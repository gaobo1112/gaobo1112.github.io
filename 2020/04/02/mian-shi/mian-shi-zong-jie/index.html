<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="面试总结, c++,java,后台开发">
    <meta name="description" content="常见题目jvm深入理解java虚拟机

介绍jvm的内存区域(运行时数据)     
判断对象已经死亡
简介强，软,弱,虚引用
简介垃圾收集算法以及各自特点
常见的垃圾收集器有哪些。
吞吐量有限和响应优先的垃圾收集器如何选择。
内存分配与内">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>面试总结 | 苏北之</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="苏北之" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">苏北之</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">苏北之</div>
        <div class="logo-desc">
            
             c++，linux，java
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/19.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">面试总结</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E9%9D%A2%E8%AF%95/">
                                <span class="chip bg-color">面试</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" class="post-category">
                                面试总结
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-04-01
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="常见题目"><a href="#常见题目" class="headerlink" title="常见题目"></a>常见题目</h2><h3 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h3><p>深入理解java虚拟机</p>
<ul>
<li>介绍jvm的内存区域(运行时数据)     </li>
<li>判断对象已经死亡</li>
<li>简介强，软,弱,虚引用</li>
<li>简介垃圾收集算法以及各自特点</li>
<li>常见的垃圾收集器有哪些。</li>
<li>吞吐量有限和响应优先的垃圾收集器如何选择。</li>
<li>内存分配与内存策略(对象何时进入老年态)。</li>
<li>虚拟机性能监控和故障处理工具。</li>
<li>class类文件的结构。</li>
<li>简介jvm类内存加载机制。</li>
<li>简介jvm中的类加载器和双亲委派模型。</li>
<li>简介jvm静态分派和动态分派。</li>
<li>jvm启动之client和server</li>
<li>如何优化java gc</li>
<li>jvm有哪些进程启动</li>
<li>java8 的元空间。</li>
</ul>
<h3 id="java并发"><a href="#java并发" class="headerlink" title="java并发"></a>java并发</h3><ul>
<li>线程状态有哪些</li>
<li>并发级别有哪些</li>
<li>happen-before的原则是什么</li>
<li>创建线程的几种方式</li>
<li>线程基本操作</li>
<li>volatile和synchronized的区别</li>
<li>sychronized关键字有什么问题。</li>
<li>线程同步的方式</li>
<li>线程之间的协作</li>
<li>ConcurrentHashMap实现原理。</li>
<li>多线程锁的优化</li>
<li>CAS</li>
<li>JUC并发包的队列和原子类。</li>
<li>简述线程池。</li>
<li>线程池的增长策略(任务调度)</li>
<li>线程池的拒绝策略</li>
<li>快速失败和安全失败</li>
<li>AQS原理</li>
<li>异常体系。</li>
</ul>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>mysql必知必会，mysql技术内幕</p>
<ul>
<li>数据库ACID特性</li>
<li>四大隔离级别，以及不可重复读和幻影读的出现原因。</li>
<li>封锁的粒度锁的类型</li>
<li>b+树原理，与其他查找树比较</li>
<li>b+树索引和hash索引比较</li>
<li>mysql索引有哪些</li>
<li>mysql优化</li>
<li>innodb和myisam的比较</li>
<li>聚集索引和非聚集索引</li>
<li>水平切分与垂直切分</li>
<li>主从复制原理，作用，实现</li>
<li>数据库char和varchar的区别</li>
<li>数据库的热备份和冷备份</li>
<li>红黑树和调表</li>
<li>数据库视图和存储过程</li>
<li>数据库操作(加索引，加锁)</li>
<li>sql实战练习(牛客)</li>
</ul>
<h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><p>redis设计与实现</p>
<ul>
<li>简述下redis(为什么使用redis)</li>
<li>为什么说redis且性能高</li>
<li>redis的5种数据类型，8中数据结构</li>
<li>redis的过期策略和缓存淘汰机制</li>
<li>redis中持久化机制</li>
<li>redis集群的主从复制</li>
<li>缓存雪崩和缓存穿透问题</li>
<li>缓存和数据库的数据统一问题</li>
</ul>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>tcp&#x2F;ip详解</p>
<ul>
<li>计算机网络分层</li>
<li>tcp和udp的区别</li>
<li>tcp三次握手和四次挥手</li>
<li>tcp协议-如何保证可靠传输</li>
<li>DNS域名解析</li>
<li>http报文结构和状态码</li>
<li>get和post的比较:作用，参数，安全性，幂等性，可缓存</li>
<li>cookies作用，安全性问题和session的比较</li>
<li>短连接和长连接，流水线</li>
<li>http的安全问题</li>
<li>http和ftp的异同点</li>
<li>输入网址发生过程</li>
<li>大数据中用到心跳机制的关键</li>
</ul>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul>
<li>进程、线程、协程的区别</li>
<li>进程间的通信方式</li>
<li>进程调度算法</li>
<li>死锁条件和处理方法</li>
<li>内存管理</li>
<li>io管理</li>
</ul>
<h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><ul>
<li>文件系统的原理，特别是inode和block</li>
<li>软连接和硬连接</li>
<li>僵尸进程和孤儿进程的区别，从sigchld分析产生僵尸进程的原因</li>
<li>常用指令</li>
</ul>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li>模板方法模式</li>
<li>外观实际模式</li>
<li>适配器模式</li>
<li>单例模式</li>
<li>装饰设计模式</li>
<li>简介java设计模式之动态代理</li>
<li>观察值模式</li>
</ul>
<h3 id="java-web"><a href="#java-web" class="headerlink" title="java web"></a>java web</h3><ul>
<li>深入分析javaio的工作机制</li>
<li>深入分析javaweb的中文编码</li>
<li>javac编译原理</li>
<li>虚拟机内容</li>
<li>servlet工作原理解析</li>
<li>深入理解session和cookie</li>
</ul>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul>
<li>git和github</li>
<li>maven</li>
</ul>
<h3 id="mapreduce的过程和细节"><a href="#mapreduce的过程和细节" class="headerlink" title="mapreduce的过程和细节"></a>mapreduce的过程和细节</h3><ul>
<li>简介mapreduce整个流程</li>
<li>文件切片</li>
<li>环形缓冲区的底层实现</li>
<li>shuffle机制</li>
<li>mapreduce细节问题</li>
<li>全排序</li>
<li>辅助排序(二次排序)</li>
<li>join(hive sql底层基本一致)</li>
<li>分布式缓存</li>
</ul>
<h3 id="YARN"><a href="#YARN" class="headerlink" title="YARN"></a>YARN</h3><ul>
<li>简述mapreduce1工作机制</li>
<li>简述yarn(mapreduce2)工作机制</li>
<li>简述yarn中application master向resource manager申请资源的过程</li>
<li>比较mapreduce1和2</li>
<li>简述yarn中resource manager总体结构</li>
<li>简述yarn中的资源调度器</li>
<li>简述yarn中内存和cpu调度(资源管理)，和资源隔离机制</li>
<li>简述yarn中container的概念</li>
<li>yarn中各部分运行故障如何处理(作业运行失败可能的原因)</li>
<li>yarn中常见问题以及解决方案。</li>
<li>yarn中resource manager的高可用实现(主备切换的底层实现)</li>
<li>yarn中resource mananger的高可用中出现脑裂问题的解决。</li>
</ul>
<h3 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h3><ul>
<li>简述事务四大特性以及隔离性问题</li>
<li>简述下分布式系统和cap，base理论</li>
<li>分布式系统下的一致性协议(2pc&#x2F;3pc&#x2F;paxos)</li>
<li>简述zookerper中分布式协议zab协议</li>
<li>zookerper系统模型(核心watcher监听机制)</li>
<li>会话创建过程以及底层实现</li>
<li>leader选举过程以及底层实现</li>
<li>zooperker数据存储的介绍</li>
<li>zookerper服务器启动流程简介</li>
<li>构建zookerper高可用集群</li>
<li>zookerper典型应用场景总结</li>
<li>raft协议</li>
</ul>
<h3 id="hdfs"><a href="#hdfs" class="headerlink" title="hdfs"></a>hdfs</h3><ul>
<li>简述hdfs的各节点之间的通信问题</li>
<li>hdfs中rpc的通信接口以及主要功能</li>
<li>hdfs中流式接口及主要功能</li>
<li>简述hadoop远程调用过程底层核心实现过程。</li>
<li>hdfs中客户端与namenode中rpc通信实例</li>
<li>简述下namenode作用</li>
<li>hdfs中namenode文件系统目录树管理</li>
<li>hdfs中namenode对数据块和数据节点的管理</li>
<li>hdfs数据块副本状态的管理</li>
<li>namenode中对数据块的增加的管理</li>
<li>namenode中数据块副本的删除的管理</li>
<li>namenode中数据块副本的复制的管理</li>
<li>namenode中数据块副本监控线程</li>
<li>namenode对块汇报的处理</li>
<li>namenode管理datanode添加和撤销</li>
<li>namenode对datenode的启动过程管理</li>
<li>namenode对datenode的心跳处理</li>
<li>namenode种的租约管理</li>
<li>namenode中的集中式缓存管理</li>
<li>namenode中的安全模式</li>
<li>namenode中的高可用的实现</li>
<li>namenode中高可用的脑裂问题</li>
<li>namenode中的启动过程底层分析。</li>
<li>hdfs的1.x和2.x架构以及区别</li>
<li>datanode升级机制和过程</li>
<li>datanode磁盘目录结构</li>
<li>datanode数据层实现</li>
<li>datanode逻辑层的实现(处理hdfs逻辑，管理块池和nodename通信o)</li>
<li>datenode流式接口的实现(服务层)</li>
<li>datanode中dataxcerver的读数据</li>
<li>datanode宏读取数据的两种方式</li>
<li>datanode中dataxcerver的写数据</li>
<li>简述hadoop的安全认证问题</li>
<li>如何衡量hadoop中两个节点的距离</li>
<li>简述java序列化对hadoop自带序列化机制以及其区别</li>
<li>简述hadoop的压缩和压缩框架</li>
</ul>
<h3 id="spark，storm，flink函数句处理"><a href="#spark，storm，flink函数句处理" class="headerlink" title="spark，storm，flink函数句处理"></a>spark，storm，flink函数句处理</h3><ul>
<li>scala编程入门</li>
<li>代码示例</li>
<li>类，对象，继承</li>
<li>模式匹配</li>
<li>隐世转换</li>
</ul>
<p>spark</p>
<ul>
<li>spark的算子有哪些</li>
<li>spark的rdd理解</li>
<li>rdd分区函数的实现</li>
<li>spark的运行模式</li>
<li>spark运行的基本流程</li>
<li>spark的任务调度模块是实现</li>
<li>spark的存储管理架构</li>
<li>spark的rdd容错机制</li>
<li>对spark的shuffle过程介绍</li>
<li>spark相对于hadoop和mapreduce在shuffle有哪些优化</li>
<li>spark解决数据倾斜</li>
<li>sparksql的三种jion实现</li>
<li>简介spark streaming</li>
<li>spark streaming性能调优手段</li>
<li>spark streaming容错机制</li>
<li>spark streaming反压机制</li>
</ul>
<p>storm</p>
<ul>
<li>简述storm的流式数据处理</li>
<li>提高storm的并发度</li>
<li>storm中stream grouping的几种方式</li>
<li>storm中的容错机制</li>
<li>storm的反压机制</li>
</ul>
<p>flink</p>
<ul>
<li>简述flink</li>
<li>flink的架构</li>
<li>flink的windows机制和时间概念</li>
<li>flink的容错机制</li>
<li>flink的反压机制</li>
<li>flink如何是实现反压机制</li>
<li>flink如何在jvm内部实现自己的内存管理</li>
<li>storm,spark streaming,flink比较</li>
</ul>
<p>hbase</p>
<ul>
<li>hbase在数据库中的地位</li>
<li>简述hbase(数据模型，架构)</li>
<li>简述hbase的读写底层实现过程</li>
<li>hbase在写过程中region的切分过程</li>
<li>hbase在建表是的设计原则</li>
<li>hbase的增删查和实现</li>
<li>hbase的过滤器</li>
<li>hbase的协处理器</li>
<li>hbase的二次索引</li>
<li>每天百亿数据存入hbase，如何保证数据的存储正确和在规定的时间内全部写入完毕，不留数据</li>
<li>hbase的优化方法</li>
<li>hbase中的region server发生故障的处理方法</li>
</ul>
<p>kafka</p>
<ul>
<li>简述kafka</li>
<li>kafka如何保证消息有序性</li>
<li>kafka消息的存储机制</li>
<li>相比较传统消息队列，kafka的区别</li>
<li>消息丢失和消息重复</li>
<li>spark streaming和kafka连接</li>
</ul>
<p>数据仓库和hive</p>
<ul>
<li>什么是数据仓库，数仓的架构</li>
<li>数仓事务表和维度表</li>
<li>数仓多维数据模型</li>
<li>数据库和数据仓库有什么区别</li>
<li>构建企业级数据仓库五步骤</li>
<li>数据仓库部分术语</li>
</ul>
<p>hive</p>
<ul>
<li>hive的简介</li>
<li>hive的内部表和外部表区别和使用</li>
<li>hive和传统数据库之间的区别</li>
<li>hive和hbase的区别</li>
<li>hive的分区</li>
<li>hive的分桶</li>
<li>hive严格模式</li>
<li>hive中的排序关键字有哪些</li>
<li>hive的join底层是实现</li>
<li>hive导入数据的四种方式</li>
<li>hive中数据倾斜的原因</li>
<li>hive性能调优</li>
<li>hive的udf和udaf和udft</li>
</ul>
<p>java程序员面试宝典</p>
<ul>
<li>10亿数据中找出最大的1000个数</li>
<li>大数据面试问题分而治之。</li>
</ul>
<h2 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h2><ol>
<li><p>面向对象的特征有哪些&#x2F;接口和抽象类的区别&#x2F;java面向对象的三大特性</p>
<ul>
<li>抽象：抽象是将一类对象的共同特征总结出来构造类的过程，<code>java</code>中包括抽象类和接口，抽象类和接口的区别如下:<ul>
<li>接口的方法默认是<code>public</code>的，所有方法在接口中不能有实现，但是在<code>java8</code>接口方法可以有默认实现，抽象类可以有非抽象的方法。</li>
<li>接口中抽了<code>static</code>和<code>final</code>变量，不能有其他变量，抽象类没有这个规定。</li>
<li>一个类可以实现多个接口，但是一个类只能实现一个抽象方法，接口自己也可以通过<code>extends</code>关键字扩展多个接口。</li>
<li>接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。</li>
<li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li>
<li><code>java8</code>接口可以定义默认方法，也可以顶一个静态方法，当一个类实现了两个接口时，两个接口有一样的默认方法，该类必须要重写方法，否则会产生歧义，通过该类的对象会不知道调用哪个接口的默认方法。</li>
<li><code>java9</code>在引入了私有方法和私有静态方法。这两个方法都需要有实现。</li>
</ul>
</li>
<li>继承<ul>
<li>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。继承的注意事项：<ul>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ul>
</li>
<li>继承的底层原理:<ul>
<li>JAVA继承并不是复制，只是获取了父类的引用super。另外JAVA的继承是在JVM编译阶段就执行好了的，首先执行父类的构造方法，然后执行子类的构造方法，子类只是获取了父类对象在内存中的引用。</li>
</ul>
</li>
</ul>
</li>
<li>封装<ul>
<li>通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。  我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装  。</li>
</ul>
</li>
<li>多态<ul>
<li>方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）  ，是子类对父类的允许访问的方法的实现过程进行重新编写。方法重载可以理解成不同参数的方法其实是不同的方法，方法名在编译的时候并不相同。方法重写是。而重载的实现是虚函数表，所谓虚方法表，就是在类加载的时候，为每个类创建一个表，这个表包括该类的对象所有动态绑定的方法及其地址，包括父类的方法，但一个方法只有一条记录，子类重写了父类方法后只会保留子类的。重载发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</li>
</ul>
</li>
</ul>
</li>
<li><p>一个类的基本信息有哪些?</p>
<ol>
<li><p>类变量(静态变量)：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> b<span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">static</span> String c<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> d<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li><p>类初始化代码:</p>
<ol>
<li><p>自定义静态变量的赋值语句。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li><p>静态代码初始块</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token keyword">static</span><span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"static scrop"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>	
</code></pre>
</li>
</ol>
</li>
<li><p>类方法(静态方法)</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>   
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"class static method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li><p>实例变量</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li><p>实例初始化代码</p>
<ol>
<li><p>定义实例变量时的赋值语句</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>				<span class="token comment" spellcheck="true">//定义时没有赋值，编译器会有个一个默认值</span>
    
    <span class="token keyword">public</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>		<span class="token comment" spellcheck="true">//构造方法变量进行初始化，如果没有会有一个默认构造函数对变量赋初值。</span>
    <span class="token punctuation">}</span>
    
    <span class="token punctuation">{</span>
        a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//实例初始化代码块</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li><p>实例初始化代码</p>
</li>
<li><p>构造方法</p>
</li>
</ol>
</li>
<li><p>实例方法</p>
</li>
<li><p>父类信息引用:</p>
</li>
</ol>
</li>
<li><p>类中各部分代码执行的顺序。</p>
<ol>
<li><p>在类加载的第三阶段也就是准备阶段完成对类变量分配内存并为类变量赋初值的过程，这里要理解的是这个如<code>public static int = 123</code>的语句在准备阶段后的值是0，而把value赋值为123的·<code>putstatic</code>指令是程序被编译后， 存放于类构造器<code>&lt;clint()&gt;</code> 方法之中， 所以把value赋值为123的动作将在初始化阶段才会执行。  实例变量将会在对象实例化时随着对象一起分配在Java堆中  ,<code>clinit()	</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（ static{}块） 中的语句合并产生的， 编译器收集的顺序是由语句在源文件中出现的顺序所决定的， 静态语句块中只能访问到定义在静态语句块之前的变量， 定义在它之后的变量， 在前面的静态语句块可以赋值， 但是不能访问 。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token keyword">static</span><span class="token punctuation">{</span>
        i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>						<span class="token comment" spellcheck="true">//可以对变量赋值</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printlin</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment" spellcheck="true">//编译器会提示非法向前引用，因为这块代码在前面看不到后面</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li><p>父类的<code>clinit</code>方法会在子类之前调用，虚拟机保证。父类中定义的静态语句块要优先于子类的变量赋值操作  。</p>
</li>
<li><p>实例变量在对象被创建出来的时候才会被创建，每个对象除了保存类的实例变量之外，还保存着实际类信息的引用。，创建对象的过程：</p>
<ol>
<li>分配内存。</li>
<li>对所有实例变量赋默认值。</li>
<li>执行实例初始化代码。</li>
</ol>
</li>
</ol>
</li>
<li><p>访问修饰符 public,private,protected,以及不写（默认）时的区别？  	</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>当前类</th>
<th>同包</th>
<th>子类</th>
<th>其他包</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<ul>
<li>类的成员不写访问修饰时默认为 default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java 中，外部类的修饰符只能是 public 或默认，类的成员（包括内部类）的修饰符可以是以上四种 。</li>
</ul>
</li>
<li><p>String 是最基本的数据类型吗？  </p>
<ul>
<li>不是，基本数据类型只有8中，其他全部是引用类型</li>
</ul>
</li>
<li><p>float f&#x3D;3.4;是否正确？  、</p>
<ul>
<li>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f &#x3D;(float)3.4; 或者写成 float f &#x3D;3.4F;</li>
</ul>
</li>
<li><p>short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗？  </p>
<ul>
<li>第一个有错误，s1+1是int类型如果要赋值给short需要类型转换，而第二个+&#x3D;有隐含的强制类型转换。也即使说第二个在编译的时候会变成<code>s1 = (short)(s1+1);</code></li>
</ul>
</li>
<li><p>int 和 Integer 有什么区别？  </p>
<ul>
<li>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱&#x2F;拆箱机制，使得二者可以相互转换。如果整型字面量的值在-128 到 127 之间，那么不会 new 新的 Integer对象，而是直接引用常量池中的 Integer 对象</li>
</ul>
</li>
<li><p>java有没有引用传递?</p>
<ul>
<li>java只有值传递，但是我们在传递一个对象的时候其实是将这个对象的地址作为一个值传入到了函数当中，所以也能完成对对象属性的修改。也即使说我们将一个对象传递到一个方法中的时候，实际上传递的是该引用的一个副本，但是这个副本也是执行堆中的一块区域的，所以也可以改变值。</li>
</ul>
</li>
<li><p>String 和 StringBuilder、StringBuffer 的区别？  </p>
<ul>
<li>String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以 String 对象是不可变的。</li>
<li>而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</li>
<li>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</li>
<li>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。</li>
</ul>
</li>
<li><p>char 型变量中能不能存贮一个中文汉字，为什么  </p>
<ul>
<li>char 类型可以存储一个中文汉字，因为 Java 中使用的编码是 Unicode（不选择<br>任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一<br>个 char 类型占 2 个字节（16 比特），所以放一个中文是没问题的。</li>
</ul>
</li>
<li><p>静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？  </p>
<ul>
<li>Static Nested Class 是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化</li>
</ul>
</li>
<li><p>Java 中会存在内存泄漏吗，请简单描述。  </p>
<ul>
<li>理论上 Java 因为有垃圾回收机制（ GC）不会存在内存泄露问题（这也是 Java 被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被 GC 回收 ，因此也会导致内</li>
<li>泄露的发生 。</li>
</ul>
</li>
<li><p>Error 和 Exception 有什么区别</p>
<ul>
<li>Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；<br>也就是说，它表示如果程序运行正常，从不会发生的情况</li>
</ul>
</li>
<li><p><code>&lt;? extends T&gt;</code>和<code>&lt;? super T&gt;</code>的区别？</p>
<ol>
<li><? extends T> 表示类型的上界，表示参数化类型的可能是T 或是 T的子类;带来的好处就是可以用子类去给父类赋值了。</li>
<li><? super T> 表示类型下界（Java Core中叫超类型限定），表示参数化类型是此类型的超类型（父类型），这句话的意思也即是参数的类型可能是T或者T的祖先们。</li>
<li>参数写成：T&lt;? super B&gt;，对于这个泛型，?代表容器里的元素类型，由于只规定了元素必须是B的超类，导致元素没有明确统一的“根”（除了Object这个必然的根），所以这个泛型你其实无法使用它，对吧，除了把元素强制转成Object。所以，对把参数写成这样形态的函数，你函数体内，只能对这个泛型做<strong>插入操作，而无法读</strong></li>
<li>参数写成： T&lt;? extends B&gt;，由于指定了B为所有元素的“根”，你任何时候都可以安全的用B来使用容器里的元素，但是插入有问题，由于供奉B为祖先的子树有很多，不同子树并不兼容，由于实参可能来自于任何一颗子树，所以你的插入很可能破坏函数实参，所以，对这种写法的形参，<strong>禁止做插入操作，只做读取</strong>。</li>
<li>Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</li>
</ol>
</li>
<li><p>理解lambda表达式吗</p>
<ol>
<li>lambda表达式是为了是实现函数式编程的，如果一个接口只有一个需要子类重写的方法，那么我们就可以使用lambda表达式方便的实现一个类。</li>
<li>Lambda 表达式中要用到的，但又未在 Lambda 表达式中声明的变量，必须声明为 final 或者是 effectively final，否则就会出现编译错误。</li>
</ol>
</li>
</ol>
<h2 id="JAVA容器"><a href="#JAVA容器" class="headerlink" title="JAVA容器"></a>JAVA容器</h2><p><img src="C:\Users\gaobo\AppData\Roaming\Typora\typora-user-images\image-20200509134711734.png" alt="image-20200509134711734"></p>
<ol>
<li><p>Collection简介?</p>
</li>
<li><p>Collection接口也就是集合，集合可以存储多个元素，但是对多个元素有一定的要求：</p>
<ol>
<li><p>多个元素能按照某种规则排序。</p>
</li>
<li><p>接口中定义了一些子类或者接口需要重写的方法，还有一些有实现的默认方法。</p>
</li>
<li><p>该接口继承自Iterable接口，Iterable接口源码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Iterator<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Objects<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Spliterator<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Spliterators<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span>Consumer<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     *实现这个接口的的类允许使用"for-each loop"语句来遍历。
     */</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterable</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">/**
     *返回一个元素类型为T的迭代器
     */</span>
    Iterator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     jdk1.8新增的遍历方式
     */</span>
    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">forEach</span><span class="token punctuation">(</span>Consumer<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>T t <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            action<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 暂不研究
     */</span>
    <span class="token keyword">default</span> Spliterator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">spliterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> Spliterators<span class="token punctuation">.</span><span class="token function">spliteratorUnknownSize</span><span class="token punctuation">(</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li><p>Iterator是定义了三个方法和实现了一个默认的方法，源码如下:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> java<span class="token punctuation">.</span>util<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span>Consumer<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//返回集合中是否有更多的元素</span>
    <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//返回集合中的下一个元素</span>
    E <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token string">"remove"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">forEachRemaining</span><span class="token punctuation">(</span>Consumer<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> E<span class="token operator">></span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            action<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li><p>Collection的源码如下:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> java<span class="token punctuation">.</span>util<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span>Predicate<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>stream<span class="token punctuation">.</span>Stream<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>stream<span class="token punctuation">.</span>StreamSupport<span class="token punctuation">;</span>


<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Collection</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Iterable</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//返回集合中元素的个数</span>
    <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//判断集合是否是空的</span>
    <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//判断集合手否处在某个元素</span>
    <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//返回一个迭代器</span>
    Iterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//返回一个包含所有元素的数组</span>
    Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  
    <span class="token operator">&lt;</span>T<span class="token operator">></span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// Modification Operations</span>

    <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">boolean</span> <span class="token function">containsAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">boolean</span> <span class="token function">removeAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">removeIf</span><span class="token punctuation">(</span>Predicate<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> E<span class="token operator">></span> filter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>filter<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> removed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> Iterator<span class="token operator">&lt;</span>E<span class="token operator">></span> each <span class="token operator">=</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>each<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>filter<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>each<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                each<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                removed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> removed<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token keyword">boolean</span> <span class="token function">retainAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token comment" spellcheck="true">// Comparison and hashing</span>

    <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">default</span> Stream<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> StreamSupport<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token function">spliterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">default</span> Stream<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">parallelStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> StreamSupport<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token function">spliterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li><p>AbstractCollection是一个实现了Collection接口的抽象类，除了iterator()和size()接口，它提供了一些其他接口的默认实现，其他集合类可以继承此类来复用。</p>
</li>
</ol>
</li>
<li><p>说下list，set和map的区别？</p>
<ol>
<li><strong>List(对付顺序的好帮手)：</strong> List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</li>
<li><strong>Set(注重独一无二的性质):</strong> 不允许重复的集合。不会有多个元素引用相同的对象。</li>
<li><strong>Map(用Key来搜索的专家):</strong> 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</li>
</ol>
</li>
<li><p>ArrayList和LinkedList的区别，以及LinkedList和ArrayDeque？</p>
<ol>
<li>**是否保证线程安全  **<code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li>
<li><strong>插入和删除是否受元素位置的影响：</strong> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e) </code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element) </code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></li>
<li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index) </code>方法)。</li>
<li><strong>内存空间占用：</strong> ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ol>
</li>
<li><p>ArrayList和Deque的区别?</p>
<ol>
<li><code>Vector</code>类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。<code>Arraylist</code>不是同步的，所以在不需要保证线程安全时建议使用Arraylist。</li>
</ol>
</li>
<li><p>说下ArrayList的扩容机制?</p>
<ol>
<li><strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。</strong> </li>
<li><strong>int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1,所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity为偶数就是1.5倍，否则是1.5倍左右）！</strong></li>
</ol>
</li>
<li><p>HashMap和HashTable的区别？</p>
<ol>
<li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li>
<li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对Null key 和Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制</li>
</ol>
</li>
<li><p>HashSet如何检查重复</p>
</li>
</ol>
<pre><code>  1. 当你把对象加入`HashSet`时，HashSet会先计算对象的`hashcode`值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用`equals()`方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。
  2. hashcode()和equals的相关规定?
     1. 如果两个对象相等，则hashcode一定也是相同的
     2. 两个对象相等,对两个equals方法返回true
     3. 两个对象有相同的hashcode值，它们也不一定是相等的
     4. 综上，equals方法被覆盖过，则hashCode方法也必须被覆盖
     5. hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。
  3. ==和equal的区别
     1. ==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同
     2. ==是指对内存地址进行比较 equals()是对字符串的内容进行比较
     3. ==指引用是否相同 equals()指的是值是否相
</code></pre>
<ol start="8">
<li><p>hashMap的底层实现?</p>
<ol>
<li><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p>
</li>
<li><p>JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>
<pre class=" language-java"><code class="language-java">    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">int</span> h<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">// key.hashCode()：返回散列值也就是hashcode</span>
      <span class="token comment" spellcheck="true">// ^ ：按位异或</span>
      <span class="token comment" spellcheck="true">// >>>:无符号右移，忽略符号位，空位都以0补齐</span>
      <span class="token comment" spellcheck="true">//如果key是null的话hash值是零，否则用key的hashCode和它本身的右移16位进行XOR运算，这样做是为了避免hash算法不好导致key.hashCode()分布不够均匀</span>
      <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre>
<p>对比一下 JDK1.7的 HashMap 的 hash 方法源码.</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// This function ensures that hashCodes that differ only by</span>
    <span class="token comment" spellcheck="true">// constant multiples at each bit position have a bounded</span>
    <span class="token comment" spellcheck="true">// number of collisions (approximately 8 at default load factor).</span>

    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>
</li>
<li><p>相比于之前的版本， JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
</li>
</ol>
</li>
<li><p>HashMap的长度为什么要是二的次幂?</p>
<ol>
<li>“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</li>
</ol>
</li>
<li><p>HashMap扩容机制？</p>
<ol>
<li>初始容量定义：默认为1 &lt;&lt; 4（16）。最大容量为1&lt;&lt; 30</li>
<li>扩容加载因子为(0.75)，第一个临界点在当HashMap中元素的数量大于table数组长度<em>加载因子（16**0.75&#x3D;12），<br>则按oldThr &lt;&lt; 1（原长度</em>2）扩容。</li>
</ol>
</li>
<li><p>底层容器总结:</p>
<p>​	1.List</p>
<ul>
<li><strong>Arraylist：</strong> Object数组</li>
<li><strong>Vector：</strong> Object数组</li>
<li><strong>LinkedList：</strong> 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环)</li>
</ul>
<ol start="2">
<li>Set</li>
</ol>
<ul>
<li><strong>HashSet（无序，唯一）:</strong> 基于 HashMap 实现的，底层采用 HashMap 来保存元素</li>
<li><strong>LinkedHashSet：</strong> LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的</li>
<li><strong>TreeSet（有序，唯一）：</strong> 红黑树(自平衡的排序二叉树)</li>
</ul>
<ol start="3">
<li>Map</li>
</ol>
<ul>
<li><strong>HashMap：</strong> JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li><strong>LinkedHashMap：</strong> LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>
<li><strong>Hashtable：</strong> 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><strong>TreeMap：</strong> 红黑树（自平衡的排序二叉树）</li>
</ul>
</li>
<li><p>ConcurrentHashMap和HashTable区别?</p>
<ol>
<li><strong>底层数据结构：</strong> JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ol>
</li>
<li><p>怎么选择集合?</p>
<ol>
<li>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用Map接口下的集合，需要排序时选择TreeMap,不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap.当我们只需要存放元素值时，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList，然后再根据实现这些接口的集合的特点来选用。</li>
</ol>
</li>
</ol>
<h2 id="jvm-1"><a href="#jvm-1" class="headerlink" title="jvm"></a>jvm</h2><ol>
<li><p>jvm基本概念？</p>
<ul>
<li>jvm可以理解为运行java代码的假象的计算机，包括一套字节码指令集，一组寄存器，一个栈，一个垃圾回收，堆和一个存储方法域。jvm是运行在操作系统之上的，与硬件没有直接的联系。</li>
</ul>
</li>
<li><p>java文件的运行过程？</p>
<ul>
<li>java源文件通过编译器编程字节码文件，字节码文件通过jvm变成机械码，可以在操作系统上运行，扩平台是因为每个平台的编译器不同，但是jvm是相同的。</li>
</ul>
</li>
<li><p>jvm后台运行的线程有哪些？</p>
<ul>
<li>虚拟机线程，这个线程等待 JVM 到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当堆修改无法进行时，线程都需要 JVM 位于安全点。这些操作的类型有： stop-theworld 垃圾回收、线程栈 dump、线程暂停、线程偏向锁（biased locking）解除。</li>
<li>周期性任务线程：这线程负责定时器事件（也就是中断），用来调度周期性操作的执行。</li>
<li>GC 线程 这些线程支持 JVM 中不同的垃圾回收活动。</li>
<li>编译器线程 这些线程在运行时将字节码动态编译成本地平台相关的机器码。</li>
<li>信号分发线程 这个线程接收发送到 JVM 的信号并调用适当的 JVM 方法处理</li>
</ul>
</li>
<li><p>java内存区域(**)</p>
<ul>
<li>VM 内存区域主要分为线程私有区域(程序计数器、虚拟机栈、本地方法区)、线程共享区域(JAVA 堆、方法区)、直接内存。线程私有数据区域生命周期与线程相同, 依赖用户线程的启动&#x2F;结束 而 创建&#x2F;销毁。线程共享区域随虚拟机的启动&#x2F;关闭而创建&#x2F;销毁。直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用: 在 JDK 1.4 引入的 NIO 提供了基于 Channel 与 Buffer 的 IO 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I&#x2F;O 扩展), 这样就避免了在 Java堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。</li>
<li>程序计数器：<ul>
<li>一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有” 的内存。</li>
<li>正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址） 。</li>
<li>如果还是 Native 方法，则为空。这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域</li>
</ul>
</li>
<li>虚拟机栈：<ul>
<li>是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</li>
</ul>
</li>
<li>本地方法区：<ul>
<li>本地方法区和 Java Stack 作用类似, 区别是虚拟机栈为执行 Java 方法服务, 而本地方法栈则为Native 方法服务, 如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用, 那么该栈将会是一个C 栈，但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一</li>
</ul>
</li>
<li>堆：<ul>
<li>是被线程共享的一块内存区域， 创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。 由于现代 VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、 From Survivor 区和 To Survivor 区)和老年代。</li>
</ul>
</li>
<li>方法区：<ul>
<li>我们常说的永久代(Permanent Generation), 用于存储被 JVM 加载的类信息、 常量、 静态变量、 即时编译器编译后的代码等数据. HotSpot VM把GC分代收集扩展至方法区, 即使用Java堆的永久代来实现方法区, 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存,而不必为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对常量池的回收和类型的卸载, 因此收益一般很小)。</li>
<li>在 Java8 中， 永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于： 元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。 类的元数据放入nativememory, 字符串池和类的静态变量放入 java 堆中， 这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制</li>
<li>运行时常量池（Runtime Constant Pool）是方法区的一部分。 Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 Java 虚拟机对 Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行</li>
</ul>
</li>
</ul>
</li>
<li><p>new一个对象后发生的过程？</p>
<ul>
<li>首先检查类是否已被加载如果没有执行相应的类加载过程。</li>
<li>分配内存，两种方法指针碰撞，空闲列表。Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。Java堆中内存是绝对规整的， 所有用过的内存都放在一边， 空闲的内存放在另一边， 中间放着一个指针作为分界点的指示器， 那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。如果Java堆中的内存并不是规整的， 已使用的内存和空闲的内存相互交错， 那就没有办法简单地进行指针碰撞了， 虚拟机就必须维护一个列表， 记录上哪些内存块是可用的， 在分配的时候从列表中找到一块足够大的空间划分给对象实例， 并更新列表上的记录， 这种分配方式称为“ 空闲列表” 。</li>
<li>内存分配完成后， 虚拟机需要将分配到的内存空间都初始化为零值（ 不包括对象头）。</li>
<li>虚拟机要对对象进行必要的设置， 例如这个对象是哪个类的实例、 如何才能找到类的元数据信息、 对象的哈希码、 对象的GC分代年龄等信息。 这些信息存放在对象的对象头（ Object Header） 之中。 根据虚拟机当前的运行状态的不同， 如是否启用偏向锁等， 对象头会有不同的设置方式。</li>
</ul>
</li>
<li><p>对内存的并发操作不安全怎么解决？ </p>
<ul>
<li>一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性.</li>
<li>另一种是把内存分配的动作按照线程划分在不同的空间之中进行， 即每个线程在Java堆中预先分配一小块内存， 称为本地线程分配缓冲（ Thread Local Allocation Buffer,TLAB） 。</li>
</ul>
</li>
<li><p>对象的内存布局？</p>
<ul>
<li>在HotSpot虚拟机中， 对象在内存中存储的布局可以分为3块区域： 对象头（ Header） 、 实例数据（ InstanceData） 和对齐填充（ Padding） 。</li>
<li>对象头： 第一部分用于存储对象自身的运行时数据， 如哈希码（ HashCode） 、 GC分代年龄、 锁状态标志、 线程持有的锁、 偏向线程ID、 偏向时间戳等，在32位的HotSpot虚拟机中， 如果对象处于未被锁定的状态下， 那么Mark Word的32bit空间中的25bit用于存储对象哈希码， 4bit用于存储对象分代年龄， 2bit用于存储锁标志位， 1bit固定为0，对象头的另外一部分是类型指针， 即对象指向它的类元数据的指针， 虚拟机通过这个指针来确定这个对象是哪个类的实例。 </li>
<li>接下来的实例数据部分是对象真正存储的有效信息， 也是在程序代码中所定义的各种类型的字段内容。 无论是从父类继承下来的， 还是在子类中定义的， 都需要记录起来。</li>
<li>第三部分对齐填充并不是必然存在的， 也没有特别的含义， 它仅仅起着占位符的作用。 由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍， 换句话说， 就是对象的大小必须是8字节的整数倍。</li>
</ul>
</li>
<li><p>对象访问的方式？</p>
<ul>
<li>如果使用句柄访问的话， 那么Java堆中将会划分出一块内存来作为句柄池， reference中存储的就是对象的句柄地址， 而句柄中包含了对象实例数据与类型数据各自的具体地址信息。使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址， 在对象被移动（ 垃圾收集时移动对象是非常普遍的行为） 时只会改变句柄中的实例数据指针， 而reference本身不需要修改</li>
<li>如果使用直接指针访问， 那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息， 而reference中存储的直接就是对象地址，</li>
<li>String str1 &#x3D; “string”; String str2 &#x3D; new String(“string”);第一种是对象类型数据，存在方法区。第二种是对象实例数据，存在堆内存。</li>
<li>使用指针的好处是访问的速度更快，节省了一次指针定位的是时间开销。</li>
</ul>
</li>
<li><p>如何判断对象已经死亡?</p>
<ul>
<li>引用计数算法:引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关联的引用， 即他们的引用计数都不为 0， 则说明对象不太可能再被用到，那么这个对象就是可回收对象。可作为GC Roots的对象包括下面几种：虚拟机栈（ 栈帧中的本地变量表） 中引用的对象。方法区中类静态属性引用的对象。方法区中常量引用的对象。本地方法栈中JNI（ 即一般说的Native方法） 引用的对象。</li>
<li>可达性分析算法：如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。要注意的是，不可达对象不等价于可回收对象， 不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链， 那它将会被第一次标记并且进行一次筛选， 筛选的条件是此对象是否有必要执行finalize（ ） 方法。</li>
<li>永久代的垃圾收集主要回收两部分内容： 废弃常量和无用的类。 回收废弃常量与回收Java堆中的对象非常类似。 以常量池中字面量的回收为例， 假如一个字符串“ abc” 已经进入了常量池中， 但是当前系统没有任何一个String对象是叫做“ abc” 的， 换句话说， 就是没有任何String对象引用常量池中的“ abc” 常量， 也没有其他地方引用了这个字面量， 如果这时发生内存回收， 而且必要的话， 这个“ abc” 常量就会被系统清理出常量池。 常量池中的其他类（ 接口） 、 方法、 字段的符号引用也与此类似。判定一个常量是否是“ 废弃常量” 比较简单， 而要判定一个类是否是“ 无用的类” 的条件则相对苛刻许多。 类需要同时满足下面3个条件才能算是“ 无用的类” ：该类所有的实例都已经被回收， 也就是Java堆中不存在该类的任何实例。加载该类的ClassLoader已经被回收。该类对应的java.lang.Class对象没有在任何地方被引用， 无法在任何地方通过反射访问该类的方法。</li>
</ul>
</li>
<li><p>引用的类型有哪些?</p>
<ul>
<li>强引用：强引用就是指在程序代码之中普遍存在的， 类似“ Object obj&#x3D;new Object（ ） ” 这类的引用， 只要强引用还存在， 垃圾收集器永远不会回收掉被引用的对象。</li>
<li>软引用：软引用是用来描述一些还有用但并非必需的对象。 对于软引用关联着的对象， 在系统将要发生内存溢出异常之前， 将会把这些对象列进回收范围之中进行第二次回收。 如果这次回收还没有足够的内存， 才会抛出内存溢出异常。 </li>
<li>弱引用:弱引用也是用来描述非必需对象的， 但是它的强度比软引用更弱一些， 被弱引用关联的对象只能生存到下一次垃圾收集发生之前。 当垃圾收集器工作时， 无论当前内存是否足够， 都会回收掉只被弱引用关联的对象</li>
<li>虚引用：虚引用也称为幽灵引用或者幻影引用， 它是最弱的一种引用关系。 一个对象是否有虚引用的存在， 完全不会对其生存时间构成影响， 也无法通过虚引用来取得一个对象实例。 为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li>
</ul>
</li>
<li><p>基本垃圾回收算法?</p>
<ul>
<li>标记清除算法（Mark-Sweep）:最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。该算法最大的问题是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题</li>
<li>复制算法（copying）:为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话， Copying 算法的效率会大大降低。</li>
<li>标记整理算法(Mark-Compact): 标记阶段和 Mark-Sweep 算法相同， 标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象</li>
<li>分代收集算法：分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured&#x2F;Old Generation)和新生代(YoungGeneration)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法<ul>
<li>JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1： 1 来划分新生代。一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。</li>
<li>而老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。</li>
</ul>
</li>
</ul>
</li>
<li><p>常见垃圾收集器有哪些？</p>
<ul>
<li>Serial 垃圾收集器（单线程、 复制算法）：Serial（英文连续） 是最基本垃圾收集器，使用复制算法，曾经是JDK1.3.1 之前新生代唯一的垃圾收集器。 Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 Serial垃圾收集器依然是 java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器。</li>
<li>ParNew 垃圾收集器（Serial+多线程）：ParNew 垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和 Serial 收集器完全一样， ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。ParNew 收集器默认开启和 CPU 数目相同的线程数，可以通过-XX:ParallelGCThreads 参数来限制垃圾收集器的线程数。 【Parallel：平行的】ParNew 虽然是除了多线程外和Serial 收集器几乎完全一样，但是ParNew垃圾收集器是很多 java虚拟机运行在 Server 模式下新生代的默认垃圾收集器</li>
<li>Parallel Scavenge 收集器（多线程复制算法、高效）：Parallel Scavenge 收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器， 它重点关注的是程序达到一个可控制的吞吐量（Thoughput， CPU 用于运行用户代码的时间&#x2F;CPU 总消耗时间，即吞吐量&#x3D;运行用户代码时间&#x2F;(运行用户代码时间+垃圾收集时间)），高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。 自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个重要区别</li>
<li>Serial Old 收集器（单线程标记整理算法 ）： Serial Old 是 Serial 垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在 Client 默认的 java 虚拟机默认的年老代垃圾收集器。在 Server 模式下，主要有两个用途：<ol>
<li>在 JDK1.5 之前版本中与新生代的 Parallel Scavenge 收集器搭配使用。</li>
<li>作为年老代中使用 CMS 收集器的后备垃圾收集方案。</li>
</ol>
</li>
<li>Parallel Old 收集器（多线程标记整理算法）:Parallel Old 收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在 JDK1.6才开始提供。在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量， Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器， 如果系统对吞吐量要求比较高，可以优先考虑新生代 Parallel Scavenge和年老代 Parallel Old 收集器的搭配策略。</li>
<li>CMS 收集器（多线程标记清除算法）:Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间， 和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段：<ol>
<li>初始标记: 只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。</li>
<li>并发标记: 进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。</li>
<li>重新标记: 为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程</li>
<li>并发清除: 清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作， 所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。<br>由于CMS并发清理阶段用户线程还在运行着， 伴随程序运行自然就还会有新的垃圾不断产生， 这一部分垃圾出现在标记过程之后， CMS无法在当次收集中处理掉它们， 只好留待下一次GC时再清理掉。CMS是一款基于“ 标记—清除” 算法实现的收集器， 如果读者对前面这种算法介绍还有印象的话， 就可能想到这意味着收集结束时会有大量空间碎片产生。 空间碎片过多时， 将会给大对象分配带来很大麻烦， 往往会出现老年代还有很大空间剩余， 但是无法找到足够大的连续空间来分配当前对象， 不得不提前触发一次Full GC。</li>
</ol>
</li>
<li>Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器， G1 收集器两个最突出的改进是：<ol>
<li>基于标记-整理算法，不产生内存碎片。</li>
<li>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。<br>G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间， 优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率.</li>
</ol>
</li>
</ul>
</li>
<li><p>内存分配和内存策略(对象何时进入老年态)</p>
<ul>
<li>大多数情况下， 对象在新生代Eden区中分配。 当Eden区没有足够空间进行分配时， 虚拟机将发起一次Minor GC</li>
<li>大对象直接进入老年代,所谓的大对象是指， 需要大量连续内存空间的Java对象， 最典型的大对象就是那种很长的字符串以及数组</li>
<li>虚拟机给每个对象定义了一个对象年龄（ Age） 计数器。 如果对象在Eden出生并经过第一次Minor GC后仍然存活， 并且能被Survivor容纳的话， 将被移动到Survivor空间中， 并且对象年龄设为1。 对象在Survivor区中每“ 熬过” 一次Minor GC， 年龄就增加1岁， 当它的年龄增加到一定程度（ 默认为15岁） ，就将会被晋升到老年代中。 </li>
<li>为了能更好地适应不同程序的内存状况， 虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代， 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半， 年龄大于或等于该年龄的对象就可以直接进入老年代， 无须等到MaxTenuringThreshold中要求的年龄。</li>
<li>在发生Minor GC之前， 虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间， 如果这个条件成立， 那么Minor GC可以确保是安全的。 如果不成立， 则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。 如果允许， 那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于， 将尝试着进行一次Minor GC， 尽管这次Minor GC是有风险的； 如果小于， 或者HandlePromotionFailure设置不允许冒险， 那这时也要改为进行一次Full GC。</li>
</ul>
</li>
<li><p>java运行时内存?</p>
<ul>
<li>新生代:是用来存放新生的对象。一般占据堆的 1&#x2F;3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden 区、 ServivorFrom、 ServivorTo 三个区。<ul>
<li>eden区：Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发minorGC，对新生代区进行一次垃圾回收。</li>
<li>ServivorFrom：上一次 GC 的幸存者，作为这一次 GC 的被扫描者。</li>
<li>ServivorTo：保留了一次 MinorGC 过程中的幸存者。</li>
</ul>
<ol>
<li>eden、 servicorFrom 复制到 ServicorTo，年龄+1首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位置了就放到老年区）；</li>
<li>清空 eden、 servicorFrom然后，清空 Eden 和 ServicorFrom 中的对象；</li>
<li>ServicorTo 和 ServicorFrom 互换</li>
<li>最后， ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区。</li>
</ol>
</li>
<li>老年代:主要存放应用程序中生命周期长的内存对象。老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。 MajorGC 的耗时比较长，因为要扫描再回收。 MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。</li>
</ul>
</li>
<li><p>java类加载机制</p>
<ul>
<li>加载：加载是类加载过程中的一个阶段， 这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象， 作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。通过类的完全限定名获取定义该类的二进制字节流<br>将该字节流表示的静态存储结构转换成运行时的存储结构，在内存中生成一个代表该类的class对象，作为方法区中该类各种数据的入口。<ul>
<li>通过一个类的全限定名获取定义此类的二进制字节流。 </li>
<li>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构  </li>
<li>在内存中生成一个代表这个类的java.lang.Class对象， 作为方法区这个类的各种数据的访问入口</li>
</ul>
</li>
<li>验证：这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</li>
<li>准备：准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。</li>
</ul>
</li>
</ol>
<ul>
<li>解析：解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。（也即是将符号引用转为确定的地址空间的过程)<br>  *  符号引用与虚拟机实现的布局无关， 引用的目标并不一定要已经加载到内存中。 各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的引用，那引用的目标必定已经在内存中存在<ul>
<li>初始化：初始化阶段才真正开始执行类中定义的Java程序代码，初始化阶段是虚拟机执行类构造器<code>&lt;clinit&gt;()</code>方法的过程，在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划	去初始化类变量和其它资源。</li>
</ul>
</li>
</ul>
<ol start="16">
<li><p>类加载器的种类？</p>
<ul>
<li>启动类加载器(Bootstrap ClassLoader)<ol>
<li>负责加载 JAVA_HOME\lib 目录中的， 或通过-Xbootclasspath 参数指定路径中的， 且被虚拟机认可（按文件名识别， 如 rt.jar） 的类。</li>
</ol>
</li>
<li>扩展类加载器(Extension ClassLoader)<ol start="2">
<li>负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库。</li>
</ol>
</li>
<li>应用程序类加载器(Application ClassLoader)：<ol start="3">
<li>负责加载用户路径（classpath）上的类库。JVM 通过双亲委派模型进行类的加载， 当然我们也可以通过继承 java.lang.ClassLoader<br>  实现自定义的类加载器。</li>
</ol>
</li>
</ul>
</li>
<li><p>双亲委派模型是什么？</p>
<ul>
<li>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class）， 子类加载器才会尝试自己去加载。采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。</li>
</ul>
</li>
<li><p>class文件</p>
<ul>
<li>class文件是一组8字节为基础单位的二进制流，class文件是一中类似于C语言伪结构体的结构来存储数据的，这种伪结构体中只有两种数据元素，无符号数和表。<ul>
<li>魔数与class文件的版本。</li>
<li>常量池:常量池主要包括字面量和符号引用字面量如”hello”,符号引用包括了类和接口的的全限定名、字段的名称和描述符、方法的名称和描述符。Java代码在进行Javac编译的时候， 并不像C和C++那样有“ 连接” 这一步骤， 而是在虚拟机加载Class文件的时候进行动态连接。 也就是说， 在Class文件中不会保存各个方法、 字段的最终内存布局信息， 因此这些字段、 方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址， 也就无法直接被虚拟机使用。 当虚拟机运行时，需要从常量池获得对应的符号引用， 再在类创建时或运行时解析、 翻译到具体的内存地址之中。   </li>
<li>访问标志：在常量池结束之后， 紧接着的两个字节代表访问标志（ access_flags） ， 这个标志用于识别一些类或者接口层次的访问信息， 包括： 这个Class是类还是接口； 是否定义为public类型； 是否定义为abstract类型； 如果是类的话， 是否被声明为final等。   </li>
<li>类索引、父类索引、接口索引集合:确定类的继承关系。</li>
<li>字段表集合:用来描述接口或者类中声明的变量。但是不包括类中局部变量。</li>
<li>方法表集合:用来描述接口或者类中声明的方法。</li>
</ul>
</li>
</ul>
</li>
<li><p>类加载器：</p>
<ol>
<li>从Java虚拟机的角度来讲， 只存在两种不同的类加载器： 一种是启动类加载器（ Bootstrap ClassLoader） ，<br> 这个类加载器使用C++语言实现[1]， 是虚拟机自身的一部分； 另一种就是所有其他的类加载器， 这些类加载器都由<br> Java语言实现， 独立于虚拟机外部， 并且全都继承自抽象类java.lang.ClassLoader。  </li>
<li>类加载器种类：<ul>
<li>Bootstrap：一般用本地代码实现，负责加载 JVM 基础核心类库（rt.jar）；</li>
<li>Extension：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap；、</li>
<li>System：又叫应用类加载器，其父类是 Extension。它是应用最广泛的类加载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目录中记载类，是用户自定义加载器的默认父加载器。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul>
<li><p>线程状态有哪些</p>
<ul>
<li>新建状态：当程序使用 new 关键字创建了一个线程之后，该线程就处于新建状态，此时仅由 JVM 为其分配内存，并初始化其成员变量的值</li>
<li>就绪状态（RUNNABLE）：当线程对象调用了 start()方法之后，该线程处于就绪状态。 Java 虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。</li>
<li>运行状态（RUNNING）：如果处于就绪状态的线程获得了 CPU，开始执行 run()方法的线程执行体，则该线程处于运行状态。</li>
<li>阻塞状态（BLOCKED）：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得 cpu timeslice 转到运行(running)状态。阻塞的情况分三种：<ul>
<li>等待阻塞（o.wait-&gt;等待对列） ：运行(running)的线程执行 o.wait()方法， JVM 会把该线程放入等待队列(waitting queue)中。</li>
<li>同步阻塞(lock-&gt;锁池)：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池(lock pool)中</li>
<li>其他阻塞(sleep&#x2F;join)：运行(running)的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I&#x2F;O 请求时，JVM 会把该线程置为阻塞状态。当 sleep()状态超时、 join()等待线程终止或者超时、或者 I&#x2F;O处理完毕时，线程重新转入可运行(runnable)状态。</li>
</ul>
</li>
<li>线程死亡（DEAD）线程会以下面三种方式结束，结束后就是死亡状态。<br>  正常结束<ol>
<li>run()或 call()方法执行完成，线程正常结束。<br>  异常结束</li>
<li>线程抛出一个未捕获的 Exception 或 Error。<br>  调用 stop</li>
<li>直接调用该线程的 stop()方法来结束该线程—该方法通常容易导致死锁，不推荐使用</li>
</ol>
</li>
</ul>
</li>
<li><p>创建线程的几种方式</p>
<ul>
<li>继承 Thread 类：Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。 启动线程的唯一方法就是通过 Thread 类的 start()实例方法。 start()方法是一个 native 方法，它将启动一个新线程，并执行 run()方法。</li>
<li>实现 Runnable 接口。如果自己的类已经 extends 另一个类，就无法直接 extends Thread，此时，可以实现一个Runnable 接口。</li>
<li>ExecutorService、 Callable<Class>、 Future 有返回值线程：有返回值的任务必须实现 Callable 接口，类似的，无返回值的任务必须 Runnable 接口。执行Callable 任务后，可以获取一个 Future 的对象，在该对象上调用 get 就可以获取到 Callable 任务返回的 Object 了，再结合线程池接口 ExecutorService 就可以实现有返回结果的多线程了</li>
<li>基于线程池的方式：线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建，不需要的时候销毁，是非常浪费资源的。那么我们就可以使用缓存的策略，也就是使用线程池</li>
</ul>
</li>
<li><p>volatile底层原理</p>
<ul>
<li>可见性：即当一个线程修改了声明为volatile变量的值，新值对于其他要读该变量的线程来说是立即可见的。而普通变量是不能做到这一点的，普通变量的值在线程间传递需要通过主内存来完成。</li>
<li>有序性：volatile变量的所谓有序性也就是被声明为volatile的变量的临界区代码的执行是有顺序的，即禁止指令重排序。</li>
<li>受限原子性：这里volatile变量的原子性与synchronized的原子性是不同的，synchronized的原子性是指只要声明为synchronized的方法或代码块儿在执行上就是原子操作的。而volatile是不修饰方法或代码块儿的，它用来修饰变量，对于单个volatile变量的读&#x2F;写操作都具有原子性，但类似于volatile++这种复合操作不具有原子性。所以volatile的原子性是受限制的。并且在多线程环境中，volatile并不能保证原子性。</li>
<li>有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，通过查IA-32架构软件开发者手册可知，Lock前缀的指令在多核处理器下会引发了两件事情<ul>
<li>将当前处理器缓存行的数据写回到系统内存。</li>
<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。<br>  通常处理器和内存之间都有几级缓存来提高处理速度，处理器先将内存中的数据读取到内部缓存后再进行操作，但是对于缓存写会内存的时机则无法得知，因此在一个处理器里修改的变量值，不一定能及时写会缓存，这种变量修改对其他处理器变得“不可见”了。但是，使用Volatile修饰的变量，在写操作的时候，会强制将这个变量所在缓存行的数据写回到内存中，但即使写回到内存，其他处理器也有可能使用内部的缓存数据，从而导致变量不一致，所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期，如果过期，就会将该缓存行设置成无效状态，下次要使用就会重新从内存中读取。</li>
</ul>
</li>
</ul>
</li>
<li><p>cpu如何实现原子操作？</p>
<ol>
<li>处理器自动保证基本内存操作的原子性</li>
<li>使用总线锁保证原子性</li>
<li>使用缓存锁保证原子性</li>
</ol>
</li>
<li><p>cas的底层原理？</p>
<ul>
<li>JVM中的CAS操作正是利用了上一节中提到的处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。</li>
<li>CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作。<ul>
<li><p>ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。 从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。 </p>
</li>
<li><p>循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>
</li>
<li><p>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j&#x3D;a，合并一下ij&#x3D;2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>sychronized底层原理。</p>
<ul>
<li>java文件在编译成class文件的时候，如果代码块加了sychronized，那么编译器会添加java的指令monitorenter和monitoreexit.</li>
<li>synchronized用的锁是存在Java对象头里的。不同的锁对应的对象头的内容可能会不同。</li>
<li>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率，下文会详细分析。<ul>
<li>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。因为在虚拟机启动的时候一般会有多个线程并行进行，所以默认是前几秒会关闭偏向锁。</li>
<li>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁,轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</li>
<li>前面的两种锁都不需要设计到内核态到用户态的切换，都是在jvm虚拟机就可以完成，但是重量级锁需要向操作系统申请，如果自选等待的线程较多的时候使用这种方式比较合适，操作系统会将这些线程加入到阻塞队列中，而不需要这写线程占用cpu资源了。</li>
</ul>
</li>
<li>每一个JAVA对象都会与一个监视器monitor关联，我们可以把它理解成为一把锁，当一个线程想要执行一段被synchronized圈起来的同步方法或者代码块时，该线程得先获取到synchronized修饰的对象对应的monitor。在hotSpot虚拟机中，monitor是由ObjectMonitor实现的。其源码是用c++来实现的,java对象对应的monitor也是一个临界资源，其线程安全由虚拟机自身代码来保证，开发者无需考虑。</li>
</ul>
</li>
<li><p>线程同步的方式</p>
<ul>
<li>sychronized</li>
<li>volatile</li>
<li>使用Reentrantlock(),有lock方法和unlock方法。</li>
<li>使用局部变量：如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</li>
<li>使用阻塞队列。BlockingQueue()</li>
<li>使用原子变量实现线程同步。AtomicInteger()..</li>
</ul>
</li>
<li><p>java锁有哪些？<br>  1. 乐观锁：乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。java 中的乐观锁基本都是通过 CAS 操作实现的， CAS 是一种更新的原子操作， 比较当前值跟传入值是否一样，一样则更新，否则失败。<br>  2. 悲观锁：悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如 RetreenLock。<br>  3. 自旋锁：自旋锁原理非常简单， 如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。<br>  4. Synchronized 同步锁：synchronized 它可以把任意一个非 NULL 的对象当作锁。 他属于独占式的悲观锁，同时属于可重入锁。<br>  5. ReentrantLock：ReentantLock 继承接口 Lock 并实现了接口中定义的方法， 他是一种可重入锁， 除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。<br>  6. Semaphore 信号量：Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。 Semaphore 可以用来构建一些对象池，资源池之类的， 比如数据库连接池<br>  7. 可重入锁（递归锁）本文里面讲的是广义上的可重入锁，而不是单指 JAVA 下的 ReentrantLock。 可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁。<br>  8. ReadWriteLock 读写锁为了提高性能， Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。 读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。<br>  9.  重量级锁（Mutex Lock）Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized 效率低的原因。因此， 这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为“重量级锁” 。 JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”<br>  10. 分段锁：分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践</p>
</li>
<li><p>synchronized 和 ReentrantLock 的区别</p>
<ul>
<li>两者的共同点：<ol>
<li>都是用来协调多线程对共享对象、变量的访问</li>
<li>都是可重入锁，同一线程可以多次获得同一个锁</li>
<li>都保证了可见性和互斥性</li>
</ol>
</li>
<li>两者的不同点：<ol>
<li>ReentrantLock 显示的获得、释放锁， synchronized 隐式获得释放锁</li>
<li>ReentrantLock 可响应中断、可轮回， synchronized 是不可以响应中断的，为处理锁的<br>  不可用性提供了更高的灵活性</li>
<li>ReentrantLock 是 API 级别的， synchronized 是 JVM 级别的</li>
<li>ReentrantLock 可以实现公平锁</li>
<li>ReentrantLock 通过 Condition 可以绑定多个条件</li>
<li>底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略， lock 是同步非阻<br>  塞，采用的是乐观并发策略</li>
<li>Lock 是一个接口，而 synchronized 是 Java 中的关键字， synchronized 是内置的语言<br>  实现。</li>
<li>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；<br>  而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，<br>  因此使用 Lock 时需要在 finally 块中释放锁。</li>
<li>Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，<br>  等待的线程会一直等待下去，不能够响应中断。</li>
<li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li>
<li>Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等。</li>
</ol>
</li>
</ul>
</li>
<li><p>ConcurrentHashMap实现原理。</p>
<ul>
<li>减小锁粒度<br>  减小锁粒度是指缩小锁定对象的范围，从而减小锁冲突的可能性，从而提高系统的并发能力。减小锁粒度是一种削弱多线程锁竞争的有效手段， 这种技术典型的应用是 ConcurrentHashMap(高性能的 HashMap)类的实现。对于 HashMap 而言，最重要的两个方法是 get 与 set 方法，如果我们对整个 HashMap 加锁，可以得到线程安全的对象，但是加锁粒度太大。 Segment 的大小也被称为 ConcurrentHashMap 的并发度。</li>
<li>ConcurrentHashMap 分段锁<br>  ConcurrentHashMap，它内部细分了若干个小的 HashMap，称之为段(Segment)。 默认情况下一个 ConcurrentHashMap 被进一步细分为 16 个段，既就是锁的并发度。如果需要在 ConcurrentHashMap 中添加一个新的表项，并不是将整个 HashMap 加锁，而是首先根据 hashcode 得到该表项应该存放在哪个段中，然后对该段加锁，并完成 put 操作。在多线程环境中，如果多个线程同时进行 put操作，只要被加入的表项不存放在同一个段中，则线程间可以做到真正的并行，ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。 Segment 是一种可重入锁 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色， HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组， Segment 的结构和 HashMap类似，是一种数组和链表结构， 一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素， 每个 Segment 守护一个 HashEntry 数组里的元素,当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。</li>
</ul>
</li>
<li><p>什么是AQS？</p>
<ul>
<li>AbstractQueuedSynchronizer 类如其名，抽象的队列式的同步器， AQS 定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock&#x2F;Semaphore&#x2F;CountDownLatch。</li>
<li>AQS 只是一个框架，具体资源的获取&#x2F;释放方式交由自定义同步器去实现， AQS 这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过 state 的 get&#x2F;set&#x2F;CAS)之所以没有定义成abstract ，是 因 为独 占模 式 下 只 用实现 tryAcquire-tryRelease ，而 共享 模 式 下 只用 实 现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等）， AQS 已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法</li>
<li>同步器的实现是 ABS 核心，以 ReentrantLock 为例， state 初始化为 0，表示未锁定状态。 A 线程lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前， A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</li>
</ul>
</li>
<li><p>JUC并发包的队列和原子类。</p>
<ul>
<li>&#x3D;&#x3D;ArrayBlockingQueue&#x3D;&#x3D;:由数据结构组成的有界阻塞队列。</li>
<li>&#x3D;&#x3D;LinkedBlockingQueue&#x3D;&#x3D;:由链表结构组成的有界（但大小默认值为<code>Integer.MAX_VALUE</code>)阻塞队列。</li>
<li>PriorityBlockingQueue:支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue:使用优先级队列实现的延迟无界阻塞队列。</li>
<li>&#x3D;&#x3D;SychronousQueue&#x3D;&#x3D;:不存储元素的阻塞队列，也即单个元素的队列。</li>
<li>LinkedTransferQueue:由链表结构组成的无界阻塞队列。</li>
<li>LinkedBlocking<strong>Deque</strong>:由历览表结构组成的双向阻塞队列。</li>
</ul>
</li>
<li><p>简述线程池。</p>
<ul>
<li>线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动给这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行.</li>
</ul>
<ul>
<li>Executors.newFixedThreadPool(int)</li>
</ul>
<p>   <strong>执行长期的任务，性能好很多</strong></p>
<p>   创建一个定长线程池，可控制线程最大并发数，炒出的线程回在队列中等待。</p>
<p>   newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是想到等的，他使用的是LinkedBlockingQueue</p>
<ul>
<li><p>Executors.newSingleThreadExecutor()</p>
<p><strong>一个任务一个任务执行的场景</strong></p>
<p>创建一个单线程话的线程池，他只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行</p>
<p>newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，使用LinkedBlockingQueue</p>
</li>
<li><p>Executors.newCachedThreadPool() </p>
<p><strong>执行很多短期异步的小程序或负载较轻的服务器</strong></p>
<p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲县城，若无可回收，则新建线程。</p>
<p>newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE,使用的SynchronousQueue,也就是说来了任务就创建线程运行，当县城空闲超过60s，就销毁线程</p>
</li>
</ul>
</li>
<li><p>线程池创建的参数?</p>
<ol>
<li>**&#x3D;&#x3D;corePoolSize&#x3D;&#x3D;**：线程池中常驻核心线程数</li>
</ol>
<ul>
<li>在创建了线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务</li>
<li>当线程池的线程数达到corePoolSize后，就会把到达的任务放到缓存队列当中</li>
</ul>
<ol start="2">
<li>**&#x3D;&#x3D;maximumPoolSize&#x3D;&#x3D;**：线程池能够容纳同时执行的最大线程数，必须大于等于1</li>
<li>**&#x3D;&#x3D;keepAliveTime&#x3D;&#x3D;**：多余的空闲线程的存活时间</li>
</ol>
<ul>
<li>当前线程池数量超过corePoolSize时，档口空闲时间达到keepAliveTime值时，多余空闲线程会被销毁到只剩下corePoolSize个线程为止</li>
</ul>
<ol start="4">
<li>**&#x3D;&#x3D;unit&#x3D;&#x3D;**：keepAliveTime的单位</li>
<li>**&#x3D;&#x3D;workQueue&#x3D;&#x3D;**：任务队列，被提交但尚未被执行的任务</li>
<li>**&#x3D;&#x3D;threadFactory&#x3D;&#x3D;**：表示生成线程池中工作线程的线程工厂，用于创建线程一般用默认的即可</li>
<li>**&#x3D;&#x3D;handler&#x3D;&#x3D;**：拒绝策略，表示当队列满了并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的runable的策略</li>
</ol>
</li>
<li><p>线程池的增长策略(任务调度)</p>
<ol>
<li><p>在创建了线程池之后，等待提交过来的 人物请求。</p>
</li>
<li><p>当调用execute()方法添加一个请求任务时，线程池会做出如下判断</p>
<p> 2.1 如果正在运行的线程数量小于corePoolSize，那么马上船舰线程运行这个任务；</p>
<p> 2.2 如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；</p>
<p> 2.3如果此时队列满了且运行的线程数小于maximumPoolSize，那么还是要创建非核心线程立刻运行此任务</p>
<p> 2.4如果队列满了且正在运行的线程数量大于或等于maxmumPoolSize，那么启动饱和拒绝策略来执行</p>
</li>
<li><p>当一个线程完成任务时，他会从队列中却下一个任务来执行</p>
</li>
<li><p>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程池会判断：</p>
</li>
</ol>
<p>  如果当前运行的线程数大于corePoolSize，那么这个线程会被停掉；所以线程池的所有任务完成后他最大会收缩到corePoolSize的大小</p>
</li>
<li><p>线程池的拒绝策略</p>
<ul>
<li><ul>
<li>AbortPolicy(默认)</li>
</ul>
</li>
</ul>
<p>   直接抛出RejectedExecutionException异常阻止系统正常运行</p>
<ul>
<li><p>CallerRunsPolicy</p>
<p>”调用者运行“一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量</p>
</li>
<li><p>DiscardOldestPolicy</p>
<p>抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</p>
</li>
<li><p>DiscardPolicy</p>
<p>直接丢弃任务，不予任何处理也不抛异常。如果允许任务丢失，这是最好的一种方案</p>
</li>
</ul>
</li>
</ul>
<p>​						</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">苏北之</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://gaobo1112.github.io/2020/04/02/mian-shi/mian-shi-zong-jie/">http://gaobo1112.github.io/2020/04/02/mian-shi/mian-shi-zong-jie/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">苏北之</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E9%9D%A2%E8%AF%95/">
                                    <span class="chip bg-color">面试</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/04/29/java/java-bian-cheng-ji-chu/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/5.jpg" class="responsive-img" alt="java编程基础">
                        
                        <span class="card-title">java编程基础</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-04-28
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            苏北之
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/03/06/suan-fa/dong-tai-gui-hua/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="动态规划">
                        
                        <span class="card-title">动态规划</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-03-06
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%AE%97%E6%B3%95/" class="post-category">
                                    算法
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%AE%97%E6%B3%95/">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <a href="/about" target="_blank">苏北之</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1181062873" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1181062873" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"live2d-widget-model-haru/01"},"display":{"position":"left","width":300,"height":360},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>
