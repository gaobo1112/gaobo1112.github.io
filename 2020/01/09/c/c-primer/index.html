<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="c++ primer 学习笔记, c++,java,后台开发">
    <meta name="description" content="第2章 变量和类型基本内置变量算数类型表2.1 c++算术类型  



类型
含义
最小尺寸



bool
布尔类型
未定义


char
字符
8位


wchar_t
宽字符
16


char16_t
Unicode字符
16位
">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>c++ primer 学习笔记 | 苏北之</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="苏北之" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">苏北之</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">苏北之</div>
        <div class="logo-desc">
            
             c++，linux，java
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/22.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">c++ primer 学习笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/c-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">
                                <span class="chip bg-color">c++,编程语言</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/c/" class="post-category">
                                c++
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-01-09
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="第2章-变量和类型"><a href="#第2章-变量和类型" class="headerlink" title="第2章 变量和类型"></a>第2章 变量和类型</h1><h2 id="基本内置变量"><a href="#基本内置变量" class="headerlink" title="基本内置变量"></a>基本内置变量</h2><h3 id="算数类型"><a href="#算数类型" class="headerlink" title="算数类型"></a>算数类型</h3><p>表2.1 c++算术类型  </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>最小尺寸</th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td>布尔类型</td>
<td>未定义</td>
</tr>
<tr>
<td>char</td>
<td>字符</td>
<td>8位</td>
</tr>
<tr>
<td>wchar_t</td>
<td>宽字符</td>
<td>16</td>
</tr>
<tr>
<td>char16_t</td>
<td>Unicode字符</td>
<td>16位</td>
</tr>
<tr>
<td>char32_t</td>
<td>Unicode字符</td>
<td>32位</td>
</tr>
<tr>
<td>short</td>
<td>短整型</td>
<td>16位</td>
</tr>
<tr>
<td>int</td>
<td>整型</td>
<td>32位</td>
</tr>
<tr>
<td>long</td>
<td>长整型</td>
<td>32位</td>
</tr>
<tr>
<td>long long</td>
<td>长整型</td>
<td>64位</td>
</tr>
<tr>
<td>float</td>
<td>单精度浮点数</td>
<td>6位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点数</td>
<td>10位有效数字</td>
</tr>
<tr>
<td>long double</td>
<td>扩展精度浮点数</td>
<td>10位有效数字</td>
</tr>
</tbody></table>
<p><strong>带符号类型和无符号类型</strong></p>
<p>除去比而行和扩展的字符类型之外，其他整型可以划分为带符号类型和无符号类型两种，类型int，short，long和long long 都是带符号的，通过加unsigned就可以的到无符号的类型。类型unsigned int可以缩写成unsigned。<br><br>和其他整型不同的是,字符被分为了三种：char，signed char 和unsigned char。尽管有三种但是只有两种表现形式，char的实际表现形式有编译器决定。<br><br>一般来说无符号类型所有的比特都用来存值。如8比特的unsigned char 可以表示0-255的值，而8比特的signed char表示范围是-128-127.<br></p>
<pre><code>**建议如何选择类型**
1.当明确数值不可能位负数的时候选择无符号的类型
2.使用int进行整数的运算，short常常过小，如果超过了int的类型选用long long，long和int的范围一样。
3.在算数表达是中不要使用char和bool。因为char在一些机器上是有符号的而在一些事无符号的。如果需要使用一个不大的整数请明确signed char和unsigned char
4.执行浮点数请用double，因为float的精度通常不够，且两者的计算效率差不多。
</code></pre>
<p><strong>练习2.1</strong></p>
<pre><code>    四者都可以用来表示整型，但是表示的范围不一样，short表示范围最少，long long表示范围最大，int 和long表示范围基本一致。
    无符号数所有的位都用来表示数值，而有符号数的首位可以用来表示符号。
    float是单精度的浮点数，而double是双精度的浮点数。double表示的精度更好，且两者运算效率基本无差别。
</code></pre>
<p><strong>联系2.2</strong></p>
<pre><code>    三者都可以用double来表示。
</code></pre>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>当赋值无符号类型一个超出范围的值的时候，结果是初始值对无符号类型表示数总数取模的余数。如8bit的unsigned char 可以表示0-255的数值，如果我们赋值了一个区域之外的值，结果就是该值对256取模所得的余数<br></p>
<p><strong>含有无符号类型的表达式</strong><br><br>当一个算数表达是中有无符号数有有int时。这个int值会转为无符号的数。<br></p>
<pre><code>unsigned u = 10;
int i = -42;
std::cout&lt;&lt;i+i&lt;&lt;std::endl;//输出-84
std::cout&lt;&lt;i+u&lt;&lt;std::endl;//如果int是32位，输出4294967264  = 2**32-32 
</code></pre>
<p>当从无符号数中减去一个值的时候，不管这个数是不是无符号数，我们都必须确保结果不是负数。</p>
<pre><code>unsigned u1 = 42,u2 = 10;
std::cout&lt;&lt;u2-u1&lt;&lt;std::endl;//输出取模后的结果
</code></pre>
<p><strong>提示：切勿混用带符号类型和无符号类型</strong></p>
<p><strong>练习2.3</strong></p>
<pre><code>    32,2**32-32,32,-32,0,2**32
</code></pre>
<p><strong>练习2.4</strong></p>
<pre><code>最后一个结果是0，将int转为unsigned也是变成10，所以减了之后结果是0，也无符号整数int不可能最大值是2**32-1.
</code></pre>
<h3 id="字面值变量"><a href="#字面值变量" class="headerlink" title="字面值变量"></a>字面值变量</h3><p>一个形如42的值就是<strong>字面值变量</strong>。<br><br><strong>整型和浮点型字面值</strong><br><br>整型字面值具体的数据类型有它的值和它的符号决定，默认情况下，十进制字面值是带符号的，八进制和十六进制则都可能。尽管整型字面值可以存储在带符号的类型中，但时十进制字面值不会是负数，-42表示对42进行取负值操作。</p>
<pre><code>20//十进制
024//八进制
0x14//十六进制
3.14159E0//浮点数，指数部分用E或e表示
</code></pre>
<p><strong>字符和字符串字面值</strong><br><br>单引号是字符字面值，双引号字符串字面值，其实是由常量字符组成的数组，只是在结尾加了一个’\0’字符。</p>
<p><strong>转义序列</strong><br><br>有两类字符不能直接使用，一种是不可打印字符，如退格和其他控制字符，另一类是在c++中有特殊含义的字符。常见转义序列包括：\n(换行符)，\r(回车符),\t(退格符)。也可以用泛华的转义序列\x后紧跟的是1个或多个16位的数字。\后跟着1个2个或3个八进制的数字。如果\后跟着的八进制的数超过3个，只有钱3个数字是转义。\x后的所有数字都表示一个字符，但是不能超过char的8个字节。</p>
<p><strong>字符和字符串字面值</strong></p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>含义</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>u</td>
<td>unicode16字符</td>
<td>char16_t</td>
</tr>
<tr>
<td>U</td>
<td>Unicode32字符</td>
<td>char32_t</td>
</tr>
<tr>
<td>L</td>
<td>宽字符</td>
<td>wchar_t</td>
</tr>
<tr>
<td>u8</td>
<td>utf-8(仅用于字符串子面常量)</td>
<td>char</td>
</tr>
</tbody></table>
<p><strong>整型字面值</strong></p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>最小匹配类型</th>
</tr>
</thead>
<tbody><tr>
<td>u or U</td>
<td>unsigned</td>
</tr>
<tr>
<td>l or L</td>
<td>long</td>
</tr>
<tr>
<td>ll or LL</td>
<td>long long</td>
</tr>
</tbody></table>
<p><strong>浮点型字面值</strong></p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>f或F</td>
<td>float</td>
</tr>
<tr>
<td>l或L</td>
<td>long double</td>
</tr>
<tr>
<td>对于一个整型字面值来说，我们可以分别指定他是否带符号，即占用多少空间。如ul就表示unsigned long，或取unsigned long long，是情况而定。</td>
<td></td>
</tr>
</tbody></table>
<p><strong>布尔字面值和指针字面值</strong><br><br>true和false是博尔类型的字面值<br>nullpt是指针字面值</p>
<p><strong>练习2.5</strong></p>
<pre><code>(a)&#39;a&#39;是char类型，L&#39;a&#39;是wchar_t类型，&quot;a&quot;是字符串类型，L&quot;a&quot;是宽字符串类型。
(b)10整型，10u 无符号整型，10L signed long ，10 ul unsigned long，012八进制整型，0xc16进制整型。
(c)3.14 double,3.14f float,3.14L long double
(d)10 int ,10u unsigned int ,10. double,10e-2 double
</code></pre>
<p><strong>练习2.6</strong></p>
<pre><code>    有区别，int month = 09定义是不合法的，因为超过的8进制的范围。day表示值是相同的。
</code></pre>
<p><strong>练习2.7</strong></p>
<pre><code>65是A ，97是a所以145是e
(a)who goes whit Fergus?换行
(b)3.14 是long double类型的数据
(c)1024.0是float类型的数据
(d)3.14L 3.14是long double类型的数据
</code></pre>
<p><strong>练习2.8</strong></p>
<pre><code>int main()&#123;
    cout&lt;&lt;&quot;2M&quot;&lt;&lt;endl;
    cout&lt;&lt;2&lt;&lt;\t&lt;&lt;&#39;M&#39;&lt;&lt;endl;
&#125;
</code></pre>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><p>变量和对象一般是可以互换使用的，对象是指一块能存储数据病具有某中类型的内存空间。</p>
<p><strong>初始值</strong><br><br>当对象在创建的时候有了一个特定的值，我们就说这个对象呗初始化了。<br>初始化不是赋值，初始化时在创建变量的时候给变量一个初始的值，而赋值是将原来变量的值抹去付给一个新的值。<br><br>在c++11中用花括号来初始化变量的到了全面的应用。这种初始化形式是<strong>列表初始化</strong>，当用于内置类型变量时，如果我们使用列表初始化也初始化值存在丢失信息的风险的时候，编译器会报错。</p>
<p><strong>默认初始化</strong><br><br>如果变量在定义时没有指定初值，则变量会被默认初始化。定义宇函数体内的内置类型的对象如果没有初始化，则其值就是未定义。类的对象如果没有显示初始化，其值由类确定。</p>
<p><strong>练习2.9</strong></p>
<pre><code>(a)错误，应该先定义才能输出 int input_value;cin&gt;&gt;input_value;
(b)错误，列表初始化在数据信息有丢失的时候回报错。int i = &#123;3&#125;;
(c)错误，不能这样连环赋值。double salary = 9999.99，wage = 9999.99;
(d)正确
</code></pre>
<p><strong>练习2.10</strong></p>
<pre><code>global_str是空字符串，global_int是0，local_int和local_str都是未定义。
</code></pre>
<p>&#x3D;&#x3D;最后一个local_str不是未定义，是空字符，因为没有定义的字符会交个类去定义，string类中有默认构造函数，将该对象赋值为空字符。&#x3D;&#x3D;</p>
<h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><p>声明使得名字为程序所知，一个文件如果想使用别处定义的名字必须包含对那个名字的声明，而定义则负责与名字关联的实体。如果想声明一个变量而不是定义它，就在变量名添加关键字extern，而且不要显示的初始化变量。任何包含了显示初始化的声明都会变成定义。在函数内部如果初始化一个有extern标记的变量，会报错。变量只能被定义一次，但是可以被声明多次。</p>
<p><strong>练习2.11</strong></p>
<pre><code>(a)定义
(b)定义
(c)声明
</code></pre>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>有数字、字母和下划线组成，必须以字母或者下划线开头，大小写不敏感，用户自定义的标识符不能连续出现多个下划线，也不能以下划线后加大写字母的形式出先，定义在函数体外的标识符不能以下划线开头。</p>
<p><strong>练习2.12</strong></p>
<pre><code>(a)不合法，double是关键字
(b)不合法，不能以下划线开头
(c)合法
(d)不合法，不能以数字开头
(e)合法
</code></pre>
<p><strong>名字的作用域</strong><br>一般作用域都是{}中间的部分。如果函数有可能用到某全局变量，则不宜在定义同一个同名的局部变量。</p>
<p><strong>练习2.13</strong></p>
<pre><code>100
</code></pre>
<p><strong>练习2.14</strong></p>
<pre><code>100&quot; &quot;45
</code></pre>
<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><p>复合类型是指基于其他类型定义的类型，引用和指针都是符合类型。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型。引用并非对象，而是对一个已经存在的对象的别名。因为引用本身不是一个对象，所以不能定义引用的引用。引用只能绑定到对象上，而不能与字面值或某个表达式的结果绑定到一起。</p>
<p><strong>练习2.15</strong></p>
<pre><code>(a)合法
(b)不合法，引用不能绑定字面值
(c)合法
(d)引用必须初始化。
</code></pre>
<p><strong>练习2.16</strong></p>
<pre><code>(a)合法，将d的值赋值为3.14159
(b)合法，将d的值赋值为0
(c)合法
(d)合法
</code></pre>
<p><strong>练习2.17</strong></p>
<pre><code>10&quot;&quot;10
</code></pre>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针和引用类似，以实现的对其他对象的间接访问功能，和引用的区别在于，指针本身就是一个对象，所以可以被赋值，指针无需再定义的时候就赋初值。</p>
<p><strong>获取对象地址</strong><br><br>使用&amp;操作符，因为在声明语句中指针类型实际上被用于指定它所指向对象的类型。所以两者必须匹配。</p>
<p><strong>利用指针访问对象</strong><br><br>如果指针指向了一个对象，则可以使用*操作符来访问该对象。</p>
<p><strong>空指针</strong><br><br>得到空指针的直接方法就是用字面值nullptr来初始化指针。NULL是预处理变量，在编译之前由预处理器负责处理。使用为初始化指针是引发运行错误的一大原因，所以建议初始化所有的指针。</p>
<p><strong>赋值和指针</strong><br><br>给指针赋值就是令他存放一个新的地址，从而指向一个新的对象。赋值操作永远改变的是等号左侧的对象。</p>
<p><strong>其他指针操作</strong><br><br>指针可以用来进行比较，如果两个指针相同可能是：他们都是空、指向同一个对象、指向同一个对象的下一个地址。</p>
<p><strong>void</strong><em><br><br>以void</em>的视角来看内存空间也只是内存空间，无法访问内存空间中的对象。</p>
<pre><code>练习2.18
int a ,b;
int * pa = &amp;a;
pa = &amp;b;        //修改指针的值
*pa = b;        //修改指针所指的值
</code></pre>
<pre><code>练习2.19
指针指向内存中的某个对象，而引用绑定到内存中的某个对象，都是实现了对其他对象的间接访问，区别在于：
1.指针本身就是一个对象，可以实现对指针的赋值和拷贝，而引用只是另外一个对象的别名，不能重新绑定另一个对象
2.指针不用在定义的时候给初值，而引用必须给。
</code></pre>
<pre><code>练习2.20
将42*42的值赋给i
</code></pre>
<pre><code>练习2.21
(a)合法，但是会有隐世转换
(b)不合法
(c)合法
</code></pre>
<p>&#x3D;&#x3D;第一个是非法的，不能够将int类型的数据给double类型的指针，这里也不会进行类型转换&#x3D;&#x3D;</p>
<pre><code>练习2.22
if(p)       //如果p是一个非空指针，就执行if后面的语句
if(*p)      //如果p所指对的int类型数据不为0，就执行后面的语句。
</code></pre>
<pre><code>练习2.23
c++程序应该尽量的初始化所有的指针，并竟可能的等定义了对象后再定义指向他的指针，如果不清楚指针所指何处，就将他设为nullptr，这样程序就可以知道他有没有指向一个具体的对象了。
</code></pre>
<pre><code>练习2.24
void*可以指向任意类型的对象，而long*只能指向long类型的对象。
</code></pre>
<h3 id="2-3-3-理解复合类型的声明"><a href="#2-3-3-理解复合类型的声明" class="headerlink" title="2.3.3 理解复合类型的声明"></a>2.3.3 理解复合类型的声明</h3><ul>
<li>一条数据可以定义出不同类型的对象，如：int i &#x3D; 1024，*p &#x3D; &amp;i,&amp;r &#x3D; i;</li>
<li>一个错误的观点：类型修饰符(*或&amp;)会作用在本次定义的全部局部变量中。但是非如此，如：int * p1,p2;只有p1是指针，p2是int类型。</li>
<li>引用本身不是一个对象，所以不存在指向引用的指针，但是存在对指针的引用。</li>
<li>面对一个比较复杂的指针或者引用的声明语句的时候，从右向左阅读有助于理解他的真实含义。如：<code>int *&amp;r = p;</code>,从右向左先看到&amp;所以r是一个引用，然后看到*说明引用的是指针。</li>
</ul>
<pre><code>练习2.25
(a)ip是int类型的指针，i是int类型，r是int类型的引用
(b)i是int类型，ip是int类型的空指针。
(c)ip是int类型的指针，ip2是int类型。
</code></pre>
<h2 id="2-4-const限定符"><a href="#2-4-const限定符" class="headerlink" title="2.4 const限定符"></a>2.4 const限定符</h2><ul>
<li>因为const对象一旦创建就不能改变，所以const对象必须初始化。</li>
<li>如果想在多个文件之间共享const对象，必须在变量定义的前面添加extern关键字。</li>
</ul>
<pre><code>练习2.26
(a)不合法，const变量在声明的时候必须从初始化。
(b)合法
(c)合法
(d)++cnt合法，++sz不合法。const变量不能修改。
</code></pre>
<h3 id="2-4-1-const的引用"><a href="#2-4-1-const的引用" class="headerlink" title="2.4.1 const的引用"></a>2.4.1 const的引用</h3><ul>
<li>const引用不能改变引用的值，也不能将非常量引用指向一个常量对象。</li>
<li>常量引用仅对引用可参与的操作进行了限定，引用对象本身是可以通过其他方式进行改变的。</li>
</ul>
<h3 id="2-4-2-指针和const"><a href="#2-4-2-指针和const" class="headerlink" title="2.4.2 指针和const"></a>2.4.2 指针和const</h3><ul>
<li>想要存放常量对象的地址，必须使用指向常量的指针。</li>
<li>指针的类型与其对象的类型必须一致，一个例外是允许一个指向常量的指针指向一个非常量的变量。</li>
<li>所谓的指向常量的指针或者引用，不过是指针或者引用自己以为指向了一个不能改变的变量，事实上是虽然不能通过该指值改变变量，但是可以通过别的指针改变变量的值。</li>
<li>指针是一个常量意味着指针不能指向其他的对象。且指针一个常量的话必须在定义的时候初始化。</li>
</ul>
<pre><code>练习2.27
(a)不合法，r应该是一个常量引用。
(b)合法
(c)合法
(d)合法。
(e)合法
(f)不合法，const类型的引用必须在定义的时候初始化
(g)合法。
</code></pre>
<pre><code>练习2.28
(a) i Int类型，cp是常量指针，指向int类型，但是不合法，没有初始化。
(b)pl int类型指针，p2 int类型的常量指针，不合法，p2没哟初始化。
(c)ic const的int类型，r是const类型的引用，不合法，ic没有初始化
(d)p3是const类型的指针，指向const的int类型，不合法，没有初始化。
(e)p是一个指针，指向const的int类型，合法。
</code></pre>
<pre><code>练习2.29
(a)不合法，不能将const类型赋值给非cosnt类型。
(b)不合法，不能将非常量指针指向常量指针。
(c)不合法，同上
(d)合法
(e)合法
(f)合法。
</code></pre>
<p>&#x3D;&#x3D;(a)是合法的，常量的值可以赋值给非常量变量。但是该常量不能够改变你了，赋值是可以的，d,e,f错误相同，常量不能作为左值，也就是不能被赋值。同事不同指针不能指向常量，以为指针可以改变常量。注意该该练习的前提是已经定义了变量，所以不能对常量进行赋值，如果在定义的时候是可以将一个常量指针指向一个非常量的。&#x3D;&#x3D;</p>
<h3 id="2-4-3-顶层const"><a href="#2-4-3-顶层const" class="headerlink" title="2.4.3 顶层const"></a>2.4.3 顶层const</h3><ul>
<li>顶层cosnt可以表示任意的对象是常量，底层const则和指针和引用等复合类型有关。</li>
<li>底层const进行拷贝操作的时候，两个对象必须有相同的底层const资格。</li>
</ul>
<pre><code>练习2.30
底层cosnt ： p2，p3，r2
顶层const：p3，v2
</code></pre>
<pre><code>(a)r1是引用，不能指向其他变量，不合法
(b)不合法，p2包含底层const，p1没有
(c)合法
(d)不合法，p3包含底层const
(e)不合法，p2可以改变，而p3是一个const对象。
</code></pre>
<p>&#x3D;&#x3D;a和e都是合法的，因为这里是赋值操作，存在拷贝赋值的关系，所以v2是什么与r1并没有关系，只要r1可以，p2可以改变就可以。这里r1并没有指向其他变量，只是他指向的变量的值被赋值为另一值而已。&#x3D;&#x3D;</p>
<h3 id="2-4-4-constexpr和常量表达式"><a href="#2-4-4-constexpr和常量表达式" class="headerlink" title="2.4.4 constexpr和常量表达式"></a>2.4.4 constexpr和常量表达式</h3><ul>
<li>常量表达式是值不会改变且在编译过程就得到计算结果的表达式。显然字面值输入常量表达式，用字面值初始化的const对象也是常量表达式。</li>
<li>c++11规定，允许将变量声明为constexpr类型以便编译器验证变量的值是否是一个常量表达式。声明为一个constexpr的变量必须是一个常量，且必须用常量表达式初始化。</li>
</ul>
<pre><code>constexpr int mf = 20;          //20是常量表达式
constexpr int limit = mf+ 1;    //mf+1是常量表达式
cosntexpr int sz = size();      //只要当size是一个constexpr函数的时候才是一个正确的声明语句。
</code></pre>
<ul>
<li>constexpr指针的初始值必须是nullptr，或者是存储于某个固定地址中的对象。函数内的对象一般无固定地址，所以一般constexpr一般用来指向函数外的变量。且限定符仅仅限定指针，对指针所指对象无限定。</li>
</ul>
<pre><code>练习2.32
不合法，int null= 0，*p = nullptr;
</code></pre>
<h2 id="类型处理"><a href="#类型处理" class="headerlink" title="类型处理"></a>类型处理</h2><h3 id="2-5-1-类型别名"><a href="#2-5-1-类型别名" class="headerlink" title="2.5.1 类型别名"></a>2.5.1 类型别名</h3><ul>
<li>类型别名是一个名字，他是某种类型的同义词，使用类型别名可以是复杂类型名称变得明了。</li>
<li>如果某个类型别名代指符合类型或常量，那声明语句可能有不一样的结果</li>
</ul>
<pre><code>typedef char * pstring ;
const pstring cstr = 0;             //cstr 是指向char的常量指针，之一这里的const修饰pstring所以是常量指针
const pstring * ps;                 //ps是一个指针，该指针指向char的常量指针。
</code></pre>
<h3 id="2-5-2-auto类型说明符"><a href="#2-5-2-auto类型说明符" class="headerlink" title="2.5.2 auto类型说明符"></a>2.5.2 auto类型说明符</h3><ul>
<li>auto让编译器通过初始值来推算变量的类型，所以const定义的变量必须有初值。</li>
<li>编译推断出的auto类型有时候和初始值不一致，会适当改变结果。编译器以引用对象的类型作为auto的类型。</li>
<li>auto会忽略掉顶层const。同时底层const会保留。如果希望推断出的auto是一个顶层const，要明确指出<code>const auto f = c;</code></li>
<li>要在一条语局中定义多个变量，符号&amp;和*只属于某个声明符，而非基本类型的一部分，因此初始值必须保持一致。</li>
</ul>
<pre><code>练习2.33
(a)合法
(b)合法
(c)合法
(d)不合法，d是指针
(e)不合法，e是指针
(f)不合法，g是常量，不能被赋值。
</code></pre>
<pre><code>练习2.35
j是int，k是const int的引用，int * p；const int j2；int &amp;k2 = i;
</code></pre>
<p>&#x3D;&#x3D;对常量对象取地址是一种底层const行为，所以p是 const int * p&#x3D;&#x3D;</p>
<h3 id="2-5-3-decltype类型指示符"><a href="#2-5-3-decltype类型指示符" class="headerlink" title="2.5.3 decltype类型指示符"></a>2.5.3 decltype类型指示符</h3><ul>
<li>从表达式的类型推算出要定义的变量的类型，但是不行用该表达式的值初始化变量。</li>
</ul>
<pre><code>decltype(f()) sum = x;      //sum的类型是f函数的返回值类型，但是该语句并不调用f函数。
</code></pre>
<ul>
<li>decltype处理顶层const和引用的方式和auto不同，保留这两个类型。</li>
<li>如果表达式的内容是解引用操作，则decltype得到的是引用类型。decltype(*p)的结果是int &amp; 而不是int。</li>
<li>如果r是引用类型，decltype(r)的结果是引用类型，想让结果得到r所指的类型，可以吧r作为表达式的一部分如decltype(r+0).</li>
<li>decltype的结果类型和表达式形式密切相关。decltype的表达式如果加上了括号的变量，得到的是引用。</li>
</ul>
<pre><code>练习2.36
d是int &amp;，其他都是int。a = 4，b = 4,c = 4,d = 4;
</code></pre>
<pre><code>练习2.37
int a = 4;int c = 3;int b = 4; int &amp;d = 4;
</code></pre>
<p>&#x3D;&#x3D;decltype不实际计算表达式所以a，d都是3&#x3D;&#x3D;</p>
<pre><code>练习2.38
1.decltype不实际计算表达式的值
2.decltype会保留引用和顶层const
3.decltype的结果类型与表达式形式密切相关。
</code></pre>
<h2 id="2-6-自定义数据结构"><a href="#2-6-自定义数据结构" class="headerlink" title="2.6 自定义数据结构"></a>2.6 自定义数据结构</h2><h3 id="2-6-1定义sales-data类型"><a href="#2-6-1定义sales-data类型" class="headerlink" title="2.6.1定义sales_data类型"></a>2.6.1定义sales_data类型</h3><ul>
<li>类最后的分号表示声明符的结束，一般来说最好不要将对象的定义和类的定义放在一起。</li>
<li>可以为数据成员提供一个类内初始值，创建对象的手类内初始值用于初始化数据成员，没有初始值得成员被默认初始化。</li>
</ul>
<pre><code>练习2.39 无法通过编译
</code></pre>
<pre><code>struct Sales_dat
&#123;
    std::string bookNo;             //书籍编号
    unsigned units_sold = 0;        //销售量
    double sellingprice = 0.0;      //零售价
    double saleprice = 0.0;         //实售价
    double discount = 0.0          //折扣
&#125;;
</code></pre>
<h3 id="2-6-2-使用Salaes-data类"><a href="#2-6-2-使用Salaes-data类" class="headerlink" title="2.6.2 使用Salaes_data类"></a>2.6.2 使用Salaes_data类</h3><h3 id="2-6-3-编写自己的头文件"><a href="#2-6-3-编写自己的头文件" class="headerlink" title="2.6.3 编写自己的头文件"></a>2.6.3 编写自己的头文件</h3><ul>
<li>头文件通常包含一些职能被定义一次的实体，如类、const和constexpr变量。</li>
<li>头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。</li>
<li>头文件包含符很简单，是通过预处理器实现的。和#pragma once一样。</li>
</ul>
<h1 id="第3章-字符串、向量、和数组"><a href="#第3章-字符串、向量、和数组" class="headerlink" title="第3章 字符串、向量、和数组"></a>第3章 字符串、向量、和数组</h1><h2 id="3-1命名空间的using声明"><a href="#3-1命名空间的using声明" class="headerlink" title="3.1命名空间的using声明"></a>3.1命名空间的using声明</h2><ul>
<li>using namespace::name;每个名字都需要独立的using声明。</li>
<li>头文件不应该使用using声明，因为头文件的内容会拷贝到引用他的文件中。</li>
</ul>
<h2 id="3-2-标准库类型string"><a href="#3-2-标准库类型string" class="headerlink" title="3.2 标准库类型string"></a>3.2 标准库类型string</h2><h3 id="3-2-1-定义和初始化string对象"><a href="#3-2-1-定义和初始化string对象" class="headerlink" title="3.2.1 定义和初始化string对象"></a>3.2.1 定义和初始化string对象</h3><ul>
<li>使用&#x3D;初始化一个变量，实际执行的是拷贝初始化，编译器直接把等号右侧的初始值拷贝到新创建的对象中，如果不适用等号，则执行的是直接初始化。</li>
</ul>
<pre><code>string 的初始化方式
string s1;              //默认初始化，s1是空字符串
string s2(s1);          //直接初始化
string s2 = s1;         //拷贝初始化
string s3(&quot;value&quot;);     //直接初始化
string s3 = &quot;value&quot;;
sring s4 (n,&#39;c&#39;);       //直接初始化
</code></pre>
<h3 id="3-2-2string对象上的操作"><a href="#3-2-2string对象上的操作" class="headerlink" title="3.2.2string对象上的操作"></a>3.2.2string对象上的操作</h3><ul>
<li>iostream对string进行读取操作的时候，string对象会自动忽略开头的空白，并从真正的字符开始读取，知道遇到下一处空白为止。</li>
<li>string对象的此类操作也是返回运算符左侧的运算对象作为结果。所以，多个输入或者输出可以连写。</li>
<li>getline函数的参数是一个输入流和一个string对象，函数从给定的出入流中读取内容，直到遇到换行符为止。</li>
<li>empty返回string对象是否为空</li>
<li>size函数返回string对象的长度。size函数返回的是一个string::size_type类型的值，这个类型与机器无关，是一个无符号类型的值。所以如果一条表达式已经有了size()函数，就不要使用int了，可以避免int和unsigned混用带来的问题。</li>
<li>string比较的时候对大小写敏感，且比较顺序是根据字典字母的顺序比较的，只有在两个string前面字符都相同的时候才会按照长度比较。</li>
<li>string允许将一个对象的值赋给另外一个对象。</li>
<li>当把string对象和字符字面值混用的时候，必须保证每一个+两侧至少有一个是string。</li>
<li>c++中的字符串字面值和string是不同的类型。</li>
</ul>
<pre><code>练习3.2
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main()
&#123;
    string line;
    while(getline(cin,line))
        cout&lt;&lt;line&lt;&lt;endl;
    return 0;
&#125;

#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main()
&#123;
    string word;
    while(cin&gt;&gt;word)
        cout&lt;&lt;line&lt;&lt;endl;
    return 0;
&#125;
</code></pre>
<pre><code>练习3.3
输入运算符会忽略开头的空白字符，并从真正的字符开始读取，直到遇到下一个空白字符为止
getline函数会读取一行的数据，也就是读取数据知道遇到换行符为止。
</code></pre>
<pre><code>练习3.4
int main()
&#123;
    string s1,s2;
    cin&gt;&gt;s1&gt;&gt;s2;
    if(s1==s2)
    &#123;
        cout&lt;&lt;ture&lt;&lt;endl;
    &#125;else&#123;
        cout&lt;&lt;(s1&lt;s2)?s2:s1;
    &#125;
    
    if(s1.size()&gt;s2.size())
    &#123;
        cout&lt;&lt;s1&lt;&lt;endl;
    &#125;
    
&#125;
</code></pre>
<pre><code>练习3.5
int main()
&#123;
    string word,line,line2;
    while(cin&gt;&gt;word)
        line+=word;
        line2.size()==0?line+word: line2 + &quot; &quot; + word;
    cout&lt;&lt;line&lt;&lt;endl;
&#125;
</code></pre>
<h3 id="处理string对象中的字符"><a href="#处理string对象中的字符" class="headerlink" title="处理string对象中的字符"></a>处理string对象中的字符</h3><ul>
<li>如果想改变string对象中字符的值，必须把循环变量定义为引用类型。</li>
<li>访问string对象中的单个字符有两种方式，一种是用下标，一种是使用迭代器。</li>
<li>[]接收的参数是string::size_type类型的值，返回的是该位置上字符的引用。</li>
<li>对于&amp;&amp;运算符，c++规定只有当左侧运算对象为真才会检查右侧运算对象的情况。</li>
</ul>
<pre><code>表3.3 ：cctype头文件中的函数
isalnum(c);         //当c是字母或数字为真
isalpha(c);         //当c是字母为真
iscntrl(c);         //当c是控制字符为真
isdigit(c);         //当c是数字为真
islower(c);         //c是小写为真
ispunct(c);         //c是标点符号为真
isspace(c);         //c为空白为真
isupper(c);         //c为大写为真
isxdigit(c);        // c为16进制为真
tolower(c);toupper(c);//转为大小写
</code></pre>
<pre><code>练习3.6
int main()
&#123;
    string temp(&quot;asdfdsf&quot;);
    for(auto a:temp)
    &#123;
        a = &#39;X&#39;;
    &#125;
&#125;
</code></pre>
<p>&#x3D;&#x3D;如果改变string的值，必须将循环的变量设为引用类型for(auto &amp;a:temp){}&#x3D;&#x3D;</p>
<pre><code>练习3.7
设置为char不会对程序造成影响。
</code></pre>
<pre><code>练习3.8
int main()
&#123;
    string temp(&quot;afdasf&quot;);
    int len = temp.size();
    while(len--&gt;0)
        temp[len] = &#39;x&#39;;
&#125;

int main()
&#123;
    string temp = &quot;fasafdasd&quot;;
    for(int i = 0;i&lt;len.size();i++)
        temp[len] = &#39;x&#39;;
&#125;

我们希望处理字符串的每一个字符，无须在意字符的处理顺序，所以与传统的while和for相比，使用范围for更好。
</code></pre>
<pre><code>练习3.9
不合法，s是空字符串，所以不能使用[]操作符。
</code></pre>
<pre><code>练习3.10
int main()
&#123;
    string s,result;
    cin&gt;&gt;s;
    for(auto temp :s)
    &#123;
        if(!ispunct(temp))
            result+=temp;
    &#125;
    cout&lt;&lt;result;
&#125;
</code></pre>
<pre><code>练习3.11
for语句合法，但是不能对s字符串进行修改。
</code></pre>
<h2 id="3-3-标准库类型vector"><a href="#3-3-标准库类型vector" class="headerlink" title="3.3 标准库类型vector"></a>3.3 标准库类型vector</h2><h3 id="3-3-1-定义和初始化vector对象"><a href="#3-3-1-定义和初始化vector对象" class="headerlink" title="3.3.1 定义和初始化vector对象"></a>3.3.1 定义和初始化vector对象</h3><pre><code>初始化vector的方法
vector&lt;T&gt; v1;                   //默认初始化，不含有任何的元素
vector&lt;T&gt; v2(v1);
vector&lt;T&gt; v2 = v1;
vector&lt;T&gt; v3(n,val);
vector&lt;T&gt; v5&#123;a,b,c...&#125;;
vector&lt;T&gt; v5 = &#123;a,b,c..&#125;;
</code></pre>
<ul>
<li>如果提供的是初始元素值的列表，只能把初始值放在花括号中进行列表初始化。</li>
<li>可以提供vector对象容纳的元素的数量而不用略去初始值如：vector<int> ivec(10);</li>
<li>vector中如果使用的是()可以说提供的值是用来构造vector对象的。如果是用花括号{},可以表述为使用初始化列表来初始化vector对象。但是如果{}提供的之不能列表初始化可以考虑构造初始化，如<code>vecotr&lt;string&gt; v&#123;10&#125;;</code>表示v有10个默认初始化的元素。</li>
</ul>
<pre><code>练习3.12
正确，不正确，正确
</code></pre>
<pre><code>练习3.13
(a) 0
(b) 10,0
(c) 10,42
(d) 1,10
(e) 2,&#123;10.42&#125;
(f) 10,&quot;&quot;
(g)10,&quot;hi&quot;
</code></pre>
<h3 id="3-3-2向vector对象中添加元素"><a href="#3-3-2向vector对象中添加元素" class="headerlink" title="3.3.2向vector对象中添加元素"></a>3.3.2向vector对象中添加元素</h3><ul>
<li>使用push_back添加元素，若循环体内包含指向vector对象那个添加元素的语句，不能使用范围for循环。</li>
</ul>
<pre><code>练习3.14
int main()
&#123;
    vector&lt;int&gt; vi ;
    cout&lt;&lt;&quot;请输入一组整数&quot;&lt;&lt;endl;
    int i;
    while(cin&gt;&gt;i)
        vi.push_back(i);
&#125;
</code></pre>
<h3 id="3-3-3-其他vector操作"><a href="#3-3-3-其他vector操作" class="headerlink" title="3.3.3 其他vector操作"></a>3.3.3 其他vector操作</h3><pre><code>vector支持的操作
v.empty();
v.size();                   //返回size_type类型
v.push_back(t);
v[n];
v1 = v2;
v1 = &#123;a,b,c&#125;;
v1 == v2;
v1!= v2 ,&lt;,&lt;=,&gt;,&gt;=          //  以字典顺序进行比较
</code></pre>
<ul>
<li>要使用size_type，需要首先指定他是哪种类型定义的。vector对象的类型总是包含元素的类型。如：vector::size_type是错误的需要指明类型。</li>
<li>只有vector中的类可以比较的时候vector才可以比较，比较规则和string一样，先看元素大小是否相同，如果全部相同再比较vector的大小。</li>
<li>vector对象的下标运算符符可以访问已存在的元素，而不能用于添加元素。</li>
</ul>
<pre><code>练习3.17
int main()
&#123;
    vector&lt;string&gt; vString ;
    string s;
    while(cin&gt;&gt;s)&#123;
        vString.push_back(s);
    &#125;
    for(auto &amp;temp : vString)
    &#123;
        for(auto &amp; c:temp)
        &#123;
            c = toupper(c);
        &#125;
        cout&lt;&lt;temp&lt;&lt;endl;
    &#125;
&#125;
</code></pre>
<pre><code>练习3.18
不合法
vector&lt;int&gt; ivec;
ivec.push_back(42);
</code></pre>
<pre><code>练习3.19
vector&lt;int&gt; a(10,42);
vector&lt;int&gt; a&#123;42,42,42,42,42,42,42,42,42,42&#125;
vector&lt;int&gt; a;for(int i = 0;i&lt;10;i++)a.push_back(42);
</code></pre>
<pre><code>练习3.20
int main()
&#123;
    int i;
    vector&lt;int&gt; vi;
    while(cin&gt;&gt;i)
        vi.push_back(i);
    for(int i = 0;i&lt;vector.size()-1;i++)
    &#123;
        cout&lt;&lt;vi[i]+vi[i+1]&lt;&lt;endl;
    &#125;
    
    int len = vector.size();
    for(int i = 0;i&lt;=len-i-1;i++)
    &#123;
        cout&lt;&lt;vi[i]+vi[len-i-1]&lt;&lt;endl;
    &#125;
&#125;
</code></pre>
<h2 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h2><h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><ul>
<li>begin成员负责返回指向第一个元素的迭代器，end成员负责返回容器尾元素的下一位置。</li>
<li>如果容器为空，begin和end返回的是同一个迭代器，都是尾后迭代器。</li>
</ul>
<pre><code>标准容器迭代器的运算符
*iter 返回得带器iter所指元素的引用
iter-&gt;mem  解引用iter并获取该元素的名为mem的成员。
++iter  令iter指示容器下一个元素。
--iter
iter1 == iter2 判断迭代器是否相同，指向同一个元素或者是同一容器的尾后迭代器。
</code></pre>
<ul>
<li>应该养成使用！&#x3D;的习惯，因为所有的标准库容器的迭代器都定义了&#x3D;&#x3D;和!&#x3D;</li>
<li>就像不知道string的size_type的类型一样，我们也不知道迭代器的类型，一般使用iterator和const_iterator</li>
<li>cbegin和cend返回的一定是const类型的迭代器。</li>
<li>但凡是使用了迭代器的循环体，都不要想迭代器所属的容器添加元素。</li>
</ul>
<pre class=" language-cpp"><code class="language-cpp">练习<span class="token number">3.22</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>text<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token operator">!</span>it<span class="token operator">-</span><span class="token operator">></span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>it<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>it<span class="token operator">==</span>text<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>temp<span class="token operator">:</span><span class="token operator">*</span>it<span class="token punctuation">)</span>
            <span class="token function">toupper</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>it<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<pre class=" language-cpp"><code class="language-cpp">练习<span class="token number">3.23</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">vi</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> vi<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>vi<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>it<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token operator">*</span>it <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>it<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="3-4-2迭代器运算"><a href="#3-4-2迭代器运算" class="headerlink" title="3.4.2迭代器运算"></a>3.4.2迭代器运算</h3><ul>
<li><code>auto mid = vi.begin()+vi.size()/2</code>如果vi有20个元素，mi等于vi.begin()+10</li>
<li>迭代器的&lt;可以用来比较所指的想的位置前后。</li>
<li>difference_type表示两个迭代器之间的距离，可正可负。</li>
</ul>
<pre><code>练习3.25
vector&lt;unsigned&gt; scores(11,0);
unsigned grad;
while(cin&gt;&gt;grade)&#123;
    if(grade&lt;=100)
        *(scores.begin()+grade/10)++;
&#125;
</code></pre>
<pre><code>练习3.26
beg+end可能超过整数的边界。
</code></pre>
<p>&#x3D;&#x3D;迭代器没有定义加法的操作，&#x3D;&#x3D;</p>
<h2 id="3-5-数组"><a href="#3-5-数组" class="headerlink" title="3.5 数组"></a>3.5 数组</h2><ul>
<li>如果不清楚元素的确切个数，使用vector较好</li>
</ul>
<h3 id="3-5-1-定义和初始化内置数组"><a href="#3-5-1-定义和初始化内置数组" class="headerlink" title="3.5.1 定义和初始化内置数组"></a>3.5.1 定义和初始化内置数组</h3><ul>
<li>如果维度比提供的默认值数量大，则用提供的初始值初始化靠前的元素。剩余的初始化为默认值。</li>
<li>字符数组可以用字符字面值初始化，使用这种方式的时候，结尾会自动添加一个空字符。而使用列表初始化不会添加空字符。</li>
<li>不能将数组的内容拷贝给其他的数组作为其初始值，也不能用数组为其他数组赋值。</li>
<li>理解数组声明的含义，最好的办法是从数组的名字开始按照从内向外的顺序阅读。</li>
</ul>
<pre><code>练习3.27
(a) buf_size只是一个普通的变量不是常量，不能作为数组的维度。
(b)合法
(c)非法，txt_size()不是一个constexpr不能作为数组的维度。
(d)非法，数组的维度过小，应该是12。
</code></pre>
<pre><code>练习3.28
除了ia2其他的都被默认初始化了
</code></pre>
<p>&#x3D;&#x3D;对于string类型的数组来说，因为string类本身接受无参数的初始化方式，所以不论数组定义在函数内还是函数外都被默认初始化为空串。&#x3D;&#x3D;</p>
<pre><code>练习3.29
数组的大小固定，不能随便向数组中添加额外的元素。如果我们需要一个更大的数组，只能重新申请空间。
</code></pre>
<h3 id="3-5-2访问数组元素"><a href="#3-5-2访问数组元素" class="headerlink" title="3.5.2访问数组元素"></a>3.5.2访问数组元素</h3><ul>
<li>数组的元素也可以使用范围for语句和下标运算符来访问。</li>
<li>使用数组下标的时候，通常将其定义为size_t类型，size_t是一种与机器相关的无符号类型。在cstddef头文件中定义了该类型，该文件是c标准库stddef.h头文件的c++语言版本。</li>
</ul>
<pre><code>练习3.30
ix不能为10，所以程序改为for(size_t = 0;ix&lt;arrray_size;++ix)比较好。
</code></pre>
<pre><code>练习3.31
int main()
&#123;
    int a[10] ;
    for(int i = 0;i&lt;10;i++)
    &#123;
        a[i] = i;
    &#125;
&#125;
</code></pre>
<pre><code>练习3.32
int main()
&#123;
    const int sz = 10;
    vector&lt;int&gt; vInt ,vInt2;
    for (int i = 0;i&lt;sz;i++)
    &#123;
        vInt.push_back(i);
        vInt2.push_back(vInt[i]);
    &#125;
    for(auto vla:vInt2)
    &#123;
        cout&lt;&lt;val&lt;&lt;&quot;&quot;;
    &#125;
    cout&lt;&lt;endl;
    return 0;
    
&#125;
</code></pre>
<pre><code>练习3.33
如果不初始化scores，该数组会含有未定义的数值，因为scores是定义在函数内部的整数数组。所以不会执行默认初始化。
</code></pre>
<h3 id="3-5-3-指针和数组"><a href="#3-5-3-指针和数组" class="headerlink" title="3.5.3 指针和数组"></a>3.5.3 指针和数组</h3><ul>
<li>对数组的元素取地址可以得到指向该元素的指针。</li>
<li>在很多用到数组名字的地方，编译器会自动将替换为一个指向数组首元素的指针。</li>
<li>如果ia是一个10个整数组成的数组，当使用ia作为初始值的时候编译器会进行转化，而使用decltype关键字时不会发生上述的转化。</li>
</ul>
<pre><code>int ia[] = &#123;1,2,3,4,5,6,7,8,9&#125;;
auto ia2(ia);                   //ia2是一个整型的指针，指向ia的第一个元素。
decltype(ia) ia3 = &#123;0,1,2,3,4,5,6,7,8&#125;;         //ia3是一个含有10个整数的数组。
</code></pre>
<ul>
<li>使用指针遍历数组的元素，需要得到尾元素的下一个位置，可以使用<code>int * e = &amp;arr[10];</code>的到，虽然索引是一个不存在的元素，但是可以的到所需要的地址</li>
<li>另一种方法是c++11提供的，使用begin和end，但是数组不是类型，所以这两个不是成员函数。使用方法是将数组作为他们的参数。这两个函数定义在iterator头文件中。</li>
</ul>
<pre><code>int ia[10];
int *beg = begin(ia);
int *end = end(ia);
</code></pre>
<ul>
<li>两个指针相减的结果是ptrdiff_t的标准类型，和size_t定义的位置一样。</li>
<li>如果两个指针分别指向不相关的对象，不能对他们进行比较。</li>
<li>内置的下标运算符所用的索引值不是无符号类型，这一点和vector和string不同。</li>
</ul>
<pre><code>练习3.34
另p1指向p2所指的元素。只有在p1和p2的类型不同的时候改程序才是非法的。
</code></pre>
<pre><code>练习3.35
int main()
&#123;
    int a[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;
    for(auto p = begin(a);p!=end(a);++p)
    &#123;
        *p = 0;
    &#125;
&#125;
</code></pre>
<h3 id="3-5-4-c风格的字符串"><a href="#3-5-4-c风格的字符串" class="headerlink" title="3.5.4 c风格的字符串"></a>3.5.4 c风格的字符串</h3><ul>
<li>c风格的字符串不是一种类型，是为了表达和使用字符串而形成的一种约定俗称的写法。</li>
<li>c语言的标准库string函数，可以用来操作c风格字符串，定义在cstring头文件中，是string.h的c++版本</li>
</ul>
<pre><code>c风格的字符串函数
strlen(p);              //返回p的长度，不包含空字符串
strcmp(p1,p2);          //比较p1和p2的相等性，若相同返回0，如果p1&gt;p2返回正。
strcat(p1,p2);          //将p2附加到p1上，返回p1
strcpy(p1,p2);          //将p2拷贝给p1，返回p1
</code></pre>
<pre><code>char a[] = &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;;
cout&lt;&lt;strlen(a)&lt;&lt;endl;              //错误，a没有以空字符结束
</code></pre>
<pre><code>const char cal[] = &quot;a string example&quot;;
const char cal2[] = &quot;a different string&quot;
if(cal&lt;cal2)                    //未定义的：试图比较两个无关的的地址。
</code></pre>
<ul>
<li>如果比较c风格字符串，使用strcmp函数，此时比较的就不是指针了而是字符串。</li>
<li>连接或拷贝c风格字符串使用strcat函数和strcpy函数，不过想要使用这两个函数，需要提供一个用于存放字符串结果的数组，该数组必须足够大，可以存放字符串和结尾的空字符，否则会发生错误。</li>
</ul>
<pre><code>练习3.37
还程序的含义是输出cp地址之后的结果，知道遇到了空字符。但是因为ca定义的时候没有定义空字符，所以可能会带来一定的问题，所以修改为
const char ca [] = &#123;&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;\0&#39;&#125;;
const char ca[] = &quot;hello&quot;;
</code></pre>
<pre><code>练习3.38
指针存放的是对象的地址，将对象的地址相加是没有意义的。
但是对象的指针相减是有意义的，在一个数组表示的意义是元素在数组中的距离。
</code></pre>
<pre><code>练习3.39
bool isEqual(const String &amp;s1,const String &amp;s2)
&#123;
    return s1==s2;
&#125;
bool isEqual(const char* &amp;s1,const char* &amp; s2)
&#123;
    return strcmp(s1,s2);
&#125;
</code></pre>
<pre><code>练习3.40
int main()
&#123;
    char a[] = &quot;hello&quot;;
    char b[] = &quot;world&quot;;
    char c[20] = strcat(a,b);
    
&#125;
</code></pre>
<p>&#x3D;&#x3D;strcat返回的结果是a的值，所以这样做后就改变了a，更好的做法是想用strcpy(c,a)再用strcat(c,b)&#x3D;&#x3D;</p>
<h3 id="3-5-5-与旧代码的接口"><a href="#3-5-5-与旧代码的接口" class="headerlink" title="3.5.5 与旧代码的接口"></a>3.5.5 与旧代码的接口</h3><ul>
<li>允许使用空字符串结尾的字符数组来初始化string对象或为string对象赋值</li>
<li>若想将string赋值给c字符串数组，使用c_str函数，该函数返回一个c风格的字符串。其实返回的是const char* ，如果后续的操作改变了string，那么之前返回的数组失去作用。</li>
<li>如果指向完c_str()返回后程序向一直使用返回的数组，最好是将该数组重新拷贝一份。</li>
<li>可以使用数组来初始化vector对象，只要指定拷贝区域的首元素地址和尾后地址即可。<pre><code>int int_arr[] = (0,1,2,3,4,5);
vector&lt;int&gt; ivec(begin(int_arr),end(int_arr));
</code></pre>
</li>
</ul>
<pre><code>练习3.41
int main()
&#123;
    int a[] = (1,2,3,4,5);
    vector&lt;int&gt; ivec(begin(a),end(a));
&#125;
</code></pre>
<pre><code>练习3.42
void vec_int(const vector&lt;int&gt; vec,int* &amp;a)
&#123;
    auto it = vec.cbegin();
    for(auto &amp;val:a)
    &#123;
        val = *it;
        it++;
    &#125;
&#125;
</code></pre>
<h2 id="3-6-多维数组"><a href="#3-6-多维数组" class="headerlink" title="3.6 多维数组"></a>3.6 多维数组</h2><ul>
<li>严格来说c++没有多维数组，通常所说的多维数组就是数组的数组。</li>
<li>按照从内到外的阅读顺序有助于理解，<code>int ia[3][4]</code>ia是一个含有三个元素的数组，而每个元素有是含有4个元素的数组。</li>
<li>对于二维数组，把第一维度称为行，第二维度称为列。</li>
<li>多维数组的初始化，每一行用花括号括起来，如果想初始化每一行第一个元素，其他的值会默认初始化。<pre><code>int ix[3][4] = &#123;&#123;0&#125;,&#123;4&#125;,&#123;8&#125;&#125;;           //显示初始化每一行的首元素
int ix[3][4] = &#123;0,1,2&#125;;                 //显示的初始化第一行，其他元素执行默认初始化。
</code></pre>
</li>
<li>如果想要改变数组的元素，选用引用类型作为循环控制变量，但在为了防止数组被自动转为指针，也需要将外层循环的控制变量声明为引用类型。<pre><code>for(const auto &amp;row:ia)             //这里必须用引用，否则row会被当成指针，而无法通过编译。
    for(auto col:row)
        cout&lt;&lt;col&lt;&lt;endl;
</code></pre>
</li>
<li>使用范围for语句处理多维数组，除了最内层的循环外，其他的循环控制变量都应该是引用类型。</li>
<li>当程序使用多维数组的名字的时候，也会自动将其转化成指向数组首元素的指针。</li>
<li>使用auto和decltype可以避免在数组前添加一个指针类型了<pre><code>for(auto p = ia;p!=ia+3;++p)            //  p指向含有4个整数的数组 int(*p)[4] = ia;
    for(auto q = *p;q!=*p+4;++q)
        cout&lt;&lt;*q&lt;&lt;endl;
</code></pre>
</li>
<li>读写和理解指向多维数组的指针很麻烦，使用类型别名可以使工作更加简单。<pre><code>typedef int int_array[4];
for(int_array *p = ia;p!=ia+3;++p)
&#123;
    for(int *q = *p)
&#125;
</code></pre>
<ul>
<li>程序将类型4个整数数组命名为int_array,用类型名定义更加明了简介</li>
</ul>
</li>
</ul>
<pre><code>练习3.43
int ia[3][4];
for(int (&amp;p)[4]:ia)
    for(int &amp;q:p)
        cout&lt;&lt;q&lt;&lt;endl;
        
for(int i = 0;i！=3;i++)
&#123;
    for(int j = 0;j!=4;j++)
    &#123;
        cout&lt;&lt;ia[i][j];
    &#125;
&#125;

for(int (*p)[4] = ia;p!=ia+3;p++)
&#123;
    for(int *q = *p;q!=*p+4;q++)
    &#123;
        cout&lt;&lt;*q&lt;&lt;endl;
    &#125;
&#125;
</code></pre>
<pre><code>练习3.44
typedef int int_array[4];
for(int_array &amp;p:ia)
    for(int &amp;q:p)
        cout&lt;&lt;q;
</code></pre>
<pre><code>练习3.45
for(auto &amp;p:ia)
    for(auto &amp;q:p)
        cout&lt;&lt;q

for(auto i = 0;i!=3;i++)
    for(auto j = 0;j!=4;j++)
        cout&lt;&lt;ia[i][j];

for(auto p = ia;p!=ia+3;p++)
    for(auto q = *p;q!=*p+4;q++)
     cout&lt;&lt;*q&lt;&lt;endl;
</code></pre>
<h1 id="第4章-表达式"><a href="#第4章-表达式" class="headerlink" title="第4章 表达式"></a>第4章 表达式</h1><h2 id="4-1-1-基本概念"><a href="#4-1-1-基本概念" class="headerlink" title="4.1.1 基本概念"></a>4.1.1 基本概念</h2><ul>
<li>c++定义了一元运算符和二元运算符，函数调用也是一种特殊的运算符，他的运算对象数量没有限制。</li>
<li>一个c++表达式要不是左值，要不是右值，一个左值表达式的求值结果是一个对象或者一个函数。</li>
<li>当一个对象被用作右值的时候用的是对象的值(内容)，当对象被用作左值的时候，用的是对象的身份(在内存中的位置)</li>
<li>需要右值的地方可以用左值代替，但是不能把右值当成左值使用。</li>
<li>使用关键字decltype的时候，左值和右值也有所不同，如果表达式的求值结果是左值，会得到一个引用类型。<pre><code>int * p;
decltype(*p);           //因为*p是左值所以结果还是int &amp;
decltype(&amp;p);           //因为取地址符生成右值，所以结果是int **也就是一个指向整型指针的指针。
</code></pre>
</li>
</ul>
<h3 id="4-1-2-优先级和结合律"><a href="#4-1-2-优先级和结合律" class="headerlink" title="4.1.2 优先级和结合律"></a>4.1.2 优先级和结合律</h3><pre><code>练习4.1
25
</code></pre>
<pre><code>练习4.2
(a) (*vec).begin()
(b) (*vec).begin() + 1;
</code></pre>
<p>&#x3D;&#x3D;优先级最好的是成员选择符合函数调用符，其次才是解引用操作，所以是*(vec.begin())&#x3D;&#x3D;</p>
<h3 id="4-1-3-求值顺序"><a href="#4-1-3-求值顺序" class="headerlink" title="4.1.3 求值顺序"></a>4.1.3 求值顺序</h3><ul>
<li><code>int i = f1()*f2();</code>虽然知道f1和f2一定会在执行乘法之前被调用，但是无法知道到底是f1先还是f2先。</li>
<li>有4种运算符规定了运算对象的求值顺序(&amp;&amp; || ?: ,).</li>
<li>那不准执行顺序最好使用括号强制让表达式的组合关系符合程序逻辑的要求。</li>
<li>如果改变了某个对象的值，在表达式的其他地方不要再使用这个运算对象。</li>
</ul>
<h2 id="4-2-算术运算符"><a href="#4-2-算术运算符" class="headerlink" title="4.2 算术运算符"></a>4.2 算术运算符</h2><pre><code>+           一元正号   
-           一元负号
-----------------------
*           乘法
/           除法
%           求余
-----------------------
+           加法
-           减法
</code></pre>
<ul>
<li>当一元正好运算符作用域一个指针或者算术值得时候，返回运算对象值得一个副本。</li>
<li>布尔值不参与一元运算符-的运算。</li>
<li>%运算必须都是整数。</li>
<li>取余操作的正负看m%n中的m，而除法操作是看m，n的符号是否相同 。</li>
</ul>
<pre><code>练习4.4
91
</code></pre>
<pre><code>练习4.5 
(a)-86
(b)-18
(c) 0
(d) -2
</code></pre>
<pre><code>练习4.6
(m%2)==0
</code></pre>
<pre><code>练习4.7
溢出是一种常见的算术运算错误，因为在计算机中存储某个类型的内存空间有限，所以该类型的表示范围有限，当
计算的结果超过这个范围之后，就会产生未定义的数值，这种错误称为溢出。
</code></pre>
<h2 id="4-3-逻辑和关系运算符"><a href="#4-3-逻辑和关系运算符" class="headerlink" title="4.3 逻辑和关系运算符"></a>4.3 逻辑和关系运算符</h2><pre><code>!           非
-----------------------------
&lt;           小于
&lt;=          小于等于
&gt;           大于
&gt;=          大于等于
----------------------------
==          相等 
!=          不相等
-----------------------------
&amp;&amp;          逻辑与
||          逻辑或

只有！是从右想左赋值其他都是从左向右赋值
</code></pre>
<ul>
<li>逻辑与和逻辑或都有短路策略，也就是会先求左侧的表达式，若有结果了就不会求右侧的表达式。</li>
<li>进行比较运算是除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象<pre><code>if(val==true)
//等价于 
if(val==1)
</code></pre>
</li>
</ul>
<pre><code>练习4.8
逻辑与和逻辑或都是先求左侧运算对象在求右侧对象的值。相等性运算符的两个对象都需要求值，但是没有规定求值顺序。
</code></pre>
<pre><code>练习4.9
先判断cp是不是空指针，然后判断cp所指的字符串是否为空。
</code></pre>
<pre><code>练习4.10
int a;
while(cin&gt;&gt;a==42)&#123;&#125;
</code></pre>
<pre><code>练习4.11
if(a&gt;b&amp;&amp;b&gt;c&amp;&amp;c&gt;d)
</code></pre>
<pre><code>练习4.12
i!=(j&lt;k)，意思是先比较j和k的大小，得到一个布尔值，然后判断i的值是否与之相等。
</code></pre>
<h2 id="4-4-赋值运算符"><a href="#4-4-赋值运算符" class="headerlink" title="4.4 赋值运算符"></a>4.4 赋值运算符</h2><ul>
<li>赋值运算符的左侧对象必须是一个可以修改的左值。</li>
<li>赋值运算符满足右结合律，对于多重赋值语句中的每一个对象，他的类型或者与右边对象的类型相同、或者可以有右边的类型转换得到。</li>
<li>赋值语句通常会出现在条件中，因为赋值运算符的优先级相对较低，所以通常需要给赋值部分加上括号。</li>
</ul>
<pre><code>练习4.13
(a)i = 3 ,d = 3.0
(b)d = 3.5 ,i =3
</code></pre>
<pre><code>练习4.14
错误不能把42作为左值。
判断i=42的赋值操作是否执行成功
</code></pre>
<pre><code>练习4.15
daval = ival = 0;
pi = nullptr;
</code></pre>
<pre><code>练习4.16
if((p=getPtr()!=0)
if(i==1024)
</code></pre>
<h2 id="4-5-递增和递减运算符"><a href="#4-5-递增和递减运算符" class="headerlink" title="4.5  递增和递减运算符"></a>4.5  递增和递减运算符</h2><ul>
<li>除非必须，否则不要是用递增递减的后置版本，因为后置版本需要将原始数据存储下来以便返回这个为修改的内容</li>
<li>*pbeg++的含义是输出当前值并将pbeg向前移动一个元素。*pbeg++等价于*(pbeg++)pbeg++先把pbeg的值加1，然后返回pbeg的初始值得副本作为其求值的结果。</li>
<li>如果一条子表达式改变了某个对象的值，另一条子表达式又用到该指的话，运算对象的顺序就比较关键了。可能会产生未定义的行为。</li>
</ul>
<pre><code>练习4.17
前置操作符是先进行加一然后才赋值，而后置运算符将对象加一但是求值的结果是未改变之前的那个副本。
</code></pre>
<pre><code>练习4.18
会产生错误，无法输出程序第一个元素的值，还有会尝试输出最后一个元素后面位置的值，但是并不存在。
</code></pre>
<pre><code>练习4.19
(a)先判断ptr是否是空指针，如果不是空指针，将指针+1，并判断之前指针所指的对象是否为0
(b)先将ival+1，然后判断ival是否为0，若不为0，判断ival+1是否为0
(c)不正确，会带来未定义的行为。
</code></pre>
<h2 id="4-6-成员访问符号"><a href="#4-6-成员访问符号" class="headerlink" title="4.6 成员访问符号"></a>4.6 成员访问符号</h2><ul>
<li>点运算符获取类对象的一个成员，箭头运算符和点有关。ptr-&gt;mem等价于(*ptr).men;</li>
<li>因为解引用的运算符优先级低于点运算符，所以执行解引用运算符的子表达式两端必须加上括号。</li>
</ul>
<pre><code>练习4.20
(a) 合法，将iter的值取出，将指针后移
(b) 不合法，无法对string++
(c) 不合法iter没有empty的方法
(d) 合法
(e) 不合法
(f) 合法，判断iter下一个元素是否为空
</code></pre>
<h2 id="4-7-条件运算符"><a href="#4-7-条件运算符" class="headerlink" title="4.7 条件运算符"></a>4.7 条件运算符</h2><ul>
<li>条件运算符满足右结合律，当条件运算符的两个表达式都是左值或者可以转换为同一左值类型的时候。</li>
<li>条件运算符的优先级很低，所以一般加括号。</li>
</ul>
<pre><code>练习4.21
vector&lt;int&gt; vInt;
for(auto &amp;temp:vInt)
    temp = temp%2!=0 ? temp*2:temp;
</code></pre>
<pre><code>练习4.23
string p1 = s+(s[s.size()-1]==&#39;s&#39;?&quot;&quot;:&quot;s&quot;);
</code></pre>
<h2 id="4-8-位运算符"><a href="#4-8-位运算符" class="headerlink" title="4.8 位运算符"></a>4.8 位运算符</h2><pre><code>位运算符(左结合律)
~               位取反 
&lt;&lt;              左移    
&gt;&gt;              右移
&amp;               位与
^               位异或
|               位或
</code></pre>
<ul>
<li>位运算符如何处理么有明确规定，所以建议仅将位运算符用于处理无符号类型。</li>
<li>左移操作符在右侧插入值为0的二进制数，右移操作符行为依赖于左移对象的类型，如果是无符号数插入0，如果是有符号数，左侧插入符号位的副本或位0的二进制数，如何选择是环境而定。</li>
<li>在为运算符中，char类型的运算对象会被先提升为iint类型。</li>
<li>对于&amp;，都是1才是1，对于|都是0才为0，对于^相等为0，不同为1.</li>
<li>移位运算符满足做结合律。</li>
<li>c++规定整数按照他的补码新式存储。</li>
</ul>
<pre><code>练习4.25
00000000 000000000 000100011 10000000
</code></pre>
<p>&#x3D;&#x3D;11111111 11111111 11100011 10000000&#x3D;&#x3D;</p>
<pre><code>练习4.27
(a) 3 
(b) 7
(c) 1
(d) 1
</code></pre>
<h2 id="4-9-sizeof运算符"><a href="#4-9-sizeof运算符" class="headerlink" title="4.9 sizeof运算符"></a>4.9 sizeof运算符</h2><ul>
<li>sizeof返回一条表达式或者一个类型名字所占的字节数。满足右结合律，得到的值是size_t类型。<pre><code>sizeof(type)
sizeof expr;            //返回表达式结果类型的大小，不实际计算运算对象的值

Sales_data data,*p;
sizeof(Sales_data_);            //sales_data类型的对象所占空间大小
sizeof data;                   //data的类型大小，也即是sizeof(Sales_data)
sizeof p;                       //指针所占空间大小
sizeof *p;                      //p所指空间的大小，指针不需要有效，因为有结合，相当于sizeof(*p)
</code></pre>
</li>
<li>对char或类型为char的表达式执行sizeof，为1</li>
<li>对引用类型执行得到引用对象所占大小</li>
<li>对指针得到指针大小</li>
<li>对解引用指针得到指针所指向对象的大小，指针不需要有效。</li>
<li>对数组，得到整个数组的大小</li>
<li>对string和vector得到类型固定部分大小。</li>
</ul>
<pre><code>练习4.29
10
1
</code></pre>
<pre><code>练习4.30
(a) sizeof(x+y)
(b) sizeof(p-&gt;mem[i])
(c) sizeof a &lt; b
(d) sizeof f()
</code></pre>
<h2 id="4-10-逗号运算符"><a href="#4-10-逗号运算符" class="headerlink" title="4.10 逗号运算符"></a>4.10 逗号运算符</h2><ul>
<li>按照从左向右的顺序，逗号运算符的结果是右侧表达式的值。</li>
</ul>
<pre><code>练习4.33
如果somevalue==0，那么x+1，y+1，且该表达式的值为y+1
</code></pre>
<p>&#x3D;&#x3D;条件运算符等级高于逗号运算符，所以相当于(someValue ? ++x,++y:–x),–y&#x3D;&#x3D;</p>
<h2 id="4-11-类型转换"><a href="#4-11-类型转换" class="headerlink" title="4.11 类型转换"></a>4.11 类型转换</h2><ul>
<li><code>int ival = 3.42+3;</code>该表达式先将3转为3.0然后计算为6.42，最后再将double转为int。</li>
<li>大多数表达式，比int类型小的整型值首先转化为较大的int类型</li>
<li>条件中，非布尔值转为布尔值。</li>
<li>初始化中，初始值转为变量的类型，赋值中，右侧对象转为左侧运算对象的类型</li>
<li>如果算术运算或关系运算有多种类型，需要转为同一中类型。</li>
<li>函数调用发生类型转化。</li>
</ul>
<h3 id="4-11-1-算术转化"><a href="#4-11-1-算术转化" class="headerlink" title="4.11.1 算术转化"></a>4.11.1 算术转化</h3><ul>
<li>整型提升将小整数类型转化为大的整数类型。</li>
<li>如果一个是无符号类型，一个是带符号类型，其中无符号类型不小于带符号类型，则转为无符号类型。</li>
<li>如果无符号类型小于带符号类型，依据机器，如果无符号类型能存储到带符号类型中，转为带符号类型，如果不能转为带符号类型。带符号类型转为无符号类型是取模后的余数。<code>unsigned int c = -1;</code> c&#x3D;255 (-1mod256)</li>
</ul>
<pre><code>练习4.34
(a) 浮点数转为int类型，int转为bool类型
(b) ival转为fval然后相加的结果转为dval
(c) cval转为ival然后结果转为dval
(d) 
</code></pre>
<pre><code>练习4.35
(a)&#39;a&#39;提升为int，然后相加的结果转为char
(b)ival转为double，ui转为double类型。最后结果转为float类型。
(c) ui转为float类型。最后结果转为double类型
(d)ival转为float类型，然后结果转为double类型，最后转为char类型
</code></pre>
<h3 id="4-11-2-其他隐式类型转换"><a href="#4-11-2-其他隐式类型转换" class="headerlink" title="4.11.2 其他隐式类型转换"></a>4.11.2 其他隐式类型转换</h3><ul>
<li>数组转换为指针，大多数用到数组的表达式中，数组自动转换为指向数组首元素的指针。</li>
<li>指针的转化：nullptr可以转化为任意类型的指针。指向任意非常量的指针都能转为void*，指向任意对象的指针都能转外const void *.</li>
<li>存在一种从算术类型或指针类型想布尔类型自动转化的机制。</li>
<li>允许将指向非常量类型的指针转换为指向对应的常量类型的指针。</li>
<li>类类型定义的转换：类类型能定义有编译器自动执行的转换，不过编译器只能执行一次类类型的转换。<pre><code>string s,t = &quot;a value&quot;;             //字符串字面值转为string类型
while(cin&gt;&gt;s)                       //cin转换为布尔值，有istream定义的转换规则。
</code></pre>
</li>
</ul>
<h3 id="4-11-3-显示转换"><a href="#4-11-3-显示转换" class="headerlink" title="4.11.3 显示转换"></a>4.11.3 显示转换</h3><ul>
<li>一个命名的强制类型转化具有以下形式。<code>cast-name&lt;type&gt;(express)</code></li>
<li>static_cast,任何具有明确意义的类型转换，只要不包含底层cosnt，都可以使用static_cast</li>
<li>当需要将一个较大的算术 类型赋值给较小的类型的时候，staticconst比较用用，他告诉程序的读者和编译器，我们并不在乎潜在的精度损失。</li>
<li>我们把指针存放在void*中，并且使用static_cast将其强制转换为原来的类型。</li>
<li>const_static只能改变运算对象的底层const，const_cast只能用来改变常量属性</li>
<li>reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。本质上依赖机器。</li>
<li>dynamic_cast支持运行时类型识别。</li>
</ul>
<pre><code>练习4.36
i *= static_cast&lt;int&gt;( d);
</code></pre>
<pre><code>练习4.37
(a) pv = static_cast&lt;void *&gt;ps;
(b) i = static_cast&lt;int&gt;(*pc)
(c) pv = static_cast&lt;void*&gt;(&amp;d);
(d) pc =static_cast&lt;char*&gt;(pv);
</code></pre>
<pre><code>练习4.38
将j/i的值转为double然后赋值给slope
</code></pre>
<h1 id="第5章-语句"><a href="#第5章-语句" class="headerlink" title="第5章 语句"></a>第5章 语句</h1><h2 id="5-1简单语句"><a href="#5-1简单语句" class="headerlink" title="5.1简单语句"></a>5.1简单语句</h2><ul>
<li>空语句只有一个分号。空语句应该加上注释，从而使得读者段代码的人知道该语句是有意省略的。</li>
</ul>
<pre><code>练习5.1
空语句就是只有一个分号的语句，在while循环可能会用到空语句。
</code></pre>
<pre><code>练习5.2
快是由&#123;&#125;组成的以快区域。
</code></pre>
<h2 id="5-2-语句作用域"><a href="#5-2-语句作用域" class="headerlink" title="5.2 语句作用域"></a>5.2 语句作用域</h2><ul>
<li>定义在控制结构中的变量只在相应的语句内部可见。</li>
</ul>
<pre><code>练习5.3
(a) 必须为iter变量赋初值
    String::iterator iter = s.begin();
    while(iter!=s.end())&#123;/*..*/&#125;
(b) 在if语句中，status已经离开了while的范围，所以要把status的赋值操作移出来。
    bool status = find(word);
    while(status)&#123;&#125;
    if(!status)&#123;&#125;
</code></pre>
<h2 id="5-3-条件语句"><a href="#5-3-条件语句" class="headerlink" title="5.3 条件语句"></a>5.3 条件语句</h2><h3 id="5-3-1-if语句"><a href="#5-3-1-if语句" class="headerlink" title="5.3.1 if语句"></a>5.3.1 if语句</h3><ul>
<li>c++规定else与离它最近的尚未匹配的if匹配。</li>
</ul>
<h3 id="5-3-2-switch语句"><a href="#5-3-2-switch语句" class="headerlink" title="5.3.2 switch语句"></a>5.3.2 switch语句</h3><ul>
<li>case关键字和他对应的值一起被称为case标签，case标签必须是整型常量表达式。</li>
<li>一个case标签只能放一个值。</li>
<li>任何两种case标签的值不能相同，default也是一种特殊的case标签。</li>
<li>如果某个case标签匹配成功，将从该标签开始往后的顺序执行所有的case分支。除非程序中断了这一过程，也就是使用了break。</li>
<li>如果需要为case分支定义初始化一个变量，放在外面比较合适，而不是放在case分支里面。</li>
</ul>
<pre><code>练习5.9
int mian()
&#123;
    char ch;
    unsigned int vowelcnt = 0;
    while(cin&gt;&gt;ch)
    &#123;
        if(ch==&#39;a&#39;|| ch==&#39;e&#39;||ch==i||ch==&#39;o&#39;||ch==&#39;u&#39;)
            ++vowelcnt;
    &#125;
&#125;
</code></pre>
<pre><code>练习5.10
int main()
&#123;
    char ch;
    unsinged int aCnt,eCnt,iCnt,oCnt,uCnt = 0;
    while(cin&gt;&gt;ch)
    &#123;
        switch(ch)&#123;
            case &#39;a&#39;:
            case &#39;A&#39;:
                ++aCnt;
                break;
            case &#39;e&#39;:
            case &#39;E&#39;:
                ++eCnt;
                break;
            case &#39;i&#39;:
            case &#39;I&#39;:
                ++iCnt;
                break;
            case &#39;o&#39;:
            case &#39;O&#39;:
                ++oCnt;
                break;
            case &#39;u&#39;:
            case &#39;U&#39;:
                ++uCnt;
                break;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code>练习 5.13
(a)缺少break
(b)ix需要定义在case语句外面。
(c)不能使用case1,3,5,7,9的模式。
(d)不能使用变量作为case标签。改为const unsigned ival = 512,jval = 1024,kval = 4096;
</code></pre>
<h2 id="5-4-迭代语句"><a href="#5-4-迭代语句" class="headerlink" title="5.4 迭代语句"></a>5.4 迭代语句</h2><h3 id="5-4-1-while语句"><a href="#5-4-1-while语句" class="headerlink" title="5.4.1 while语句"></a>5.4.1 while语句</h3><ul>
<li>定义在while中的条件部分或者while循环内的变量每次迭代都经历从创建到销毁的过程。</li>
</ul>
<pre><code>练习5.14
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int mian()
&#123;
    string currString,preString = &quot;&quot;,maxString;
    int currCnt = 1,maxCnt = 0;
    while(cin&gt;&gt;curString)
    &#123;
        if(currString == preString)
        &#123;
            ++currCnt;
            if(currCnt &gt; maxCnt)
            &#123;
                maxCnt = currCnt;
                maxString = currString;
            &#125;
        &#125;
        else
        &#123;
            currCnt = 1;
        &#125;
        preString = currString;
    &#125;
    if(maxCnt&gt;1)
        cout&lt;&lt;&quot;出现最多的字符串是&quot;&lt;&lt;maxString;
    else
        cout&lt;&lt;&quot;没个字符串只出现了一次。&quot;
    return 0;
&#125;
</code></pre>
<h3 id="5-4-2-传统for语句"><a href="#5-4-2-传统for语句" class="headerlink" title="5.4.2 传统for语句"></a>5.4.2 传统for语句</h3><ul>
<li>for语句中的定义的对象只在for语句的循环体内可见。</li>
<li>和其他声明一样，for语句的初始化也可以定义多个对象，但是只能有一条声明语句。</li>
</ul>
<pre><code>练习 5.15
(a)定义了ix但是想要在for循环之外使用，错误。
(b)少了一个分号
</code></pre>
<pre><code>练习5.17
# include &lt;iostream&gt;
#include &lt;vector&gt;

bool VIsEqual(const vector&lt;int&gt; &amp;vInt,const vecotr&lt;int&gt; &amp;Int2)
&#123;
    bool isEqual = true;
    auto min = vInt.size()&lt;vInt2.size()?vInt.size():vInt2.size();
    for(int i = 0;i&lt;min;i++)
    &#123;
        if(vInt[i]!=vInt2[i])
            isEqual = false;
    &#125;
   return isEqual;
&#125;

int main()
&#123;
    vector&lt;int&gt; vInt,vInt2;
&#125;
</code></pre>
<h3 id="5-4-3-范围for语句"><a href="#5-4-3-范围for语句" class="headerlink" title="5.4.3 范围for语句"></a>5.4.3 范围for语句</h3><pre><code>vector&lt;int&gt; v = &#123;0,1,2,3,4,5,6,7,8,9&#125;;
for(auto &amp;r : v)
&#123;
    r *= 2;
&#125;

//等价于
for(auto beg = v.begin(),end = v.end();beg!=end;++beg)
&#123;
    auto &amp;r = *beg;
    r*=2;
&#125;
</code></pre>
<ul>
<li>不能通过范围for循环添加容器的元素，因为在for语句中运存了end()的值。</li>
</ul>
<h3 id="5-4-4-do-while-语句"><a href="#5-4-4-do-while-语句" class="headerlink" title="5.4.4 do while 语句"></a>5.4.4 do while 语句</h3><pre><code>do 
    statement
while(condition);
</code></pre>
<ul>
<li>do while语句在括号包围起来的条件后面添加一个分号表示语句结束。</li>
<li>出现在do-while条件部分的变量必须定义在循环体之外。否则在非条件定义的变量在条件中不可见。</li>
</ul>
<pre><code>练习5.18
(a) do&#123;
        ...
    &#125;while(cin);
(b) 
    int ival;
    do&#123;
    
    &#125;while(int ival = get_response());
(c)
    int ival;
    do&#123;
        ival = get_value();
    &#125;while(ival);
    
</code></pre>
<h2 id="5-5-跳转语句"><a href="#5-5-跳转语句" class="headerlink" title="5.5 跳转语句"></a>5.5 跳转语句</h2><h3 id="5-5-1-break语句"><a href="#5-5-1-break语句" class="headerlink" title="5.5.1 break语句"></a>5.5.1 break语句</h3><ul>
<li>break语句负责终止离他最近的while、do-while、for和switch语句。</li>
</ul>
<pre><code>int main()
&#123;
    bool isEqual = false;
    string curString,preString = &quot;&quot;;
    while(cin&gt;&gt;curString)
    &#123;
        if(curString == preString)
            isEqual = true;
            break;
    &#125;
    if(isEqual)
        cout&lt;&lt;curString;
    else
        cout&lt;&lt;&quot;没有重复单词&quot;;
&#125;
</code></pre>
<h3 id="5-5-2continue-语句"><a href="#5-5-2continue-语句" class="headerlink" title="5.5.2continue 语句"></a>5.5.2continue 语句</h3><ul>
<li>continue 语句中断当前的迭代，但是任然继续循环</li>
</ul>
<h3 id="5-5-3-goto语句"><a href="#5-5-3-goto语句" class="headerlink" title="5.5.3 goto语句"></a>5.5.3 goto语句</h3><ul>
<li>goto语句从goto语句无条件的跳转到同一函数的另一条语句。</li>
<li>goto语句跳转到带标签的语句。尽量不要使用goto语句。</li>
</ul>
<h2 id="5-6-try-语句块和异常处理"><a href="#5-6-try-语句块和异常处理" class="headerlink" title="5.6 try 语句块和异常处理"></a>5.6 try 语句块和异常处理</h2><h3 id="5-6-1-throw-表达式"><a href="#5-6-1-throw-表达式" class="headerlink" title="5.6.1 throw 表达式"></a>5.6.1 throw 表达式</h3><ul>
<li>程序的异常检测部分使用throw表达式引发一个异常。抛出异常将终止当前函数，并吧控制权转移给能处理该异常的代码。</li>
</ul>
<h3 id="5-6-2-try语句块"><a href="#5-6-2-try语句块" class="headerlink" title="5.6.2 try语句块"></a>5.6.2 try语句块</h3><pre><code>while(cin&gt;&gt;item1&gt;&gt;item2)
&#123;
    try&#123;
        //执行添加连个sales_item对象的代码
        //如果添加失败，代码超出runtime_error一床
        throw runtime_error(&quot;data must refer to same isbn&quot;);
    &#125;catch(runtime_error err)&#123;
        cout&lt;&lt;err.what()&lt;&lt;&quot;try again?enter y or n&quot;&lt;&lt;endl;
        char c;
        cin&gt;&gt;c;
        if(!cin||c==&#39;n&#39;)
            break;
    &#125;
&#125;
</code></pre>
<ul>
<li>寻找处理代码的过程与函数调用相反，放异常被抛出是，首先搜错抛出该异常的函数，如果没有找到匹配的catch语句，终止该函数，在调用它的函数中寻找。最后到terminate的标准库函数，该函数的行为和系统相关。</li>
</ul>
<h3 id="5-6-3-标准异常"><a href="#5-6-3-标准异常" class="headerlink" title="5.6.3 标准异常"></a>5.6.3 标准异常</h3><ul>
<li>c++标准库定义了一组类，用于报告标准库函数遇到的问题。</li>
<li>exception头文件定义了通用的异常类exception，只报告异常的发生，不提供额外信息。</li>
<li>stdexcept头文件定义了集中常用的异常类。</li>
<li>new头文件定义了bad_alloc异常类型</li>
<li>type_info头文件定义了bad_cast头文件类型。</li>
<li>异常类型定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个c风格字符串。该字符串的目的提供关于异常的一些文本信息。</li>
</ul>
<pre><code>练习 5.25
int mian()
&#123;
    int ival1,ival2;
    while(cin&gt;&gt;ival1&gt;&gt;ival2)
    &#123;
        try
        &#123;
            if(ival2 == 0)
                throw runtime_error(&quot;除数不能为0&quot;);
            cout&lt;&lt;ival1/ival2;
        &#125;
        catch(runtime_error err)
        &#123;
            cout&lt;&lt;err.what();
            cout&lt;&lt;&quot;是否继续 y or n&quot;&lt;&lt;endl;
            char ch;
            cin&gt;&gt;ch;
            if(ch!=&#39;y&#39;&amp;&amp;ch!=&#39;Y&#39;)
                break;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<h1 id="第6章-函数"><a href="#第6章-函数" class="headerlink" title="第6章 函数"></a>第6章 函数</h1><h2 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h2><ul>
<li>函数的调用完成两项工作：一个是用实参初始化函数对应的形参，一个是将控制权交给被调用的函数。</li>
</ul>
<pre><code>练习6.1
形参出现在函数的定义地方，而实参出现咋函数的调用地方。
</code></pre>
<pre><code>练习6.2
(a) 函数的 返回值是string类型
(b) 函数没有返回值。
(c) 函数的参数不能重复。
(d) 函数体必须放在括号中。
</code></pre>
<pre><code>练习6.3
int fact(int val)
&#123;
    int ret = 1;
    if(val&lt;0)return -1;
    while(val&gt;0) ret*= ret*val;
    return ret;
&#125;
</code></pre>
<pre><code>练习6.4
#include&lt;iostream&gt;

int main()
&#123;
    int num ;
    cin&gt;&gt;num
    cout&lt;&lt;fact(num)&lt;&lt;endl;
&#125;
</code></pre>
<h3 id="6-1-1局部对象"><a href="#6-1-1局部对象" class="headerlink" title="6.1.1局部对象"></a>6.1.1局部对象</h3><ul>
<li>局部静态对象在程序执行路径第一次经过对象的定义语句时初始化，知道程序终止才会被销毁。</li>
</ul>
<pre><code>练习6.6
形参是一种自动对象，在函数开始为形参申请内存，用实参来初始化形参。
普通变量是在定义该变量的语句处创建自动对象。
局部变量在第一次遇到的时候创建，然后在程序结束时销毁。
</code></pre>
<pre><code>练习6.7
int func()
&#123;
    static int temp = -1;
    ++temp;
    return (temp==0)?0:1;
&#125;
</code></pre>
<h3 id="6-1-2-函数声明"><a href="#6-1-2-函数声明" class="headerlink" title="6.1.2 函数声明"></a>6.1.2 函数声明</h3><ul>
<li>函数的名字必须在使前声明，函数只能定义一次，可以声明多次。</li>
</ul>
<h2 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a>6.2 参数传递</h2><ul>
<li>当形参是引用类型，我们说它对应的实参被引用传递或函数被传引用调用。引用形参是他对应实参的别名。</li>
<li>当实参的值被拷贝给形参的时候，形参和实参是两个相互独立的对象，我们说实参被按值传递。或者函数被传值调用。</li>
</ul>
<h3 id="6-2-1-传值参数"><a href="#6-2-1-传值参数" class="headerlink" title="6.2.1 传值参数"></a>6.2.1 传值参数</h3><ul>
<li>指针的行为和其他非引用类型一样，但是当两个指针都指向一个对象，也就实现了可以对对象的修改。建议使用引用类型而不是指针。</li>
</ul>
<pre><code>void swap(int *pval,int *pval2)
&#123;
    int temp = *pval;
    *pval = *pval2;
    *pval2 = temp;
&#125;
</code></pre>
<h3 id="6-2-2-传引用参数"><a href="#6-2-2-传引用参数" class="headerlink" title="6.2.2 传引用参数"></a>6.2.2 传引用参数</h3><ul>
<li>使用引用形参可以返回额外的信息，也就是添加多一点的形参，该参数用引用形式表示，就可以返回多个参数了。</li>
</ul>
<pre><code>练习6.12
引用更加容易实现，不用写解引用的操作。也不需要额外声明指针变量，避免了拷贝指针的值。
</code></pre>
<pre><code>一个是按值传递一个是按引用传递。
</code></pre>
<h3 id="6-2-3-const形参和实参"><a href="#6-2-3-const形参和实参" class="headerlink" title="6.2.3 const形参和实参"></a>6.2.3 const形参和实参</h3><ul>
<li>实参初始化形参会忽略掉顶层const</li>
<li>把函数不会改变的形参定义为普通引用时一种比较常见的错误。</li>
<li>字面值常量可以作为常量引用的形参的值</li>
</ul>
<pre><code>练习6.16
bool is_empty(const string &amp;s)&#123;return s.empty();&#125;
</code></pre>
<pre><code>练习6.17
bool isContain(const string &amp;s)
&#123;
    for(auto temp:s)
        if(isupper(temp))
            return true;
    return false;
&#125;

void ChangeToLower(string &amp;s)
&#123;
    for(auto &amp;temp:s)
        temp = tolower(temp);
&#125;
</code></pre>
<pre><code>练习6.18
(a) bool compare(const matrix &amp;matrix1,const matrix &amp;matrix2);
(b) vector&lt;int&gt;::iterator change_val( int a,vector&lt;int&gt;::iterator &amp;vInt);
</code></pre>
<pre><code>练习6.19
(a) 不合法
(b) 合法
(c) 合法
(d) 合法
</code></pre>
<h3 id="6-2-4-数组形参"><a href="#6-2-4-数组形参" class="headerlink" title="6.2.4 数组形参"></a>6.2.4 数组形参</h3><ul>
<li>无法以值得形式使用数组参数。我们为函数传递一个数组的时候，实际上传递的是指向首元素的指针。</li>
<li>和其他使用数组的代码一样，以数组为形参的函数也必须保证使用数组不会越界。</li>
<li>管理指针形参常用的三个方法：<ul>
<li>使用标记指定数组长度，类似于string的方法。</li>
<li>使用标准库的规范。传递指向数组首元素和尾后元素的指针。</li>
<li>显示传递一个表示数组大小的形参。</li>
</ul>
</li>
<li>数组引用形参在声明的时候不能缺少括号，缺少了括号就变成了引用的数组了。<pre><code>f(int &amp;arr[10]);//错误
f(int (&amp;arr)[10])&#39;&#39;
</code></pre>
</li>
<li>传递多维数组真是传递的就是指向数组首元素的指针，数组首元素是数组，所以是指向数组的指针。</li>
</ul>
<pre><code>练习6.21
int MaxValue(const int ival,const int *pval)
&#123;
    return (ival&lt;*pval?*pval:ival);
&#125;
</code></pre>
<pre><code>练习6.22
void swapPoint(const int *p1,const int *p2)
&#123;
    const int *temp = p1;
    p1 = p2;
    p2 = temp;
&#125;
</code></pre>
<pre><code>练习6.24
虽然我们希望传入的数组维度是10，但是实际上可以传入任意维度的数组，如果传入的维度小于10的数组，就会输出
未定义的一些值。
</code></pre>
<h3 id="6-2-5-mian：处理命令行选项"><a href="#6-2-5-mian：处理命令行选项" class="headerlink" title="6.2.5 mian：处理命令行选项"></a>6.2.5 mian：处理命令行选项</h3><ul>
<li><code>int mian(int argc,char *argv[])</code>第一个参数是数组中字符串的数量，第二个参数是一个数组，元素是指向c风格字符串的指针。</li>
<li>当实参传给main函数之后，argv的第一个元素指向程序名字或者一个空字符串，接下来的元素一次传递命令行提供的实参，最后一个指针之后的元素值保证为0.</li>
</ul>
<pre><code># include &lt;iostream&gt;

int main(int argc,char *argv[])
&#123;
    string ret;
    for(auto temp:argv)
        ret += temp;
    cout&lt;&lt;ret&lt;&lt;endl;
&#125;
</code></pre>
<h3 id="6-2-6-含有可变形参的函数"><a href="#6-2-6-含有可变形参的函数" class="headerlink" title="6.2.6 含有可变形参的函数"></a>6.2.6 含有可变形参的函数</h3><ul>
<li>如果所有的实参类型相同，可以传递一个名为initilizer_list的标准库类型，如果实参的类型不同，可以编写一个特殊的函数，也就是所谓的可变参数模板。</li>
</ul>
<pre><code>initializer_list提供的操作
initializer_list&lt;T&gt; lst;            //默认初始化，T类型元素的空列表。
initializer_list&lt;T&gt; lst&#123;a,b,c...&#125;;//lst的元素和初始值一样多，lst的元素是对应初始值的副本，列表中的元素是const。
lst2(lst);          //  不会拷贝元素，原始列表和副本共享元素。
lst2 = lst;
lst.size()
list.begin()
list.end()
</code></pre>
<ul>
<li>initializer_list中的值永远是常量值。</li>
<li>如果想向initializer_list形参中传递一个值的序列，必须把序列放到一对花括号中。<pre><code>if(expected!=actual)
    error_msg(&#123;&quot;functionX,expected,actual&quot;&#125;);
else
    error_msg(&#123;&quot;functionX&quot;,&quot;okey&quot;&#125;);
</code></pre>
</li>
<li>省略符形参是已改仅仅用于c和c++通用类型，大多是类类型对象在传递给省略符形参的是否无法正确拷贝。</li>
<li>省略符形参只能出现在参数列表的最后一个位置。</li>
</ul>
<pre><code>练习6.27
int sum(iniitizlizer_list&lt;int&gt; list)
&#123;
    int ret = 0;
    for(atuo i:list)
        ret+=i;
    return ret;
&#125;
</code></pre>
<pre><code>练习6.28
elem类型是const string &amp;，使用引用时为了避免拷贝长字符串。
</code></pre>
<pre><code>练习6.29
当容器中的类型是类类型或者容器类型才有必要，这样会避免不必要的拷贝赋值操作 
</code></pre>
<h2 id="6-3-返回类型和return语句"><a href="#6-3-返回类型和return语句" class="headerlink" title="6.3 返回类型和return语句"></a>6.3 返回类型和return语句</h2><h3 id="6-3-1-无返回类型函数"><a href="#6-3-1-无返回类型函数" class="headerlink" title="6.3.1 无返回类型函数"></a>6.3.1 无返回类型函数</h3><ul>
<li>没有返回值类型return语句只用在没有返回值类型的void函数中。</li>
</ul>
<h3 id="6-3-2-有返回值的函数"><a href="#6-3-2-有返回值的函数" class="headerlink" title="6.3.2 有返回值的函数"></a>6.3.2 有返回值的函数</h3><ul>
<li>在含有return语句的循环后面应该有一条return语句，如果没有的话程序是错误的，很多编译器无法发现此类错误。</li>
<li>如果函数返回引用，该引用仅是他所引对象的一个别名。不会返回拷贝的对象。</li>
<li>不要返回局部对象的引用和指针。因为函数完成后，局部的对象会被释放，指针会指向一个不存在的对象。</li>
<li>函数的返回类型决定函数调用是否是左值，调用一个返回引用的函数的到左值，其他类型返回右值。</li>
<li>c++11规定函数可以返回花括号包围的值的列表，类似于其他 返回结果，此处的列表也用来对函数返回的临时量进行初始化。</li>
</ul>
<pre><code>练习 6.31
如果引用所引的是函数之前就存在的对象，则返回的引用时引用的，如果引用所引的是函数的局部变量，返回的引用无效。如果不希望返回的对象被修改，返回对常量的引用。
</code></pre>
<pre><code>void func(vector&lt;int&gt; vInt,unsinged index)
&#123;
    unsingned sz = vInt.size();
    if(!vInt.empty()&amp;&amp;index&lt;sz)
    &#123;
        cout&lt;&lt;vInt[index]&lt;&lt;endl;
        func(vInt,index+1);
    &#125;
&#125;
</code></pre>
<pre><code>练习6.31
如果结果是负数会一直递归下去，会出现问题。
</code></pre>
<h3 id="6-3-3-返回数组指针"><a href="#6-3-3-返回数组指针" class="headerlink" title="6.3.3 返回数组指针"></a>6.3.3 返回数组指针</h3><ul>
<li>返回数组指针的函数，int(*func(int i))[10];该函数的返回类型数指向数组的指针，该函数接受的参数是int类型。</li>
<li>尾置返回类型，任何函数都可以使用，但是这种类型一般对比较复杂的函数有效，auto func(int i)-&gt;int(*)[10];</li>
<li>可以使用decltype关键字申明返回类型，前提是知道函数指向哪个数组。<pre><code>int odd[] = &#123;1,2,3,4,5&#125;;
int even[] = &#123;1,2,3,4,5&#125;;
decltype(odd) *arrPtr(int i)
&#123;
    return (i%2)?&amp;odd:&amp;even;
&#125;
</code></pre>
</li>
</ul>
<pre><code>练习6.36
string (&amp;func())[10];

typedef string vString[10];
vString &amp;func();

auto func() -&gt; string(&amp;)[10];

string vstring[10];
decltype(vstring) &amp;func();
</code></pre>
<h2 id="6-4-函数重载"><a href="#6-4-函数重载" class="headerlink" title="6.4 函数重载"></a>6.4 函数重载</h2><ul>
<li>不允许两个函数除了返回值类型其他所有的要素相同。</li>
<li>顶层const不影响传入函数的对象，一个拥有顶层cosnt的形参无法和另一个没有顶层const的形参区分开来。</li>
<li>底层const编译器可以通过实参是否是常量来推断调用哪个函数。</li>
<li>const_cast可以对常量和非常量进行转化，所以可以在一个接受非常量的函数中调用一个接受常量的重载函数来实现该函数，方法就是对形参进行const_cast。</li>
</ul>
<pre><code>练习 6.39
(a) 非法，顶层const不区分重载
(b) 非法，不能只用返回值来区分重载
(c) 合法。
</code></pre>
<h3 id="6-4-1-重载和作用域"><a href="#6-4-1-重载和作用域" class="headerlink" title="6.4.1 重载和作用域"></a>6.4.1 重载和作用域</h3><ul>
<li>c++中名字查找是发生在类型检查之前的。如果在函数局部作用域中声明了一个函数，就会对外部作用域的函数进行隐藏，从而无法找到外部作用域的函数。</li>
</ul>
<h2 id="6-5-特殊用途语言特性"><a href="#6-5-特殊用途语言特性" class="headerlink" title="6.5 特殊用途语言特性"></a>6.5 特殊用途语言特性</h2><h3 id="6-5-1-默认实参"><a href="#6-5-1-默认实参" class="headerlink" title="6.5.1 默认实参"></a>6.5.1 默认实参</h3><ul>
<li>如果一个参数被赋予了默认值，那么他后面的所有参数都必须有默认值。而且在调用的时候，如果想覆盖最后一个参数的默认值，前面的参数必须提供实参。</li>
<li>在给定作用域中的一个形参只能被赋予一次默认实参。</li>
<li>用作默认实参的名字在函数声明的所在作用域内被解析，而这些名字的求值过程发生在函数调用的时候。</li>
</ul>
<pre><code>练习6.40
第二个声明是错误的，因为一旦某个参数呗赋予了默认值，他后面的参数都要赋予默认值。
</code></pre>
<pre><code>练习6.41
只有第二个是正确的。
</code></pre>
<h3 id="6-5-2-内联函数和constexpr函数"><a href="#6-5-2-内联函数和constexpr函数" class="headerlink" title="6.5.2 内联函数和constexpr函数"></a>6.5.2 内联函数和constexpr函数</h3><ul>
<li>内联函数只是想编译器发出一个请求，编译器可以选择忽略这个请求。</li>
<li>constexpr函数是能用于常量表达式的函数，函数的返回值和参数类型都是字面值类型。函数体只有一个return语句<pre><code>constexpr int new_sz()&#123;return 42;&#125;;
constexpr int foo = new_sz();
</code></pre>
</li>
</ul>
<h3 id="6-5-3-调试帮助"><a href="#6-5-3-调试帮助" class="headerlink" title="6.5.3 调试帮助"></a>6.5.3 调试帮助</h3><ul>
<li>assert(expr)如果expr为0，assert输出信息并终止程序的执行，否则什么都不做。</li>
<li>assert的行为依赖于NDEBUG的预处理变量的状态。如果定义了该变量，assert什么都不做。</li>
<li>NDEBUG也可以用来编写调试代码，如果NDEBUG未定义，就会执行#ifndef 和#endif之间的代码。</li>
</ul>
<h2 id="6-6-函数匹配"><a href="#6-6-函数匹配" class="headerlink" title="6.6 函数匹配"></a>6.6 函数匹配</h2><ul>
<li>基本原则是，实参类型和形参类型越接近，他们匹配的越好。</li>
<li>调用重载函数的时候应该尽量必变强制类型转换。</li>
</ul>
<pre><code>练习6.50
(a)调用具有二义性
(b)调用f(int a)
(c) 调用f(int a,int b)
(d)调用f(double a,double b =);
</code></pre>
<h2 id="6-7-函数指针"><a href="#6-7-函数指针" class="headerlink" title="6.7 函数指针"></a>6.7 函数指针</h2><ul>
<li>函数指针指向的是函数而不是对象，函数指针指向某种类型，而函数的类型有他的返回值和形参类型决定。与函数名无关。</li>
<li>当我们把函数名作为一个值使用的时候，该函数自动转换为指针。</li>
<li>虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。我们可以把函数直接当实参使用，会自动转为指针。<pre><code>//func 和func2是函数类型
typedef bool func(const string &amp;,cosnt string&amp;);
typedef decltype(lengthCompare) func2; 

//funcp和funcp2是指向函数的指针
typedef bool(*funp)(int i,int j);
typedef decltype(lenthCompare) *funcp2;
</code></pre>
</li>
<li>和数组类似虽然不能返回一个函数，但是可以返回指向函数类型的指针。可以使用类型别名，也可以使用声明式或者使用尾置返回类型。如果明确知道返回的函数是那个，可以使用decltype简化书写函数指针返回类型的过程。</li>
</ul>
<pre><code>练习6.54
int fun(int a,int b);
typedef int (*funcp)(int a,int b);
vector&lt;funcp&gt; vFuncp;
</code></pre>
<pre><code>int func1(int a,int b)
&#123;
    return a+b;
&#125;
int func2(int a,int b)
&#123;
    return a-b;
&#125;
int func3(int a,int b)
&#123;
    return a*b;
&#125;
int func4(int a,int b)
&#123;
    return a/b;
&#125;
vFuncp.push_back(func1);
vFuncp.push_back(func2);
vFuncp.push_back(func3);
vFuncp.push_back(func4);
vFuncp[i](1,2);
</code></pre>
<h1 id="第7章-类"><a href="#第7章-类" class="headerlink" title="第7章 类"></a>第7章 类</h1><h2 id="7-1定义抽象数据类型"><a href="#7-1定义抽象数据类型" class="headerlink" title="7.1定义抽象数据类型"></a>7.1定义抽象数据类型</h2><h3 id="7-1-1-设计Sales-data类"><a href="#7-1-1-设计Sales-data类" class="headerlink" title="7.1.1 设计Sales_data类"></a>7.1.1 设计Sales_data类</h3><ul>
<li>常量成员函数其实就是给this指针所指的对象声明为const，所以该常量成员函数不能改变调用它的对象的内容。</li>
<li>编译器首先编译成员函数的声明，然后编译成员函数体，所以成员函数可以随意使用类中的其他成员而无需在意这些成员出现的次序。</li>
</ul>
<pre><code>练习7.2
class Sales_data
&#123;
private:
    string bookNo;
    unsigned units_sold = 0;
    double sellingprice = 0.0;
    double saleprice = 0.0;
    double discont = 0.0;
public:
    string isbn const &#123;return bookNo;&#125;
    Sales_data&amp; combine(const Sales_data &amp; rhs)
    &#123;
        units_sold += rhs.units_sold;
        slaeprice = (rhs.saleprice*rhs.units_sold + saleprice*units_sold)/(rhs.units_sold+units_sold);
        if(sellingprice != 0)
            discont = saleprice / sellingprice;
            return *this;
    &#125;
&#125;
</code></pre>
<pre><code>练习7.4 
class Person
&#123;
private:
    string name;
    string address;
&#125;;
</code></pre>
<pre><code>练习7.5
class Person
&#123;
private:
    string name;
    string address;
public:
    string getName() const&#123;return name&#125;;
    string getAddress() const&#123;return address&#125;;
&#125;;
</code></pre>
<h3 id="7-1-3-定义类相关的非成员函数"><a href="#7-1-3-定义类相关的非成员函数" class="headerlink" title="7.1.3 定义类相关的非成员函数"></a>7.1.3 定义类相关的非成员函数</h3><ul>
<li>如果函数在概念上属于列但是不定义在类中，则一般将其放到.h文件中，这样就只需要引用一个文件。</li>
</ul>
<pre><code>练习7.9
class Person
&#123;
private:
    string name;
    string address;
public:
    string getName() const&#123;return name&#125;;
    string getAddress() const&#123;return address&#125;;
    Person() = default;
    Person(const string &amp; iname,const string &amp;iaddress):name(iname),address(iaddress) &#123;&#125;;
    Person(istream &amp;is)&#123;return is&gt;&gt;*this;&#125;;
friend istream&amp; read(istream &amp;is,Person &amp;person);
friend ostream &amp;print(ostream &amp;os,const Person &amp; person);
&#125;;
istream&amp; read(istream &amp;is,Person &amp;person)
&#123;
    is&gt;&gt;person.name&gt;&gt;person.address;
    return is;
&#125;
ostream &amp;print(ostream &amp;os,const Person &amp; person)
&#123;
    os&lt;&lt;person.name&lt;&lt;&quot; &quot;&lt;&lt;person.address;
    return os;
&#125;
</code></pre>
<h3 id="7-1-4-构造函数"><a href="#7-1-4-构造函数" class="headerlink" title="7.1.4 构造函数"></a>7.1.4 构造函数</h3><ul>
<li>只要当类没有声明默认构造函数的时候，编译器才会自动的生成默认构造函数。</li>
<li>在c++11中如果我们需要默认的行为，可以通过在参数列表后面加上&#x3D;default俩要求编译器生成构造函数。</li>
<li>一般情况下，构造函数使用类内初始值是一种好的习惯。构造函数不应该轻易覆盖类内的初始值，除非不一样。</li>
</ul>
<h2 id="7-2-访问控制和封装"><a href="#7-2-访问控制和封装" class="headerlink" title="7.2 访问控制和封装"></a>7.2 访问控制和封装</h2><h3 id="7-2-1-友元"><a href="#7-2-1-友元" class="headerlink" title="7.2.1 友元"></a>7.2.1 友元</h3><ul>
<li>友元可以允许其他类或者函数访问他的共有成员。</li>
<li>类的封装的两个优点<ul>
<li>确保用户代码不会无意间破坏封装对象的状态。</li>
<li>被封装的类的具体实现细节可以随便改变，而不用调整用户级别的代码。</li>
</ul>
</li>
<li>友元的声明只是指定了访问的权限，如果我们希望类的用户能够调用某个友元函数，需要在该类中再次声明该函数。</li>
</ul>
<h2 id="7-3-类的其他特性"><a href="#7-3-类的其他特性" class="headerlink" title="7.3 类的其他特性"></a>7.3 类的其他特性</h2><h3 id="7-3-1-类成员再谈"><a href="#7-3-1-类成员再谈" class="headerlink" title="7.3.1 类成员再谈"></a>7.3.1 类成员再谈</h3><ul>
<li>如果希望修改类的某个数据成员即使是在const成员函数中，可以将该成员声明为mutable关键字做到这一点。</li>
</ul>
<pre><code>class Screan
&#123;
private:
    unsigned height = 0,width = 0;
    unsigned cursor = 0;
    string contents;
public:
    Screan() = default;
    Screan(unsigned ht,unsigned wd):height(ht),width(wd),contents(ht*wd,&#39; &#39;)&#123;&#125;;
    Screan(unsigned ht,unsigned wd,char c):height(ht),width(wd),contents(ht*wd,c)&#123;&#125;;
public：
    Screan&amp; move(unsigned ht,unsigned wd)&#123;cursor = th * width + wd;return *this&#125;;
    Screan&amp; set(char a)
    &#123;
        contents[cursor] = a;
        return * this;
    &#125;
    Screan&amp; display(ostreawm&amp; os)
    &#123;
        os&lt;&lt;contents;
        return *this;
    &#125;
public:
    frinend Window_mgr::clear(unsigned index));
&#125;;

class Window_mgr
&#123;
private:
    vector&lt;Screen&gt; screens&#123;Screen(24,80,&#39; &#39;)&#125;;
public: 
    void clear();
&#125;;

void Window_mgr::clear(unsigned index)
&#123;
    Screen &amp;s = screens[index];
    s.contents = string(s.height*s.width,&#39; &#39;);
&#125;
</code></pre>
<h3 id="7-3-2-返回-this的成员函数"><a href="#7-3-2-返回-this的成员函数" class="headerlink" title="7.3.2 返回*this的成员函数"></a>7.3.2 返回*this的成员函数</h3><h3 id="7-3-3-类类型"><a href="#7-3-3-类类型" class="headerlink" title="7.3.3 类类型"></a>7.3.3 类类型</h3><ul>
<li>我们可以定义指向不完整类型的指针，但是不能定义指向不完整类型的对象。如果要定义对象，必须知道对象的定义。</li>
</ul>
<pre><code>class X;

class Y
&#123;
  X x;  
&#125;;
class X
&#123;
    Y * y;
&#125;;
</code></pre>
<h3 id="7-3-4-友元再探"><a href="#7-3-4-友元再探" class="headerlink" title="7.3.4 友元再探"></a>7.3.4 友元再探</h3><ul>
<li>类也可以吧其他类定义为友元，也还可以把其他类的成员函数定义为友元。</li>
<li>友元关系不具有传递性，每个类负责控制自己的友元类和友元函数。</li>
<li>如果一个类想把一组重载函数声明为他的友元，需要对这组函数中的每个函数分别声明。</li>
</ul>
<h2 id="7-4-类的作用域"><a href="#7-4-类的作用域" class="headerlink" title="7.4 类的作用域"></a>7.4 类的作用域</h2><ul>
<li>函数的返回值类型通常位与类的作用域之外，所以返回值类型必须明确指明他是哪个类的成员。</li>
</ul>
<pre><code>练习7.33
Screen::pos Screen::size() const
&#123;
    return height*width;
&#125;
</code></pre>
<h3 id="7-4-1-名字的查找与类的作用域"><a href="#7-4-1-名字的查找与类的作用域" class="headerlink" title="7.4.1 名字的查找与类的作用域"></a>7.4.1 名字的查找与类的作用域</h3><ul>
<li>成员函数直到整个类可见后才会被处理，所以他可以使用类中定义的任何名字。</li>
<li>类型名的定义通常在类开始的地方，保证所有使用该类型的成员都在类名定义的后面。</li>
<li>如果要访问外层作用域的对象，可以使用::来访问。</li>
</ul>
<pre><code>练习7.35
typedef string Type1;
Type1 initVal();
class Exercise
&#123;
public:
    typedef double Type2;
    Type2 setVal(Type2);
    Type2 initVal();
private:
    int val;
&#125;;
Exercise::Type2 Exercise::setVal(Type2 parm)
&#123;
    val = parm + initVla();
    return val;
&#125;
</code></pre>
<h2 id="7-5-构造函数再探"><a href="#7-5-构造函数再探" class="headerlink" title="7.5 构造函数再探"></a>7.5 构造函数再探</h2><h3 id="7-5-1-构造函数初始值列表"><a href="#7-5-1-构造函数初始值列表" class="headerlink" title="7.5.1 构造函数初始值列表"></a>7.5.1 构造函数初始值列表</h3><ul>
<li>当成员属于某个类类型而且该类没有定义默认构造函数的时候，必须为这个成员初始化。</li>
<li>如果成员是const、引用、或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始化值列表来为这些成员提供初值。</li>
<li>最好另构造函数的初始值的顺序和成员声明的顺序一致，而且如果可能尽量避免使用某些成员初始化其他成员。</li>
<li>如果一个构造函数为所以参数都提供了默认的实参，实际上也就定义了默认构造函数。<pre><code>class ConstRef
&#123;
    public:
        ConstRef(int ii);
    private:
        int i;
        const int ci;
        int &amp;ri;
&#125;;
ConstRef::ConstRef(int ii)
&#123;
    i = ii;
    ci = ii;    //错误不能给const赋值
    ri = i;     //错误，ri没有初始化。
&#125;
</code></pre>
</li>
</ul>
<h3 id="7-5-2-委托构造函数"><a href="#7-5-2-委托构造函数" class="headerlink" title="7.5.2 委托构造函数"></a>7.5.2 委托构造函数</h3><ul>
<li>一个委托构造函数使用它所属的类的其他构造函数执行它自己的初始化过程。</li>
</ul>
<h3 id="7-5-3-默认构造函数的作用"><a href="#7-5-3-默认构造函数的作用" class="headerlink" title="7.5.3 默认构造函数的作用"></a>7.5.3 默认构造函数的作用</h3><ul>
<li>当对象被默认初始化或者值初始化的时候自动调用默认构造函数。</li>
<li>定义一个使用默认构造函数进行初始化的对象，正确方法是去掉对象后的括号，不然定义的是函数而不是对象了。</li>
<li>对于编译器合成的默认构造函数来说，类类型的成员执行各自所以属类的默认构造函数，而内置类型和符合类型的成员只对定义在全局作用域中的对象执行初始化。</li>
</ul>
<h3 id="7-5-4-隐式的类类型转换"><a href="#7-5-4-隐式的类类型转换" class="headerlink" title="7.5.4 隐式的类类型转换"></a>7.5.4 隐式的类类型转换</h3><ul>
<li>转换构造函数可以通过一个实参调用构造函数定义了一条从构造函数的参数类型想类类型的隐世转换的规则。</li>
<li>只允许一步类类型的转换，且转换并比总是有效的。</li>
<li>可以将构造函数声明为explicit来防止隐式转换。</li>
<li>需要多个参数的构造函数不能用于执行隐式转换。</li>
</ul>
<h3 id="7-5-5-聚合类"><a href="#7-5-5-聚合类" class="headerlink" title="7.5.5 聚合类"></a>7.5.5 聚合类</h3><ul>
<li>聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足条件：<ul>
<li>所有成员都是public的。</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始值</li>
<li>没有基类，没有虚函数。</li>
</ul>
</li>
</ul>
<h3 id="7-5-6-字面值常量类"><a href="#7-5-6-字面值常量类" class="headerlink" title="7.5.6 字面值常量类"></a>7.5.6 字面值常量类</h3><ul>
<li>数据成员都是字面值类型的聚合类是字面值常量类型。聚合类的要求：<ul>
<li>数据成员都必须是字面值类型</li>
<li>类必须至少含有一个constexpr构造函数。</li>
<li>如果一个数据成员含类内初始值，则内置类型成员的初始值必须是一条常量表达式。或者若成员属于某种类型，则初始值必须使用成员自己的constexpr构造函数。</li>
<li>类必须使用析构函数的默认的定义，该成员负责销毁类的对象。</li>
</ul>
</li>
</ul>
<h2 id="7-6-类的静态成员"><a href="#7-6-类的静态成员" class="headerlink" title="7.6 类的静态成员"></a>7.6 类的静态成员</h2><ul>
<li>通过在成员声明前添加关键字static使得其余类关联在一起。</li>
<li>和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名，static关键字只能出现在类内部的声明语句中。</li>
<li>静态数据成员不属于类的任何一部分，所以我们不能再类的内部初始化静态成员。</li>
<li>可以为静态成员提供const整数类型的类内初始值。即使一个常量静态数据成员在类内被初始化了，一般情况下也要在类外部定义一下该成员。</li>
<li>静态数据成员的类型可以是他所属的类型，也就是静态成员可以是不完全类型。</li>
<li>我们可以使用静态成员作为默认实参。</li>
</ul>
<h1 id="第8章-IO库"><a href="#第8章-IO库" class="headerlink" title="第8章 IO库"></a>第8章 IO库</h1><h2 id="8-1-IO类"><a href="#8-1-IO类" class="headerlink" title="8.1 IO类"></a>8.1 IO类</h2><ul>
<li>iostream定义了用于读写流的基本类型，fstream定义了读写命名文件的类型，sstream定义了读写内存string对象的类型。</li>
<li>标准库使我们能忽略这些不同类型的流之间的差异是通过继承机制实现的。我们可以将一个继承类对象当做基类对象使用。</li>
</ul>
<h3 id="8-1-1-io对象无拷贝或赋值"><a href="#8-1-1-io对象无拷贝或赋值" class="headerlink" title="8.1.1 io对象无拷贝或赋值"></a>8.1.1 io对象无拷贝或赋值</h3><ul>
<li>由于不能拷贝IO对象所以不能将形参或者返回类型设置为流类型。进行IO操作的函数通常以引用形式传递和返回流</li>
</ul>
<h3 id="8-1-2-条件状态"><a href="#8-1-2-条件状态" class="headerlink" title="8.1.2 条件状态"></a>8.1.2 条件状态</h3><ul>
<li>IO类定义了一些函数和标志，帮助我们访问和操纵流的条件状态。</li>
<li>IO库定义了一个与机器无挂你的iostate类型，他提供了表达流状态的完整功能，包括4个iostate类型的constexpr值表示特定的位模式。badbit表示系统级错误，如不可恢复的读写错误，发生可恢复读写错误，failbit被置位。如果到文件末尾，eofbit和failbit会被置位。</li>
<li>流对象rdstate成员返回一个iostate值，setstate将给定条件位置位。</li>
</ul>
<pre><code>io库条件状态

strm::iostate                       //条件表达状态完整功能
strm::badbig                        //流已崩溃
strm::failbit                       //io操作失败
strm::eofbig                        //流到达了文件结束
strm::goodbig                       //流末处于错误状态，此值保证为o
s.eof()                             //流的eofbig置位(变为1)，返回true
s.fail()                            //流的failbit或badbit置位，返回true
s.bad()                             //
s.good()
s.clear()
s.clear(flags)
s.setstate(flags)
s.rdstate()                         //返回流s的当前状态，返回类型为strm::iostate
</code></pre>
<pre><code>练习8.1 
istream&amp; read(istream&amp; is)
&#123;
    int v;
    while(in&gt;&gt;v,!in.eof())
    &#123;
        if(in.bad())
            throw runtime_error(&quot;io流错误&quot;);
        if(in.fail())
        &#123;
            cerr&lt;&lt;&quot;数据错误&quot;&lt;&lt;endl;
            in.clear();
            in.ignore(100,&#39;\n&#39;);
            continue;
        &#125;
        cout&lt;&lt;v&lt;&lt;endl;
    &#125;
    in.clear();
    return in;
    while(is&gt;&gt;)
&#125;
</code></pre>
<pre><code>练习8.3 
遇到了文件结束符，遇到了io流错误，遇到了无效数据。
</code></pre>
<h3 id="8-1-3-管理输出缓冲"><a href="#8-1-3-管理输出缓冲" class="headerlink" title="8.1.3 管理输出缓冲"></a>8.1.3 管理输出缓冲</h3><ul>
<li>每个输出流都管理一个缓冲区，用来保存程序读写的数据。</li>
<li>导致缓冲刷新(数据真正写到输出设备或者文件)的原因：<ul>
<li>程序正常运行结束。</li>
<li>缓冲区满的时候。</li>
<li>使用操作符endl显示刷新缓冲区。</li>
<li>使用操作符unitbuf设置流内部状态。来清空缓冲区。</li>
<li>一个输出流关联到另一个流的时候，默认cin和cerr是关联到cout的，所以读cin和写cerr会导致cout缓冲区刷新。</li>
</ul>
</li>
<li>flush刷新缓冲区，但不输出任何额外的字符，ends向缓冲区中插入一个空字符，然后刷新缓冲区。</li>
<li>我们可以使用unitbuf操纵符告诉流接下来的每次操作之后都进行一次flush操作。<pre><code>cout&lt;&lt;unitbuf;          //所有输出操作都会被立即刷新
cout&lt;&lt;nounitbuf;        //回到正常刷新模式
</code></pre>
</li>
<li>x.tie(&amp;o)将流x关联到输出流o，每个流最多关联到一个流，但是多个流可以同时关联到同一ostream。</li>
</ul>
<h2 id="8-2-文件输入输出"><a href="#8-2-文件输入输出" class="headerlink" title="8.2 文件输入输出"></a>8.2 文件输入输出</h2><pre><code>fstream fstrm;          //创建一个未绑定的文件流
fstream fstrm(s);       //创建一个fstream，并打开名为s的文件
fstream fstrm(s,mode);  //按指定mode打开文件
fstrm.open(s)           //打开名为s的文件
fstrm.close()           //关闭与fstrm绑定的文件，返回void
fstrm.is_open()         //指出fstrm关联的文件是否打开成功也没有关闭。
</code></pre>
<h3 id="8-2-1-使用文件流对象"><a href="#8-2-1-使用文件流对象" class="headerlink" title="8.2.1 使用文件流对象"></a>8.2.1 使用文件流对象</h3><ul>
<li>对文件名既可以是string也可以是c风格字符数组，c++11支持 。</li>
<li>一旦一个文件流打开，他就保持了与对应文件的关联，对一个已经打开的文件流调用open会失败，导致failbit被置位。为了将文件流关联到另一个文件中，必须关闭已关联的文件。</li>
<li>当fstream对象被销毁的时候，close被会自动调用。</li>
<li>ifstream 向一个文件中读取数据，ofstream向一个中写入数据</li>
</ul>
<pre><code>练习8.4
vector&lt;string&gt; read(string filename)
&#123;
    ifstream in(filename); 
    if(!in)&#123;
        cout&lt;&lt;&quot;打开文件失败&quot;&lt;&lt;endl;
        return -1;
    &#125;
    string line;
    vector&lt;string&gt; vs;
    while(getline(in,line))
    &#123;
        vs.push_back(line);
    &#125;
&#125;
</code></pre>
<h3 id="8-2-2-文件模式"><a href="#8-2-2-文件模式" class="headerlink" title="8.2.2 文件模式"></a>8.2.2 文件模式</h3><pre><code>in          //读
out         //写
app         //每次写操作前定位到文件末尾
ate         //打开文件后立即定位到文件末尾
trunc       //截断文件
binary      //以二进制读写
</code></pre>
<ul>
<li>默认情况下out模式是截断文件的，也就是不会追加读写，如果想追加读写，添加app。</li>
<li>对于一个给定的流，每次打开文件都可以改变文件的模式。</li>
</ul>
<h2 id="8-3-string流"><a href="#8-3-string流" class="headerlink" title="8.3 string流"></a>8.3 string流</h2><ul>
<li>istringstream从string读取数据，ostringstream向string写数据。</li>
</ul>
<pre><code>sstream strm;           //strm是一个未绑定stringstream对象
sstream strm(s);        //strm是一个sstream对象，保存一个string s的拷贝。
strm.str()              //返回strm保存的string 的拷贝
strm.str(s)             //将string s拷贝到strm中。
</code></pre>
<h3 id="8-3-1-使用istringstream"><a href="#8-3-1-使用istringstream" class="headerlink" title="8.3.1 使用istringstream"></a>8.3.1 使用istringstream</h3><pre><code>练习8.9
int main()
&#123;
    ostringstream msg;
    msg&lt;&lt;&quot;c++ primer&quot;&lt;&lt;endl;
    istringstream in(msg.str());
    f(in);
    return 0;
&#125;
</code></pre>
<pre><code>练习8.10
int main()
&#123;
    ifstream in(&quot;data&quot;);
    if(!in)
    &#123;
        cerr&lt;&lt;&quot;无法打开输入文件&quot;&lt;&lt;endl;
        return -1;
    &#125;
    string line ;
    vector&lt;string&gt; vc;
    while(getline(in,line)
    &#123;
        vc.push_back(line);
    &#125;
    in.close();
    for(auto &amp;item : vc)
    &#123;
        istringstream line_str(item);
        string word;
        while(line_str&gt;&gt;word)
            cout&lt;&lt;word&lt;&lt;&quot; &quot;;
        cout&lt;&lt;endl;
    &#125;
&#125;
</code></pre>
<h1 id="第9章-顺序容器"><a href="#第9章-顺序容器" class="headerlink" title="第9章 顺序容器"></a>第9章 顺序容器</h1><h2 id="9-1-顺序容器简介"><a href="#9-1-顺序容器简介" class="headerlink" title="9.1 顺序容器简介"></a>9.1 顺序容器简介</h2><ul>
<li>所有的顺序容器都提供了快速顺序访问元素的能力。</li>
</ul>
<pre><code>顺序容器类型
vector          //可变大小数组，支持快速随机访问，在尾部之外的位置插入和删除元素可能很慢。
deque           //双端队列，支持快速随机访问。在头尾插入删除元素快
list            //双向链表，支持双向顺序访问，在list中的任何位置进行插入删除都快
forward_list    //单向链表，只支持单向顺序访问
array           //固定大小数组，支持快速随机访问。
string          //与vector类似，但只用来存储string。
</code></pre>
<h2 id="9-2-容器库概览"><a href="#9-2-容器库概览" class="headerlink" title="9.2 容器库概览"></a>9.2 容器库概览</h2><pre><code>容器的操作
---------------------类型别名---------------------------------------
iterator                                //此容器类型的迭代器类型
const_iterator                          //可以读取元素但是不能修改元素的迭代器类型
size_type                               //无符号整型，足够保存次容器最大可能容器的大小
defference_type                         //带符号整型，足够保存两个容器之间的距离
value_type                              //元素类型
reference                               //元素的左值类型：与value_type&amp;含义相同
const_reference                         //元素的const左值类型
----------------------构造函数-----------------------------------------
C c;                                    //默认初始化，构造空容器
C c1(c2);                               //构造c2的拷贝c1
C c(b,e);                               //构造c，将迭代器b和e指定范围内的容器元素拷贝到c(array不支持)
C c&#123;a,b,c...&#125;;                          //列表初始化c
------------------------赋值和swap------------------------------------------------
c1 = c2                                 //将c1中的元素替换为c2中的元素
c1 = &#123;a,b,c...&#125;                         //将c1中的元素替换为列表中的元素
a.swap(b)                               //交换a和b的元素
swap(a,b)                               //交换a和b的元素
------------------------大小-------------------------------------------------
c.size()                                //c中元素的数目(forward_list不支持)
c.max_size()                            //c可以保存的最大元素数目
c.empty()                               //若c中有元素为false
------------------------添加和删除元素(不同容器，接口可能不一样)---------------
c.insert(args)                          //将args中的元素拷贝到c
c.emplace(inits)                        //使用inits构造c中的一个元素
c.erase(args)                           //删除args指定的元素
c.clear()                               //删除c中所有元素
==,!=                                   //所欲容器支持
&lt;,&lt;=,&gt;,&gt;=                               //无序关联容器不支持
--------------------------获取迭代器--------------------------------------------
c.begin(),c.end()
c.cbegin(),c.cend()
---------------------------反向容器的额外成员(不支持forward_list)---------------------
reverse_iterator                        //按逆序寻址元素的迭代器
const_reverse_iterator
c.rbegin(),c.rend()                     //返回c的尾元素和首元素之前位置的迭代器。
c.crbegin(),c.crend()
</code></pre>
<h3 id="9-2-1-迭代器"><a href="#9-2-1-迭代器" class="headerlink" title="9.2.1 迭代器"></a>9.2.1 迭代器</h3><ul>
<li>标准库使用左闭合范围。</li>
</ul>
<pre><code>练习9.4
bool fine(vector&lt;int&gt;::iterator begin,vector&lt;int&gt;::iterator end,int value)
&#123;
    for(auto iter = begin;iter!=end,++iter)
    &#123;
        if(*iter==value)
            return true;
    &#125;
    return false;
&#125;
</code></pre>
<pre><code>练习9.5
vector&lt;int&gt;iterator fine(vector&lt;int&gt;::iterator begin,vector&lt;int&gt;::iterator end,int value)
&#123;
    for(auto iter = begin;iter!=end,++iter)
    &#123;
        if(*iter==value)
            return iter;
    &#125;
    return -1;
&#125;
</code></pre>
<h3 id="9-2-2-容器类型成员"><a href="#9-2-2-容器类型成员" class="headerlink" title="9.2.2 容器类型成员"></a>9.2.2 容器类型成员</h3><pre><code>练习9.7
使用迭代器类型索引元素
</code></pre>
<pre><code>练习9.8
读取string的list中的元素用 list&lt;string&gt;::value_type
为了写入数据，使用引用类型，list&lt;string&gt;::reference
</code></pre>
<h3 id="9-2-3-begin和end成员"><a href="#9-2-3-begin和end成员" class="headerlink" title="9.2.3 begin和end成员"></a>9.2.3 begin和end成员</h3><ul>
<li>不一c开头的being和end函数被重载过，当对一个非常量引用调用这些函数的时候，才会的到一个const版本。</li>
<li>当不需要写访问的时候，应该使用cbegin和cend</li>
</ul>
<pre><code>练习9.9
begin返回的迭代器是非常量迭代器或者常量迭代器，根据调用的变量决定，而cbegin返回的是const迭代器。
</code></pre>
<pre><code>练习9.10
it1 vector&lt;int&gt;::iterator
it2 vector&lt;int&gt;::const_iterator
it3 vector&lt;int&gt;::const_iterator
vector&lt;int&gt;::const_iterator
</code></pre>
<h3 id="9-2-4-容器的定义和初始化"><a href="#9-2-4-容器的定义和初始化" class="headerlink" title="9.2.4 容器的定义和初始化"></a>9.2.4 容器的定义和初始化</h3><ul>
<li>只有顺序容器的构造函数才接受大小参数(不包括array)<pre><code>C seq(n)
C seq(n,t)
</code></pre>
</li>
<li>将一个容器初始化为另一个容器的拷贝的时候，两个容器的容器类型和元素类型必须相同。</li>
<li>当用传递迭代器来拷贝的时候可以不同但是必须可以转化。</li>
<li>如果元素类型是内置类型或者是有默认构造参数的类类型，可以置位构造函数提供一个容器大小参数。如果元素类型没有默认构造函数，除了大小参数外，还需要一个显示的元素初始值。</li>
<li>标准库array的大小也是类型的一部分<pre><code>array&lt;int,42&gt; 
array&lt;string,10&gt;
</code></pre>
</li>
<li>虽然不能对内置数组进行拷贝和对象的赋值操作，但是array没有限制。</li>
</ul>
<pre><code>练习9.11
vector&lt;int&gt; v1;
vector&lt;int&gt; v2(v1);
vector&lt;int&gt; v3 = v2;
vector&lt;int&gt; v4&#123;1,2,3&#125;;
vector&lt;int&gt; v5= &#123;1,2,3&#125;;
vector&lt;int&gt; v6(v5.begin(),v5.end());
</code></pre>
<pre><code>练习9.9
接受一个容器的构造函数会拷贝次容器中的所有值。而接受迭代器可以只拷贝部分值
</code></pre>
<h3 id="9-2-5-赋值和swap"><a href="#9-2-5-赋值和swap" class="headerlink" title="9.2.5 赋值和swap"></a>9.2.5 赋值和swap</h3><ul>
<li>assign操作用参数所指定的元素(的拷贝)替换左边容器中的所有元素。如可以用assign实现一个vector中的一段char*赋值给list中的string。</li>
</ul>
<pre><code>seq.assign(b,e)             //迭代器
seq.assign(il)              将元素替换为初始化列表il中的元素
seq.assign(n,t)             //将元素替换为n个值为t的元素。
</code></pre>
<ul>
<li>swap两个容器只是交换了两个容器的内部数据结构，但是array是交换了元素。</li>
</ul>
<pre><code>练习9.14
list&lt;char *&gt; lc;
vector&lt;string&gt; vs;
vs.assign(lc.begin(),lc.end());
</code></pre>
<h3 id="9-2-6-容器大小操作"><a href="#9-2-6-容器大小操作" class="headerlink" title="9.2.6 容器大小操作"></a>9.2.6 容器大小操作</h3><ul>
<li>size,emtpy,max_size</li>
</ul>
<h3 id="9-2-7-关系运算符"><a href="#9-2-7-关系运算符" class="headerlink" title="9.2.7 关系运算符"></a>9.2.7 关系运算符</h3><ul>
<li>关系运算的前提是两个容器类型必须相同，元素类型也要相同，其次是容器要支持该运算符的操作。</li>
</ul>
<h2 id="9-3-顺序容器操作"><a href="#9-3-顺序容器操作" class="headerlink" title="9.3 顺序容器操作"></a>9.3 顺序容器操作</h2><h3 id="9-3-1-向顺序容器中添加元素"><a href="#9-3-1-向顺序容器中添加元素" class="headerlink" title="9.3.1 向顺序容器中添加元素"></a>9.3.1 向顺序容器中添加元素</h3><pre><code>array不能改变容器的大小，所以不支持这些操作
forward_list有自己版本的insert和emplace
forward_list不支持push_back和emplace_back
vector和string不支持push_front和mepalce_front

c.push_back(t)                      //
c.empalce_back(args)                //这个元素原地构造，不需要触发拷贝构造和转移构造
c.push_front(t)     
c.emplace_front(args)
c.insert(p,t)                       //在p迭代器前插入t元素
c.emplace(p,args)                   
c.insert(p,n,t)                     //在p之前插入n个t元素
c.insert(p,b,e)                     //p之前插入b和e级之间的元素
c.insert(p,il)                      //il是元素值列表，插入在p之前
</code></pre>
<ul>
<li>当我们使用一个对象初始化容器的时候，实际上放到容器中的是对象值的一个拷贝。</li>
<li>当我们传递给insert一对迭代器的时候，不能指向添加元素的目标元素。</li>
<li>emplace成员使用这些参数会在容器管理的内存空间中直接构造元素，根据元素的类型。而没有拷贝的操作。</li>
</ul>
<pre><code>练习9.18
int main()
&#123;
    string str;
    deque&lt;string&gt; ds;
    while(cin&gt;&gt;str)
    &#123;   
        ds.push_back(str);
    &#125;
    for(auto iter = ds.begin();iter!=ds.end();++iter)
    &#123;
        cout&lt;&lt;*iter&lt;&lt;endl;
    &#125;
&#125;
</code></pre>
<pre><code>练习9.20
int main()
&#123;
    list&lt;int&gt; li&#123;1,2,3,4,5,6,7,8&#125;;
    deque&lt;int&gt; di1,di2;
    for(auto iter = li.begin();iter!=li.end();++iter)
    &#123;
        if(*iter%2==0)
             di1.push_back(*iter);
        else
            di2.push_back(*iter);
    &#125;
&#125;
</code></pre>
<h3 id="9-3-2-访问元素"><a href="#9-3-2-访问元素" class="headerlink" title="9.3.2 访问元素"></a>9.3.2 访问元素</h3><pre><code>c.back()                //返回c中尾元素引用
c.front()
c[n]                    //返回下标为n的元素引用     vector,string,deque,array
c.at(n)                 //返回下标为n的引用，如果越界，抛出异常。
</code></pre>
<h3 id="9-3-3-删除元素"><a href="#9-3-3-删除元素" class="headerlink" title="9.3.3 删除元素"></a>9.3.3 删除元素</h3><pre><code>c.pop_back()            //删除尾元素，如果没有未定义
c.pop_front()           //
c.earse(p)
c.earse(b,e)
c.clear()
</code></pre>
<h3 id="9-3-4-特殊的forward-list操作"><a href="#9-3-4-特殊的forward-list操作" class="headerlink" title="9.3.4 特殊的forward_list操作"></a>9.3.4 特殊的forward_list操作</h3><pre><code>forward_list中插入和删除元素的操作
lst.before_begin()                  //返回指向链表首元素之前不存在的元素的迭代器，此迭代器不能解引用。
lst.cbefore_begin()
lst.insert_after(p,t)               //在迭代器p之后的位置插入元素，t是一个对象，n是数量
lst.insert_after(p,n,t)
lst.insert_after(p,b,e)
lst.insert_after(p,il)

empalce_after(p,args)
lst.erase_after(p)                  //删除p指向位置之后的元素。或删除从b只有到e之间的元素
lst.erase_after(b,e)
</code></pre>
<ul>
<li><p>使用forward_list的时候我们关注两个迭代器一个是指向我们要处理的元素，一个指向其前驱</p>
<pre><code>forward_list&lt;int&gt; flst = &#123;0,1,2,3,4,5,6,7,8,9&#125;;
auto prev = flst.before_begin();
auto curr = flst.begin();
while(curr!=flst.end())
&#123;
    if(*curr%2)
        curr = flst.erase_after(prev);
    else
    &#123;
        prev = curr;
        ++curr;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<pre><code>练习 9.27
int main()
&#123;
    forward_list&lt;int&gt; flst = &#123;0,1,2,3,4,5,6,7,8,9&#125;;
    auto prev = flst.before_begin();
    auto curr = flst.begin();
    while(curr!=flst.end())
    &#123;
        if(*curr%2==1)
            flst.erase_after(prev);
        else
        &#123;
            prev = curr;
            ++curr;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code>Exercises 9.28
void insert(forward_list&lt;string&gt; &amp;flst,const string &amp;s1,const string &amp;s2)
&#123;
    auto prev = flst.before_begin();
    bool isfind = false;
    auto curr = flst.begin();
    while(curr!=flst.end())
    &#123;
        if(*curr == s1)
            flst.insert_after(curr,s2);
            isfind = true;
            break;
        else
            prev = curr;
            ++curr;
    &#125;
    if(!isfind)
        flst.insert_after(prev,s2);
&#125;
</code></pre>
<h3 id="9-3-5-改变容器大小"><a href="#9-3-5-改变容器大小" class="headerlink" title="9.3.5 改变容器大小"></a>9.3.5 改变容器大小</h3><ul>
<li>可以使用resize改变容器的大小，array不支持，如果当前大小大于所要求的大小，容器后面的元素会被删除，如果小于要求的大小，会添加元素到容器后部。<pre><code>c.resize(n)
c.resize(n,t)
如果resize缩小融侨i，迭代器、引用和指针都失效
</code></pre>
</li>
</ul>
<pre><code>exercises 9.29
将vec的元素增加到100，而且后面的元素默认为0，vec.resize(10)会将容器的元素减少到10个。
</code></pre>
<pre><code>exercises 9.30
要去元素必须是内置类型，或者是有默认构造函数的类类型
</code></pre>
<h3 id="9-3-6-容器操纵可能使迭代器失效"><a href="#9-3-6-容器操纵可能使迭代器失效" class="headerlink" title="9.3.6 容器操纵可能使迭代器失效"></a>9.3.6 容器操纵可能使迭代器失效</h3><ul>
<li>向容器中添加元素或者从容器中删除元素可能会使得指向容器元素的指针、引用或迭代器失效。</li>
<li>我们在调用insert和erase后都会更新迭代器，在嗲用erase后不用递增迭代器，因为eraase返回的的迭代器已经指向序列中下一个元素，而调用insert会返回新插入元素的迭代器，而且insert操作是在迭代器之前插入元素。</li>
<li>必须在每次插入操作后重新调用end()，而不能再循环开始之前保存他的迭代器。</li>
</ul>
<pre><code>exercises 9.31
list和forwoard_list不知道支持加减操作，所以只能多次调用++操作。
</code></pre>
<h2 id="9-4-vector对象是如何增长的"><a href="#9-4-vector对象是如何增长的" class="headerlink" title="9.4 vector对象是如何增长的"></a>9.4 vector对象是如何增长的</h2><pre><code>only adapt to vector,string,deque
c.shrint_to_fit()           //将capacity减小为size同样大小
c.capacity()                //不重新分配空间的话，c可以保存多少元素
c.reserve(n)                //分配至少能容纳n个元素的内存空间
</code></pre>
<pre><code>exercises 9.35
capacity是容器内存的大小，是当前容器在不改变内存的情况下最大可以容纳的元素的大小
size是当前容器中的元素个数
</code></pre>
<pre><code>exercises 9.36
不可能
</code></pre>
<pre><code>exercises 9.37
list不需要一个连续的内存空间，array的内存空间是固定的
</code></pre>
<pre><code>exercises 9.38 
vector成倍的增长的
</code></pre>
<pre><code>exercises 9.40
256 384 1024
512 768 1024
1000 1500 3000
1048 1572   1572*2
</code></pre>
<h2 id="9-5-额外的string操作"><a href="#9-5-额外的string操作" class="headerlink" title="9.5 额外的string操作"></a>9.5 额外的string操作</h2><h3 id="9-5-1-构造string的其他方法"><a href="#9-5-1-构造string的其他方法" class="headerlink" title="9.5.1 构造string的其他方法"></a>9.5.1 构造string的其他方法</h3><pre><code>string s(cp,n)                  //s是cp指向数组中的前n个字符的拷贝
string s(s2,pos2)               //s是string s2从下标pos2开始的字符的拷贝
string s(s2,pos2,len2)
s.substr(pos,n)                 //返回一个string，包含s从pos开始的n个字符的拷贝
</code></pre>
<h3 id="9-5-2-改变string的其他方法"><a href="#9-5-2-改变string的其他方法" class="headerlink" title="9.5.2 改变string的其他方法"></a>9.5.2 改变string的其他方法</h3><pre><code>s.insert(pos,args)              //在pos之前插入args指定的字符，pso可以一个下标或者迭代器，接受下标的返回引用，接受迭代器返回迭代器
s.erase(pos,len)                //删除pos开始的len个字符
s.assign(args)                  //将s中的字符替换为args字符
s.append(args)                  //将args追加到s
s.replace(range,args)           //删除s中范围range内的字符，range可以是一个下标和一个长度，或者一对迭代器。

args可以的形式是一下之一：append和assing可以使用所有形式
str不能和s相同。迭代器b和e不能指向s
str
str,pos,len
cp,len
cp
n,c                             //n个字符c
b,e
初始化列表

replace和insert所允许的args依赖于range和pos是怎么定义的
</code></pre>
<pre><code>exercises 9.43
void changeString(string &amp;s,const string &amp;oldVal,const string &amp;newVal)
&#123;
    for(auto cur = s.begin();cur&lt;=s.end()-oldVal.size();)
    &#123;
        if(oldVal == string&#123;cur,cur+oldVal.size()&#125;)
        &#123;
            cur = s.earse(cur,cur+oldVal.size();
            cur = s.insert(cur,newVal.begin(),newVal.end());
            cur += newVal.size();
        &#125;
        else
        &#123;
            ++cur;    
        &#125;
    &#125;       
&#125;
</code></pre>
<pre><code>exercises 9.44
void changeString(string &amp;s,const string &amp;oldVal,const string &amp;newVal)
&#123;
    for(auto cur = s.begin();cur&lt;=s.end()-oldVal.size();)
    &#123;
        if(oldVal == string&#123;cur,cur+oldVal.size()&#125;)
        &#123;
            cur = cur.replace(cur,oldVal.size(),newVal);
            cur += newValue.size();
        &#125;
        else
        &#123;
            ++cur;    
        &#125;
    &#125;       
&#125;
</code></pre>
<pre><code>exercises 9.45
auto add_pre_and_suffix(string &amp;name,const string &amp;pre,const string &amp;su)
&#123;
    name.insert(name.begin(),pre.cbegin(),pre.cend());
    return name.append(su);
&#125;
</code></pre>
<pre><code>exercises 9.45
auto add_pre_and_suffix(string &amp;name,const string &amp;pre,const string &amp;su)
&#123;
    name.insert(0,pre);
    name.insert(name.size(),su);
    return name;
&#125;
</code></pre>
<h3 id="9-5-3-string搜索操作"><a href="#9-5-3-string搜索操作" class="headerlink" title="9.5.3 string搜索操作"></a>9.5.3 string搜索操作</h3><ul>
<li>string搜索函数返回string::size_type值，表示匹配位置的下标，如果搜索失败返回一个string::npos的static成员，这个值初始化为1，所以代表了任意string最大可能的大小。</li>
</ul>
<pre><code>s.find(args)                //查找s中args第一次出现的位置
s.rfind(args)               //查找s中args最后一次出现位置
s.find_first_of(args)       //在s中查找ats中任意一个字符第一次出现位置
s.find_last_of(args)        //最后一次出现位置
s.find_first_not_of(args)   //在s中查找第一个不在args中的字符
s.find_last_not_of(args)    //在s中查找最后一个不在args的字符

args形式
c,pos               //从位置pos查找c
s2,pos              //从位置pos查找字符串s2
cp,pos              //从位置pos查找c风格字符串
cp,pos,n            //从位置pos查找cp前n个字符
</code></pre>
<pre><code>exercise 9.47
string number&#123;&quot;1234567689&quot;&#125;;
string alphabet&#123;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#125;;
string str&#123;&quot;ad2c3d7R4E6&quot;&#125;;
for(int pos = 0;(pos = str.find_first_of(number,pos))!=string::npos;++pos)
&#123;
    cout&lt;&lt;str[pos]&lt;&lt;&quot; &quot;;
&#125;
cout&lt;&lt;endl;
for(int pos = 0;(pos = str.find_first_of(alphabet,pos))!=string::npos;++pos)
&#123;
    cout&lt;&lt;str[pos]&lt;&lt;&quot; &quot;;
&#125;

for(int pos = 0;(pos = str.find_first_not_of(alphabet,pos))!=string::npos;++pos)
&#123;
    cout&lt;&lt;str[pos]&lt;&lt;&quot; &quot;;
&#125;

for(int pos = 0;(pos = str.find_first_not_of(number,pos))!=string::npos;++pos)
&#123;
    cout&lt;&lt;str[pos]&lt;&lt;&quot; &quot;;
&#125;
</code></pre>
<pre><code>exercises 9.48 
string::npos
</code></pre>
<h3 id="9-5-4-compare函数"><a href="#9-5-4-compare函数" class="headerlink" title="9.5.4 compare函数"></a>9.5.4 compare函数</h3><ul>
<li>compare有6个版本。compare用于字符串比较操作，类似于c标准库的strcmp函数。</li>
</ul>
<h3 id="9-5-5-数值转化"><a href="#9-5-5-数值转化" class="headerlink" title="9.5.5 数值转化"></a>9.5.5 数值转化</h3><pre><code>to_string(val)          //返回数值val的string表示
stoi(s,p,b)             //返回s的起始子串的数值，b是转换所用的基数默认为10，p是size_t指针，，默认为0
stol(s,p,b)
stoul(s,p,b)
stoll(s,p,b)
stoull(s,p,b)
stof(s,p)
stod(s,p)
stdld(s,p)
</code></pre>
<pre><code>exercise 9.50
int main()
&#123;
    int sum;
    vector&lt;string&gt; vs&#123;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;&#125;;
    for(auto &amp;temp:vs)
        sum+= stoi(temp);
    cout&lt;&lt;sum&lt;&lt;endl;
&#125;
</code></pre>
<pre><code>exercise 9.51
class Data
&#123;
private:
    unsinged year,month,day;
public:
    Data(const string &amp;s);
&#125;;

Data::Data(const string &amp;s)
&#123;
    unsigned tag;
    unsigned format;
    format = tag = 0;
    
    if(s.find_first_of(&quot;/&quot;!=string::npos)
        format = ox01;
    
    if(s.find_first_of(&#39;,&#39;)&gt;=4&amp;&amp;s.find_first_of(&#39;,&#39;)!=string::npos)&#123;
        format = ox10;
    &#125;else&#123;
        if(s.find_first_of(&#39; &#39;)&gt;=3&amp;&amp;s.find_first_of(&#39; &#39;)!=string::npos
        &#123;
            format = ox10;
            tag = 1;
        &#125;
    &#125;
    
    switch(format)
    &#123;
        case 0x01:
            day = stoi(s.substr(0,s.find_first_of(&quot;/&quot;));
            month = stoi(s.substr(s.find_first_of(&quot;/&quot;)+1,s.find_last_of(&quot;/&quot;)-s.find_first_of(&quot;/&quot;));
            year = stoi(s.substr(s.find_last_of(&quot;/&quot;)+1,4));
            break;
        case 0x10:
            if( s.find(&quot;Jan&quot;) &lt; s.size() )  month = 1;
            if( s.find(&quot;Feb&quot;) &lt; s.size() )  month = 2;
            if( s.find(&quot;Mar&quot;) &lt; s.size() )  month = 3;
            if( s.find(&quot;Apr&quot;) &lt; s.size() )  month = 4;
            if( s.find(&quot;May&quot;) &lt; s.size() )  month = 5;
            if( s.find(&quot;Jun&quot;) &lt; s.size() )  month = 6;
            if( s.find(&quot;Jul&quot;) &lt; s.size() )  month = 7;
            if( s.find(&quot;Aug&quot;) &lt; s.size() )  month = 8;
            if( s.find(&quot;Sep&quot;) &lt; s.size() )  month = 9;
            if( s.find(&quot;Oct&quot;) &lt; s.size() )  month =10;
            if( s.find(&quot;Nov&quot;) &lt; s.size() )  month =11;
            if( s.find(&quot;Dec&quot;) &lt; s.size() )  month =12;
            
            char ch = &quot;,&quot;;
            if(tag==1)
            &#123;
                ch = &quot; &quot;;
            &#125;
            day = stoi(s.substr(s.find_first_of(&quot;123456789&quot;),s.find_first_of(ch)-s.find_first_of(&quot;123456789&quot;));
            year = stoi(s.substr(s.findfirst_of(ch)+1,4);
            break;
    &#125;
&#125;
</code></pre>
<h2 id="9-6-容器适配器"><a href="#9-6-容器适配器" class="headerlink" title="9.6 容器适配器"></a>9.6 容器适配器</h2><ul>
<li><p>除了顺序容器外，标准库还定义了三种容易适配器：stack、queue和priority_queue。</p>
</li>
<li><p>容器迭代器和函数都有适配器，适配器接受一种已有的类型，是他的行为看起来像另外一种类型。</p>
</li>
<li><p>默认情况下stack和queue是基于deque实现的，priority_queue是基于vector实现的。可以在创建容器的手将一个命的顺序容器作为第二个采参数，来重载默认容器类型。</p>
</li>
<li><p>栈适配器定义在头文件stack中，基本操作如下：</p>
<pre><code>s.pop()                 //删除栈顶元素，但不返回该元素值
s.push(item)            //创建一个新的元素加入栈顶
s.emplace(args)
s.top()                 //returns,but does not remove,the top element on the stack
</code></pre>
<pre><code>queue can use a list or vector as well ,priority_queue can use a deque
q.pop() removes,but dose not return 
q.front() return but does not remove
q.back() vialid only for queue
q.top() return ,but does not remove,valiad onlu for priority_queue
q.push(item)        //create an element with value item or constructed fromn args at the end of queue or int its appropriate position in priority_queue.
q.emplace(args)
</code></pre>
</li>
<li><p>priority_queue允许我们为队列中的袁术那建立优先级，新加入的元素会排在所有优先级比他低的元素前面。</p>
</li>
</ul>
<pre><code>exercise 9.52 
int main()
&#123;
    string expression&#123;&quot;thi is (pezy).&quot;&#125;;
    bool bSeen = false;
    stack&lt;char&gt; stk;
    for(const auto &amp;s:expression)
    &#123;
        if(s==&#39;(&#39;)&#123;bSeen = true;continue;&#125;
        else if(s==&#39;)&#39;) bSeen = false;
        if(bSeen) stk.push(s);
    &#125;
&#125;
</code></pre>
<h1 id="第10章-泛型算法"><a href="#第10章-泛型算法" class="headerlink" title="第10章 泛型算法"></a>第10章 泛型算法</h1><h2 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h2><ul>
<li>一般算法并不直接操作容器，而是遍历两个迭代器指定范围进行操作。</li>
<li>迭代器参数令算法不依赖特定容器，但是依赖于元素类型操作。</li>
<li>泛型算法本身不会执行容器的操作，算法永远不会改变底层容器的大小。算法可能改变容器保存元素的值，但是不会直接添加或者删除元素。</li>
</ul>
<pre><code>exercise 1
int mian()
&#123;
    std::vecotr&lt;int&gt; v = &#123;1,2,3,4,5,6,7,8,9&#125;;
    cout&lt;&lt;std::count(v.cbegin(),v.cend(),2)&lt;&lt;endl;
    list&lt;string&gt; l = &#123;&quot;aa&quot;,&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;&#125;;
    count(l.cbegin(),l.cend(),&quot;aa&quot;);
&#125;
</code></pre>
<h2 id="10-2-初识泛型算法"><a href="#10-2-初识泛型算法" class="headerlink" title="10.2 初识泛型算法"></a>10.2 初识泛型算法</h2><h3 id="10-2-1-只读算法"><a href="#10-2-1-只读算法" class="headerlink" title="10.2.1 只读算法"></a>10.2.1 只读算法</h3><pre><code>find()          
count()
accumulate()        //计算一个序列的和，第三个参数是和的初值(决定加法运算类型和返回值类型)
equal()             //确定连个序列是否相同，只接受单一迭代器表示第二个操作序列的算法假定第二个序列至少和以第一个序列一样长。
</code></pre>
<pre><code>exercise 3
int  main()
&#123;
    vector&lt;int&gt; v(10,1);
    int sum ;
    sum = accumulate(v.cbegin(),c.cend(),0);
&#125;
</code></pre>
<pre><code>exercise 5
for such case ,std::equal is going to compare the adderess value than the string value ,so the result
is not same as std::string .
</code></pre>
<h3 id="10-2-2-写容器元素的算法"><a href="#10-2-2-写容器元素的算法" class="headerlink" title="10.2.2 写容器元素的算法"></a>10.2.2 写容器元素的算法</h3><ul>
<li>一个写入操作需要保证容器的大小大于要写入元素的大小。</li>
<li>fill函数接受两个迭代器表示序列范围，还接受一个值作为第三个参数，将给定范围内的每个值赋值<pre><code>//rest each element to 0
fill(vec.begin(),vec.end(),0);
</code></pre>
</li>
<li>fill_n函数接受单个迭代器参数一个计数值和一个值，将给定值赋予迭代器指定位置开始的指定个元素<pre><code>//reset all the element of vec to 0
fill_n(vec.begin(),vec.size(),0)
</code></pre>
</li>
<li>插入迭代器是一种向容器中添加元素的迭代器。插入迭代器接受一个指向容器的引用，返回与该容器绑定的插入迭代器，通过迭代器赋值，将元素添加到容器中。<pre><code>vector&lt;int&gt; vec;
auto it = back_intserter(vec);
*it = 42;
fill_n(back_inserter(vec),10,0);
</code></pre>
</li>
<li>copy函数接受三个迭代器参数，1,2指定输入序列，3指定目标序列的起始位置，返回目标位置迭代器递增后的位置。<pre><code>int a1[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;
int a2[sizeof(a1)/sizeof(*a1)];
auto ret = copy(begin(a1),end(a1),a2);
</code></pre>
</li>
<li>replace 读入一个序列将，所有的给定元素改为另一值。<pre><code>//将所有0改为42
repalce(ilst.begin().ilst.end(),0,42)
replace_copy(ilst.begin(),ilst.end(),back_inserter(ivec),0,42);
//不改变ilst，ivec包含ilst的一份拷贝。
</code></pre>
</li>
</ul>
<pre><code>exercise 6
vector&lt;int&gt; vec&#123;1,2,3&#125;;
fill_n(vec.begin(),vec.end(),0);
</code></pre>
<pre><code>exercise 7
(a) flase
copy(lst.cbegin(),lst.cend(),back_inserter(vec));
</code></pre>
<pre><code>exercise 8
inserter like back_inserters is part of &lt;iterator&gt; rathon than &lt;algorithm&gt;
</code></pre>
<h3 id="10-2-3-重排容器元素算法"><a href="#10-2-3-重排容器元素算法" class="headerlink" title="10.2.3 重排容器元素算法"></a>10.2.3 重排容器元素算法</h3><ul>
<li>sort() 算法接受两个迭代器表示要排序的元素范围。</li>
<li>unique() 返回迭代器指向最后一个不重复元素之后的位置。</li>
</ul>
<pre><code>exercise 9
void elimDumps(vector&lt;string&gt; &amp;vs)
&#123;
    sort(vs.cbegin(),vs.cend());
    for(auto const &amp;temp:vs)
        cout&lt;&lt;temp;
    cout&lt;&lt;endl;
    auto iter = unique(vs.cbegin(),vs.cend());
    vs.erase(iter,vs.end());
&#125;
</code></pre>
<pre><code>exercise 10
cause the library algorithm operator on iterator,not contains,thus,an algorithm cannot add or remove element
</code></pre>
<h2 id="10-3-定制操作"><a href="#10-3-定制操作" class="headerlink" title="10.3 定制操作"></a>10.3 定制操作</h2><h3 id="10-3-1-向算法传递函数"><a href="#10-3-1-向算法传递函数" class="headerlink" title="10.3.1 向算法传递函数"></a>10.3.1 向算法传递函数</h3><ul>
<li>谓词是一个可以调用的表达式，其返回结果是一个能用作条件的值。</li>
<li>谓词可以是一元谓词或者二元谓词，sort接受的是二元谓词<pre><code>bool isShorter(const string &amp;s1,const string &amp;s2)
&#123;
    return s1.size()&lt;s2.size();
&#125;
sort(words.begin(),words.end().isShorter);
</code></pre>
</li>
<li>stable_sort可以维持输入序列中相等元素的原有位置。</li>
</ul>
<pre><code>exercise 12 
inline bool compareIsbn(const Sales_data &amp;sdl,const Sales_data &amp;sdl2)
&#123;
    return sdl.isbn().size()&lt;sdl2.isbn().size();
&#125;
int mian()
&#123;
    std::sort(v.begin(),v.end(),compareIsbn);
&#125;
</code></pre>
<pre><code>inline bool ismaxfive(const string&amp; str)
&#123;
    return str.size()&gt;=5;
&#125;

int main()
&#123;
    vector&lt;string&gt; vs = &#123;&quot;adfsad&quot;,&quot;fafdsaf&quot;,&quot;fdsf&quot;&#125;;
    auto iter = paretition(vs.begin(),vs.end(),ismaxfive);
    for(auto iter1 = vs.begin();iter1!=iter;++iter1)
        cout&lt;&lt;*iter1&lt;&lt;endl;
&#125;
</code></pre>
<h3 id="10-3-2-lambda表达式"><a href="#10-3-2-lambda表达式" class="headerlink" title="10.3.2 lambda表达式"></a>10.3.2 lambda表达式</h3><ul>
<li>对于一个对象或者表达式，可以对其使用(),则称它为可调用对象。可以向算法传递任何类别的可调用对象。</li>
<li>一个lambda表达式表示一个可调用代码单元，类似未命名的内联函数，但可以定义在函数内部。<pre><code>[capture list] (parameter list) -&gt; return type&#123;function body&#125;
capture list是一个lambda所在函数中定义的局部变量的列表。通常为空
其他和普通函数一样。
我们可以忽略参数列表和返回值。但是必须包含捕获列表和函数体。
</code></pre>
</li>
<li>lambda可以使用其所在函数的局部变量，但必须先将其包含在捕获列表中，捕获列表只能用于局部非static变量。lambda可以直接使用局部static变量和所在函数之外声明的名字<pre><code>//获取一个迭代器，指向第一个满足size()&gt;sz的元素。
auto wc = find_if(words.begin(),words.end(),
                    [sz](const string &amp;a)&#123;return a.size()&gt;=sz;&#125;);
</code></pre>
</li>
<li>for_eack函数接受一个输入序列和一个可调用对象，他对输入序列的每一个元素调用次对象。<pre><code>for_each(wc,words.end(),
            [](const string &amp;s)&#123;cout&lt;&lt;s&lt;&lt;&quot; &quot;;&#125;);
</code></pre>
</li>
</ul>
<pre><code>exercise 14
[](int a,int b)&#123;return a+b;&#125;
int main()
&#123;
    int a = 2;
    [a](int b)&#123;return a+b;&#125;
&#125;
</code></pre>
<pre><code>exercise 15
std::sort(v.begin(),v.end(),
            [](const string &amp;str,const string &amp; str2)&#123;return str.size()&lt;str2.size();&#125;);
</code></pre>
<h3 id="10-3-3-lambda捕获和返回"><a href="#10-3-3-lambda捕获和返回" class="headerlink" title="10.3.3 lambda捕获和返回"></a>10.3.3 lambda捕获和返回</h3><ul>
<li>当向一个函数传递一个lambda的时候，同时定义了一个新类型和该类型的一个对象。传递的参数就是该编译器生成类类型的未命名对象。</li>
<li>别lambda捕获的变量值是在lambda创建时拷贝，而不是在调用的时候拷贝<pre><code>size_t v1 = 42;
auto f = [v1] &#123;return v1;&#125;;
v1 = 0;
auto j = f();       //j为42，f保存了我们创建v1时的拷贝。
</code></pre>
</li>
<li>lambda可以以引用的形式捕获变量，但是必须抱枕lambda执行时变量存在。</li>
<li>可以让编译器根据lambda隐式捕获函数变量。方法是在捕获列表中写一个&amp;或者&#x3D;符号。</li>
<li>可以混用显示和隐式捕获。显示捕获的变量使用和隐式捕获不同的方式。<pre><code>[&amp;,inenfitier_list]后面的变量采用显示值捕获
[=,identifier_list]identifier_list中的变量采用显示的引用捕获，其他采用隐式值捕获。
</code></pre>
</li>
<li>默认情况下，对值捕获方式变量，lambda不能修改器值，如果希望修改，在参数列表后加mutable<pre><code>size_t v1 = 42;
auto f = [v1] () mutawble&#123;return ++v1;&#125;;
v1 = 0;
auto j = f();           //j = 42;
</code></pre>
</li>
<li>transform函数接受三个迭代器参数和一个可调用对象，前两个迭代器指定输入序列，第三个迭代器表示目的位置。对输入序列中的没个对象调用可调用对象，将写入到目的位置。<pre><code>transform(vi.begin(),vi.end(),vi.begin(),
            [](int i)-&gt;int&#123;if(i&lt;0)return -1;else return i;&#125;);
</code></pre>
</li>
</ul>
<pre><code>exercise 20
int num = count_if(vec.begin(),vec.end(),
                        [](const string &amp;s)&#123;return s.size()&gt;6&#125;);
</code></pre>
<pre><code>int mian()
&#123;
    int a  = 10;
    [&amp;a]()&#123;return i&gt;0?!--i:!i;&#125;;
&#125;
</code></pre>
<h3 id="10-3-4-参数绑定"><a href="#10-3-4-参数绑定" class="headerlink" title="10.3.4 参数绑定"></a>10.3.4 参数绑定</h3><ul>
<li>**问题提出:**为了解决用函数调用的时候如果只接受一个谓词，不能像形参传递一个参数的问题。<pre><code>bool check_size(const string &amp;s,string::size_type sz)
&#123;
    return s.size() &gt;= sz;
&#125;

不能将这个函数作为find_if的一个参数。因为find_if只接受一个一元谓词。
</code></pre>
</li>
<li>**解决方法:**使用一个新的名为bind的标准库函数，定义在functional中，bind是一个函数适配器，接受一个可调用对象，生成一个新的可调用对象适应元对象的参数列表。<pre><code>auto newCallable = bind(callable,arg_list);

//check6是一个可调用对象，接受一个string类型参数，并用次string和6来调用check_size
auto check6 = bind(check_size,_1,6);
//bind 调用只接受一个占位符，表示check6值接受一个参数，如果调用check6需要传入一个参数const string&amp;，然后改参数会传给check_size
auto wc = find_if(words.begin(),word.end()
                    bind(check_size,_1,sz));
</code></pre>
</li>
<li>名字_n定义在一个名为placeholders的命名空间中，该空间位域std中。</li>
<li>bind函数可以调整给定可调用对象的参数顺序。<pre><code>auto g = bind(f,a,b,_2,c,_1);
g(X,Y);
映射为
f(a,b,Y,c,X);
</code></pre>
</li>
<li>默认情况下bind函数的非占位元素被拷贝到bind返回的可调用对象中。</li>
<li>如果希望传递给bind一个对象而不拷贝他，必须使用标准库的ref()函数，该函数返回一个对象，包含给定的引用。cref()返回的是const引用类。</li>
</ul>
<pre><code>exercise 22
bool isLesserRoEqualTo6(const string &amp;s,int num)
&#123;
    return s.size()&lt;=num;
&#125;

int mian()
&#123;
    vector&lt;string&gt; vs;
    count_if(vs.begin(),vs.end()
                bind(isLessRoEqualTo6,_1,6);
&#125;
</code></pre>
<pre><code>exercise 23
assuming the function to be bound have n parameters,bind take n+1 parameters.the additional one 
is for the function to be bound itself.
</code></pre>
<h2 id="10-4-再探迭代器"><a href="#10-4-再探迭代器" class="headerlink" title="10.4 再探迭代器"></a>10.4 再探迭代器</h2><h3 id="10-4-1-插入迭代器"><a href="#10-4-1-插入迭代器" class="headerlink" title="10.4.1 插入迭代器"></a>10.4.1 插入迭代器</h3><ul>
<li>插入迭代器是一种迭代器适配器。接受一个容器生成一个迭代器，能向给定容器添加元素。</li>
<li>插入迭代器类型(差异在于元素插入位置)<ul>
<li>back_inserter :创建一个使用push_back的迭代器</li>
<li>front_inserter:创建一个使用push_front的迭代器</li>
<li>inserter：创建一个使用insert的迭代器，该函数第二个参数，该参数是一个指向给定容器的迭代器，插入到元素之前。</li>
</ul>
</li>
<li>使用inserter插入器迭代器的位置一直都没有变，所有是1234。</li>
</ul>
<pre><code>exercise 10.26
 back_insert use push_back
 front_inserter use push_front
 inserter uses insert
</code></pre>
<pre><code>exercise 10.27
int main()
&#123;
    vector&lt;int&gt; vec &#123;1,2,3,4,5,6,7,8,4,3&#125;;
    list&lt;int&gt; li;
    unique_copy(vec.begin(),vec.end(),back_inserter(li));
&#125;
</code></pre>
<pre><code>exercise 10.28
int main()
&#123;
    vector&lt;int&gt; vec&#123;1,2,3,4,5,6,7,8,9&#125;;
    vector&lt;int&gt; vec1,vec2,vec3;
    copy(vec.begin(),vec.end(),back_inserter(vec1));    //123456789
    copy(vec.begin(),vec.end(),front_inserter(vec1));   //987654321
    copy(vec.begin(),vec.end(),inserter(vec1,vec1.begin()));    //123456789
&#125;
</code></pre>
<h3 id="10-4-2-iostream-迭代器"><a href="#10-4-2-iostream-迭代器" class="headerlink" title="10.4.2 iostream 迭代器"></a>10.4.2 iostream 迭代器</h3><ul>
<li>istream_iterator从输入流读取数据，ostream_iterator向输出流写入数据。这些迭代器将流当做特定类型的元素数列理解。</li>
<li>创建一个流迭代器，必须制定迭代器将要读写的对象类型。如果默认初始化，创建的是尾后迭代器<pre><code>istrem_iterator&lt;int&gt; int_it(cin);           //从cin读取int
istream_iterator&lt;int&gt; int_eof;              //尾后迭代器
ifstream in(&quot;afile&quot;);
istream_iterator&lt;string&gt; str_it(in);        //从afile读取字符串
</code></pre>
<pre><code>//从标准输入读取数据存入vector
istream_iterator&lt;int&gt; int_it(cin);
istream_iterator&lt;int&gt; int_eof;
while(int_it!=int_eof)
&#123;
    vec.push_back(*in_it++);
&#125;
</code></pre>
</li>
<li>将一个istream_iterator绑定到一个流中，标准库不保证迭代器立即从流读取数据，但保证第一次解引用迭代器之前那个从流中读取数据的操作引进完成了。</li>
<li>定义ostream_iterator对象，必须将其绑定包一个指定是的输出流，不允许定义空的或表示尾后位置的ostream_iterator</li>
<li>*和++运算符实际不会对ostream_iterator对象做任何操作，但是建议代码写法和其他迭代器保持一致。</li>
<li>创建ostream_iterator可以提供第二个参数，表示每个元素输出都会打印该字符串。<pre><code>ostream_iterator&lt;int&gt; out_iter(cout,&quot; &quot;);
for(auto e:vec)
&#123;
    *out_iter++ = e;
    out_iter = e;//也可以这样写
&#125;
cout&lt;&lt;endl;
</code></pre>
</li>
</ul>
<pre><code>exercise 29
int main()
&#123;
    vector&lt;string&gt; vec;
    ifstream file(&quot;data&quot;);
    istream_iterator&lt;string&gt; str_in(file);
    istream_iterator&lt;string&gt; str_eof;
    while(str_in!=str_eof)
    &#123;
        vec.push(*str_in++);
    &#125;
    
    std::copy(str_in,str_eof,back_inserter(vec));
    copy(vec.begin(),vec.end(),std::ostream_iterator&lt;string&gt;(std::cout,&quot;\n&quot;));
&#125;
</code></pre>
<pre><code>exiercise 30
int main()
&#123;
    vector&lt;int&gt; vec&#123;1,2,3,4,5,6,7,8,9&#125;;
    vector&lt;int&gt; vec(std::istream_iterator&lt;int&gt;(std::cin),std::istream_iterator&lt;int&gt;());
    sort(vec.begin(),vec.end());
    std::copy(vec.cbegin(),vec.cend(),std::ostream_iterator&lt;int&gt;(std::cout,&quot; &quot;));

&#125;
</code></pre>
<pre><code>exercise 33
void write(const string &amp;inputfile,const string &amp;outfile1,const string &amp;outfile2)
&#123;
    vector&lt;int&gt; vec(std::istream_iterator&lt;int&gt;(istream(inpufile)),std::istream_iterator&lt;int&gt;());
    ostream_iterator&lt;int&gt; out_odd(ostream(outfile1)),out_even(ostream(outfile2));
    for_each(vec.begin(),vec.end()
                [&amp;out_odd,&amp;out_even](const int i)&#123;*(i&amp;0x1?out_odd:out_even)++;&#125;;
&#125;
</code></pre>
<h3 id="10-4-3-反向迭代器"><a href="#10-4-3-反向迭代器" class="headerlink" title="10.4.3 反向迭代器"></a>10.4.3 反向迭代器</h3><ul>
<li>反向迭代器在容器中从尾元素反向移动迭代器。递增一个迭代器会移动到前一个元素。</li>
<li>调用反向迭代器的base函数可以获得其对应的普通迭代器。</li>
<li>反向迭代器表示的是元素的范围，而这些范围是不对称的，用普通迭代器初始化反向迭代器，结果迭代器与原来迭代器指向的不是相同的元素。</li>
</ul>
<pre><code>exercise 34-37
int main()
&#123;
    vector&lt;int&gt; vec&#123;2,3,1&#125;;
    
    //10.34
    for(auto it = vec.crbegin();it!=vec.crend();++it)
    &#123;
        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;
    &#125;
    cout&lt;&lt;endl;
    
    //10.35
    for(auto it = vec.cbegin(),it!=vec.end();++it)
        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;
    cout&lt;&lt;endl;
    
    //10.36
    list&lt;int&gt; li&#123;1,2,3,4,0,2,6,0,6&#125;;
    find(li.crbegin(),li.crend(),0);
    
&#125;
</code></pre>
<h2 id="10-5-泛型算法结构"><a href="#10-5-泛型算法结构" class="headerlink" title="10.5 泛型算法结构"></a>10.5 泛型算法结构</h2><pre><code>---------------迭代器类型--------------------
输入迭代器                  只读，不写；单遍扫描，只能递增
输出迭代器                  只写，不读；单遍扫描，只能递增
前向迭代器                  可读写；多遍扫描，只能递增
双向迭代器                  可读写；多遍扫描，递增递减
随机访问迭代器              可读写；多遍扫描，支持全面迭代器运算
</code></pre>
<h3 id="10-5-1-五类迭代器"><a href="#10-5-1-五类迭代器" class="headerlink" title="10.5.1 五类迭代器"></a>10.5.1 五类迭代器</h3><h3 id="10-5-2-算法形参模式"><a href="#10-5-2-算法形参模式" class="headerlink" title="10.5.2 算法形参模式"></a>10.5.2 算法形参模式</h3><ul>
<li>一般算法形式<pre><code>alg(beg,end,other args);
alg(beg,end，dest,other args)
alg(beg,end,beg2,other args)
alg(beg,end,beg2,end2,othe args)
</code></pre>
</li>
</ul>
<h3 id="10-5-3-算法命名规范"><a href="#10-5-3-算法命名规范" class="headerlink" title="10.5.3 算法命名规范"></a>10.5.3 算法命名规范</h3><ul>
<li>一些算法使用重载形式传递谓词<pre><code>unique(beg,end);    //使用==比较元素
unique(beg,end,comp)//使用comp比较元素
</code></pre>
</li>
<li>接受谓语参数的算法那都有_if后缀<pre><code>find(beg,end,val);          //查找范围内val第一次出现位置
find_if(beg,end,pred);      //查找第一个另pred为真的元
</code></pre>
</li>
<li>区分拷贝元素的版本和不拷贝元素的版本用_copy<pre><code>reveser(beg,end);
reveser_copy(beg,end,dest);     //将元按照逆序拷贝到dest
</code></pre>
</li>
</ul>
<pre><code>exercise 41
将beg-end中的元素替换为old_val-new_val中的元素
判断new_val是否符合pred条件符合替换范围内元素
copy the new_element which is old_elements in the input range into dest
copy the new_element which pred is true in the input range into dest
</code></pre>
<h3 id="10-6-特定容器算法"><a href="#10-6-特定容器算法" class="headerlink" title="10.6 特定容器算法"></a>10.6 特定容器算法</h3><ul>
<li>对list和forward_list，应该优先使用成员函数版本的算法，而不是通用算法。<pre><code>lst.merge(lst2)                 //将链表合并，但是都是必须排序过的
lst.merge(lst2,comp)

lst.remove(val)
lst.remove_if(pred)
lst.reverse()
lst.sort()
lst.sort(comp)
lst.unique()
lst.unique(pred)

lst.splice(args)                //将一个链表连接到另一个链表中
flst.splice_after(args)
</code></pre>
</li>
</ul>
<h1 id="第11章-关联容器"><a href="#第11章-关联容器" class="headerlink" title="第11章 关联容器"></a>第11章 关联容器</h1><ul>
<li>标准库提供8个关联容器，可以体现在三个维度上<ul>
<li>是一个set或者是一个map，map是关联数组：保存关键字-值对，set关键字即值，只保存关键字的容器</li>
<li>要求不重复的关键字，或者要求可重复的关键字，可重复的关键字都是multi。</li>
<li>按顺序保存，或者无顺序保存。无顺序保存的以unordered开头。</li>
</ul>
</li>
</ul>
<h2 id="11-1-使用关联容器"><a href="#11-1-使用关联容器" class="headerlink" title="11.1 使用关联容器"></a>11.1 使用关联容器</h2><ul>
<li>map类型通常被称为关联数组</li>
<li>从map中提取一个元素的时候回得到一个pair类型的对象。pair是一个模板类型。保存两个名为first和second的共有数据成员。map所使用的pair用first成员保存关键字。用second成员保存对应的值。<pre><code>map&lt;string,size_t&gt; word_count;
string word;
while(cin&gt;&gt;word)
&#123;
    ++word_count[word];
&#125;
for(const auto &amp; w:word_count)
    cout&lt;&lt;w.first&lt;&lt;&quot; &quot;&lt;&lt;w.second&lt;&lt;endl;
</code></pre>
</li>
<li>set类型的find成员返回一个迭代器，如果给定关键字在set中，迭代器指向该关键字，否则返回尾后迭代器。</li>
</ul>
<pre><code>exercise 11.1
map is associative container whereas vector is sequence container
</code></pre>
<pre><code>exercise 11.2 
any time when a doubly-linjked list is required.
vector:anytime when a dynamic array is required.
deque:application of the deque is storing a web broser&#39;s history
map:dictionary
set: when to keep element sorted and unique
</code></pre>
<h2 id="11-2-关联容器概述"><a href="#11-2-关联容器概述" class="headerlink" title="11.2 关联容器概述"></a>11.2 关联容器概述</h2><h3 id="11-2-1-定义关联容器"><a href="#11-2-1-定义关联容器" class="headerlink" title="11.2.1 定义关联容器"></a>11.2.1 定义关联容器</h3><ul>
<li>定义map时，必须指定关键字类型和值类型。定义set是纸需要指定关键字类型</li>
<li>初始化map，提供的每个键值对用{}包围<pre><code>map&lt;string,size_t&gt;word_coumnt;
set&lt;string&gt; exclude  = &#123;&quot;the&quot;,&quot;but&quot;,&quot;and&quot;&#125;;
map&lt;string,string&gt; authors =
&#123;
    &#123;&quot;a&quot;,&quot;1&quot;&#125;,
    &#123;&quot;b&quot;,&quot;2&quot;&#125;,
    &#123;&quot;c&quot;,&quot;3&quot;&#125;
&#125;;
</code></pre>
</li>
<li>map和set的关键字必须唯一，multimap和multiset没有这限制。</li>
</ul>
<pre><code>exercise 11.5 
set contain only the key,while in map there is an associated value.
</code></pre>
<pre><code>exercise 11.6
两者都可以保存元素集合，如果需要顺序访问这些元素，或者按照位置访问元素，可以使用list
如果需要快速判定是否有元素等于给定的值，用set比较好。
</code></pre>
<pre><code>exercise 11.7
map&lt;string,vector&lt;string&gt;&gt; family;
</code></pre>
<h3 id="11-2-2-关键字类型的要求"><a href="#11-2-2-关键字类型的要求" class="headerlink" title="11.2.2 关键字类型的要求"></a>11.2.2 关键字类型的要求</h3><ul>
<li>对于有序关联容器，关键字类型必须定义元素的比较方法。</li>
<li>用来组织容器元素的操作类型也是该容器类型的一部分，如果需要使用自定义的比较类型，则必须在定义关联容器类型是提供此操作的类型。操作类型在尖括号中跟着元素类型给出<pre><code>bool compareIsbn(const Sales_data &amp;lhs,const Sales_data &amp;rhs)
&#123;
    return lhs.isbn()&lt;rhs.isbn();
&#125;
multiset&lt;Sales_data,decltype(compareIsbn)*&gt; bookstore(compareIsbn);
</code></pre>
</li>
</ul>
<pre><code>exercise 9
map&lt;string,list&lt;size_t&gt;&gt; m;
</code></pre>
<pre><code>exercise 10
vector支持，因为vector支持&lt;操作
list不支持，list不支持&lt;操作
</code></pre>
<pre><code>typedef bool(*Less)(Sales_data const&amp;,Sales_data const &amp;);
std::multiset&lt;Sales_data,Less&gt; bookstore(less);
</code></pre>
<h3 id="11-2-3-pair类型"><a href="#11-2-3-pair类型" class="headerlink" title="11.2.3 pair类型"></a>11.2.3 pair类型</h3><ul>
<li>pair定义在utility中，一个pair可以保存两个数据成员，分别为first和second。pair的默认构造函数对数据成员进行值初始化。</li>
</ul>
<pre><code>--------------------------------pair上的操作----------------------------
pair&lt;T1,T2&gt; p;
pair&lt;T1,T2&gt; p(v1,v2);
pair&lt;T1,T2&gt; p = &#123;v1,v2&#125;;
make_pair(v1,v2);               //返回一个用v1和v2初始化的pair
p.first
p.second
p1 relop p2                     //按字典排序关系运算符
p1  == p2
p1!=p2
</code></pre>
<pre><code>exercise 11.12
int main()
&#123;
    string str;
    int i;
    vector&lt;pair&lt;string,int&gt;&gt; vec;
    while(cin&gt;&gt;str,cin&gt;&gt;i)
    &#123;
        pair&lt;string,int&gt; p(cin&gt;&gt;str,cin&gt;&gt;i);
        vec.push_back(p);
    &#125;
    
    
&#125;
</code></pre>
<h2 id="11-3-关联容器操作"><a href="#11-3-关联容器操作" class="headerlink" title="11.3 关联容器操作"></a>11.3 关联容器操作</h2><pre><code>-------------------------关联容器额外的类型别名------------------------
key_type                此容器类型的关键字类型
mapped_type             每个关键字关联的类型：只适用于map
value_type              对于set和key_type相同，对于map为pair&lt;const key_type,mapped_type&gt;
</code></pre>
<pre><code>map&lt;string,int&gt;::value_type v5;     //v5为pair&lt;const string,int&gt;
</code></pre>
<h3 id="11-3-1-关联容器迭代器"><a href="#11-3-1-关联容器迭代器" class="headerlink" title="11.3.1 关联容器迭代器"></a>11.3.1 关联容器迭代器</h3><ul>
<li>当解引用一个关联容器迭代器的时候我们会得到一个类型为容器的value_type的值的引用。</li>
<li>虽然set同时定义了iterator和const_iterator，但是两种迭代器都只允许度访问set中的元素。</li>
<li>通常不对关联容器使用泛型算法</li>
</ul>
<pre><code>exercise 11.15
vector&lt;int&gt; int pair&lt;const int,vector&lt;int&gt;&gt;
</code></pre>
<pre><code>exercise 11.16
map&lt;int,std::string&gt; map;
map[25] = &quot;alan&quot;;
map&lt;int,std::string&gt;::iterator it = map.begin();
it-&gt;second = &quot;wang&quot;;
</code></pre>
<pre><code>using compareType = bool(*)(const Sales_data &amp;lhs,const Sales_dat &amp;rhs);
std::multiset&lt;Sales_data,compareType&gt; bookstore(compareIsbn);
std::multiset&lt;Sales_data,compareType&gt;::iterator c_it = bookstore.begin();
</code></pre>
<h3 id="11-3-2-添加元素"><a href="#11-3-2-添加元素" class="headerlink" title="11.3.2 添加元素"></a>11.3.2 添加元素</h3><ul>
<li>使用insert成员向容器插入元素，如果插入已存在元素无影响。</li>
<li>insert有两个版本一个接受一对迭代器，或者是一个初始化列表。</li>
<li>向一个map进行insert操作，元素的类型需要时pair类型。创建一个pair最简单的方法是使用花括号初始化。</li>
<li>关于insert的返回值，返回一个pair，如果插入成功，pair-&gt;first是一个迭代器指向具有关键字类型的元素，second为ture，如果已经存在second为false。</li>
<li>对于允许重复关键字的容器，接受单个元素的insert操作返回一个指向新元素的迭代器。</li>
</ul>
<pre><code>exercise 11.20
#include&lt;iostream&gt;
#include&lt;map&gt;
#inlcude&lt;string&gt;
int mian()
&#123;
    std::map&lt;std::string,size_t&gt; counts;
    for(string word;cin&gt;&gt;word;)
    &#123;
        auto result = couts.insert(&#123;word,1&#125;);
        if(!result.second)
            ++result.first-&gt;second;
    &#125;
&#125;
</code></pre>
<pre><code>exercise 11.22
pair&lt;map&lt;string,vector&lt;int&gt;&gt;::iterator,bool&gt; ret = map.insert(&#123;string,int&#125;);
</code></pre>
<h3 id="11-3-3-删除元素"><a href="#11-3-3-删除元素" class="headerlink" title="11.3.3 删除元素"></a>11.3.3 删除元素</h3><ul>
<li>erase有三个版本的，可以提供一个迭代器删除一个元素，可以通过一对迭代器删除一个范围的元素，也可以通过一个关键字删除元素。最后一个版本可以返回删除元素的数量。</li>
</ul>
<h3 id="11-3-4-map的下标操作"><a href="#11-3-4-map的下标操作" class="headerlink" title="11.3.4 map的下标操作"></a>11.3.4 map的下标操作</h3><ul>
<li>map下标操作符接受一个关键字获取与关键字相互关联的值。如果关键字不在容器中。会创建一个元素并插入到map中。</li>
<li>at函数访问关键字为k的元素，带参数检查，如果k不在c中，抛出一个异常。</li>
<li>当对一个map进行下标操作的时候回获得一个mapped_type对象。</li>
</ul>
<pre><code>exercise 11.24 
add a key-value pair&#123;0,1&#125; into map

exervcise 11.25 
it&#39;s try to deference an item out of range 
</code></pre>
<h3 id="11-3-5-访问元素"><a href="#11-3-5-访问元素" class="headerlink" title="11.3.5 访问元素"></a>11.3.5 访问元素</h3><pre><code>find(k)                    返回一个迭代器，指向第一个关键字为k的元素，如果没有指向尾后迭代器
count(k)                   返回关键字等于k的元素的数量
lower_bound(k)             返回一个迭代器，指向第一个关键字不小于k的元素
upper_bound(k)             返回一个迭代器，执行第一个关键字大于k的元素
equal_range(k)             返回一个迭代器pair，表示关键字等于k的范围
</code></pre>
<ul>
<li>使用find代替下标操作的情况：我们指向查找一个元素是否在map中，如果不在也不想插入。</li>
<li>在multimap和multiset查找元素的方法，具有相同关键字的元素是相邻的<ul>
<li>使用count获得总元素数目，然后调用迭代器获得第一个元素，依次获得即可。</li>
<li>使用lower_bound和upper_bound.</li>
<li>使用equal_range</li>
</ul>
</li>
</ul>
<pre><code>exercise 11.27
i would use count to deal with multimap and multiset
use find to deal with map and set

exercise 11.28
std::map&lt;std::string,vector&lt;int&gt;&gt; map;
auto iter = map.find(&quot;a&quot;);

exercise 11.29
lower_bound和upper_bound返回一样的迭代器，构成一个空的范围。如果给定关键字比所有关键字都大，返回尾后迭代器。
equal_range返回一个正确插入的位置的迭代器pair。

exercise 11.30
pos a pair ; pos.first: a iterator refering to the first element with the matching key
pos.first-&gt;second:the value of the element with the matching key
</code></pre>
<h2 id="11-4-无序容器"><a href="#11-4-无序容器" class="headerlink" title="11.4 无序容器"></a>11.4 无序容器</h2><ul>
<li>无序同期在存储上组织为一组桶，无序容器使用哈希函数将元素映射到桶，为了访问一个元素，容器先计算元素的哈希值，会搜索出在那个桶中。</li>
</ul>
<pre><code>-----------------------无序容器管理操作------------------------
c.bucket_count()           //正在使用的桶数目                              
c.max_bucket_count()       //容器能容纳最多桶数目      
c.bucket_size(n)           //第n个桶中元素个数
c.bucket(k)                //关键字k在那个桶中
local_iterator             //访问同种元素的迭代器类型              
const_local_iterator       //                      
c.begin(n)/c.end(n)        //                  
c.cbegin(n)c.cend(n)       //                      
c.load_factor()            //每个桶中的平均元素数量
c.max_load_factor()        //c试图维护的平均桶大小
c.rehash()                 //          
c.reserve(n)               //              
</code></pre>
<ul>
<li>默认情况下，无序容器使用关键字类型&#x3D;&#x3D;运算符比较元素。还使用hash<key_type>类型对象生成每个元素的哈希值。</li>
</ul>
<h1 id="第12章-动态内存"><a href="#第12章-动态内存" class="headerlink" title="第12章 动态内存"></a>第12章 动态内存</h1><h2 id="12-1-动态内存和智能指针"><a href="#12-1-动态内存和智能指针" class="headerlink" title="12.1 动态内存和智能指针"></a>12.1 动态内存和智能指针</h2><ul>
<li>shared_ptr允许多个指针同时指向一个对象，unique_ptr独占所指对象。标准库还定义了一种名为weak_ptr的伴随类，是一种弱引用，指向shared_ptr所管理的对象。三个类型都定义在memory中。</li>
</ul>
<h3 id="12-1-1-shared-ptr类"><a href="#12-1-1-shared-ptr类" class="headerlink" title="12.1.1 shared_ptr类"></a>12.1.1 shared_ptr类</h3><ul>
<li>智能指针也是模板，需要给出类型，默认初始化是一个空指针。</li>
</ul>
<pre><code>------------------shared_ptr和unique_ptr支持操作------------------
shared_ptr&lt;T&gt; sp;
unique_ptr&lt;T&gt; up;
p
*p
p-&gt;mem
p.get()                 //返回p中保存的指针
swap(p,q)
p.swap(q)
-------------shared_ptr独有操作---------------------------
make_shared&lt;T&gt;(args)            //返回一个shared_ptr,指向一个动态分配的类型t的对象，使用args初始化该对象
shared_ptr&lt;T&gt;p(q)     p是share_ptr q的拷贝：此操作递增q中计数器
p.unique()
p.usr_count()           //返回与p共享对象的smartptr的数量
</code></pre>
<ul>
<li>make_shared函数   <pre><code>//p指向一个动态分配的空的vector
auto p = make_shared&lt;vector&lt;string&gt;&gt;();
</code></pre>
</li>
<li>shared_ptr的拷贝构造：会增加引用计数，当计数为0自动释放管理的对象。</li>
<li>shared_ptr自动销毁所管理的对象：调用析构函数完成销毁工作。</li>
<li>使用动态内存的原因:<ul>
<li>程序不知道自己使用多少对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个对象间共享数据。</li>
</ul>
</li>
<li>可以在一个类中定义之智能指针指向一个vector，该vector就可以在这个类的对象中共享了。</li>
</ul>
<h3 id="12-1-2-直接管理内存"><a href="#12-1-2-直接管理内存" class="headerlink" title="12.1.2 直接管理内存"></a>12.1.2 直接管理内存</h3><ul>
<li>默认情况下，动态分配的对象是默认初始化的，所以内置类型或者组合类型的对象是未定义的。而类类型对象使用默认构造函数初始化。<pre><code>string * ps = new string;           //initialized to empty string
int *pi = new int;                  //pi points to an uninitialized int
</code></pre>
</li>
<li>只要当初始化的括号中仅有单以初始化才可以使用auto<pre><code>auto p1 = new auto(obj);            //p points to an object of the type of obj that object is initialized from obj
auto p2 = new auto&#123;a,b,c&#125;;
</code></pre>
</li>
<li>使用delete释放一块非new分配的内存，或将相同的指针值多次是放是未定义的。</li>
</ul>
<h3 id="12-1-3-shared-ptr和new结合使用"><a href="#12-1-3-shared-ptr和new结合使用" class="headerlink" title="12.1.3 shared_ptr和new结合使用"></a>12.1.3 shared_ptr和new结合使用</h3><ul>
<li>可以使用普通指指针来初始化智能指针，但是不支持隐世转化，所以必须直接初始化。</li>
<li>不要混用内置指针和只能指针，当讲shared_ptr绑定到内置指针后，资源管理就交给了share_ptr,不应该在使用内置指针访问shared_ptr说指向的内存了。</li>
<li>智能指针的get函数返回一个内置指针，指向智能指针所指对象，不要用get初始哈另一个指针指针或位智能指针赋值。如果初始化了另一个智能指针，两个智能指针指向同一对象。</li>
<li>可以使用reset函数将新的指针赋予shared_ptr,与赋值相似，reset会更新引用计数。reset常和unique一起使用，用来控制多个shared_ptr共享对象。<pre><code>if(!p.unique())
    p.reset(new string(*p));        //不是唯一的用户，重新分配拷贝，然后将p绑定拷贝后的指针。
*p += newVal;
</code></pre>
</li>
</ul>
<h3 id="12-1-4-智能指针异常"><a href="#12-1-4-智能指针异常" class="headerlink" title="12.1.4 智能指针异常"></a>12.1.4 智能指针异常</h3><ul>
<li>如果使用智能指针，即使程序过早的结束，智能指针也能确保内存在不需要的时候释放。</li>
<li>默认下shared_ptr假定其指向动态内存，使用delete释放对象，创建shared_ptr可以传递一个指向删除函数的指针参数。用来代替delete。</li>
<li>智能指针陷阱：<ul>
<li>不使用相同的内置指针初始化或reset多个智能指针。</li>
<li>不delete get()返回的指针</li>
<li>不使用get()初始化或reset另一个智能指针</li>
<li>如果使用get()返回的指针，记得在对应智能指针销毁后，内置指针也无效了。</li>
<li>如果使用智能指针管理的资源不是new分配的内存，记住传递给他一个删除器。</li>
</ul>
</li>
</ul>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;memory&gt;

//连接信息
struct connection
&#123;
    std::string ip;
    int port;
    connection(std::string ip_,int port_):ip(ip_),port(port_)&#123;&#125;
&#125;;

//连接什么
struct destination
&#123;
    std:: string ip;
    int port ;
    destination(std::string ip_,int port_):ip(ip_),port(port_)&#123;&#125;
&#125;;

connection connect(destination* pDest)
&#123;
    std::shared_ptr&lt;connection&gt; pConn(new connection(pDest-&gt;ip,pDest-&gt;prot));
    std::cout&lt;&lt;&quot;creatin connection&quot;;
    return *pCon;
&#125;

void disconnect(connection pConn)
&#123;
    cout&lt;&lt;&quot;connection close&quot;;
&#125;
void end_connection(connection * pConn)
&#123;
    disconnect(*pConn);
&#125;

void f(destination &amp;d)
&#123;
    connection conn = connect(d);
    std::shared_ptr&lt;connection&gt; p(&amp;conn,end_connection);
    std::cout&lt;&lt;&quot;conneciton now&quot;;
&#125;

int mian()
&#123;
    destination dest(&quot;202.118.176.67&quot;, 3316);
    f(dest);
&#125;
</code></pre>
<h3 id="12-1-5-unique-ptr"><a href="#12-1-5-unique-ptr" class="headerlink" title="12.1.5 unique_ptr"></a>12.1.5 unique_ptr</h3><ul>
<li>与shared_ptr不同，unique同一时刻只能有一个给定的对象。放unique-ptr被销毁，对象也随之销毁。</li>
<li>make_unique函数在动态内存中分配一个对象并初始化它。</li>
<li>虽然unique_ptr不支持拷贝和构造，但是可以使用哪个release和reset将他否给另一个指针。</li>
<li>release函数返回unique_ptr当前保存的指针，并将其设为空</li>
<li>reset函数接受一个可选指针参数。重新设置unique_ptr保存的参数，但是原来的对象会被销毁。</li>
<li>调用release会切断unique_ptr和他原来管理的对象对象之间的关系，如果没有用另一个智能指针保存返回的指针，需要手动清理。</li>
<li>不能拷贝unique_ptr的特例：可以赋值拷贝一个即将别销毁的unique_ptr</li>
<li>定义unique_\ptr是必须在尖括号中提供删除器类型。创建或reset这种类型对象，必须提供一个指定的可调用对象(删除器).</li>
</ul>
<h3 id="12-1-6-weak-ptr"><a href="#12-1-6-weak-ptr" class="headerlink" title="12.1.6 weak_ptr"></a>12.1.6 weak_ptr</h3><ul>
<li>weak_ptr是一种不控制所指向对象生存期的智能指针，它指向一个由shared_ptr管理的对象。将weak_ptr绑定到shared_ptr不会改变shared_ptr的引用计数。如果shared_ptr被销毁，即使有weak_ptr指向对象，对象仍然有可能被释放。</li>
<li>建一个weak_ptr时，需要使用shared_ptr来初始化它。</li>
<li>使用weak_ptr访问对象时，必须先调用lock函数。该函数检查weak_ptr指向的对象是否仍然存在。如果存在，则返回指向共享对象的shared_ptr，否则返回空指针。</li>
<li>weak_ptr可以阻止用户访问一个不存在的对象的企图</li>
</ul>
<h2 id="12-2-动态数组"><a href="#12-2-动态数组" class="headerlink" title="12.2 动态数组"></a>12.2 动态数组</h2><ul>
<li>使用allocator类可以将内存分配和初始化过程分离，这通常会提供更好的性能和更加灵活的内存管理能力。</li>
</ul>
<h3 id="12-2-1-new和数组"><a href="#12-2-1-new和数组" class="headerlink" title="12.2.1 new和数组"></a>12.2.1 new和数组</h3><ul>
<li>使用new分配对象数组时需要在类型名之后跟一对方括号，在其中指明要分配的对象数量（必须是整型，但不必是常量）。new返回指向第一个对象的指针（元素类型）。<pre><code>int *pia = new int[get_size()];
</code></pre>
</li>
<li>由于new分配的内存并不是数组类型，因此不能对动态数组调用begin和end，也不能用范围for语句处理其中的元素。</li>
<li>默认情况下，new分配的对象是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小后面跟一对空括号()。在新标准中，还可以提供一个元素初始化器的花括号列表。如果初始化器数量大于元素数量，则new表达式失败，不会分配任何内存，并抛出bad_array_new_length异常。</li>
<li>动态分配一个空数组是合法的，此时new会返回一个合法的非空指针。对于零长度的数组来说，该指针类似尾后指针，不能解引用。</li>
<li>使用delete[]释放动态数组。</li>
<li>unique_ptr可以直接管理动态数组，定义时需要在对象类型后添加一对空方括号[]。</li>
<li>与unique\ptr不同，shared_ptr不直接支持动态数组管理。如果想用shared_ptr管理动态数组，必须提供自定义的删除器。</li>
<li>shared_ptr未定义下标运算符，智能指针类型也不支持指针算术运算。因此如果想访问shared_ptr管理的数组元素，必须先用get获取内置指针，再用内置指针进行访问。</li>
</ul>
<h3 id="12-2-2-allocator类"><a href="#12-2-2-allocator类" class="headerlink" title="12.2.2 allocator类"></a>12.2.2 allocator类</h3><ul>
<li>allocator类是一个模板，定义时必须指定其可以分配的对象类型。</li>
<li>allocator分配的内存是未构造的，程序需要在此内存中构造对象。新标准库的construct函数接受一个指针和零或多个额外参数，在给定位置构造一个元素。额外参数用来初始化构造的对象，必须与对象类型相匹配。</li>
<li>直接使用allocator返回的未构造内存是错误行为，其结果是未定义的。</li>
<li>对象使用完后，必须对每个构造的元素调用destroy进行销毁。destroy函数接受一个指针，对指向的对象执行析构函数</li>
<li>deallocate函数用于释放allocator分配的内存空间。传递给deallocate的指针不能为空，它必须指向由allocator分配的内存。而且传递给deallocate的大小参数必须与调用allocator分配内存时提供的大小参数相一致。</li>
<li>传递给uninitialized_copy的目的位置迭代器必须指向未构造的内存，它直接在给定位置构造元素。返回（递增后的）目的位置迭代器。</li>
</ul>
<pre class=" language-.h"><code class="language-.h">#pragam once
#include<string>
using std::string;

#include<vector>
using std::vector;
#include <memory>
using std::shared_ptr;

#include <iostream>
#include <fstream>
#include <map>
using std::map;
#include <set>
using std::set;
class QueryResult;
class TextQuery
{
public:
    using LineNum = vector<string>::size_type;    
    TextQuery(std::ifstream &);
    QueryResult query(const string&) const;
private:
    share_ptr<vector<string>> input;
    map<string,shared_ptr<set<LineNum>>> result;
};

class QueryResult 
{
public:
    friend std::ostream& print(std::ostream&,const QueryResult&);
public:
    QueryResult(const string &shared_ptr<set<TextQuery::LineNum>> set,share_ptr<vector<string>> vec):
                word(s),input(vec),nos(set);
private:
    string word;
    share_ptr<vector<string>> input;
    shared_ptr<set<TextQuery::LineNum>> nos;
};

std::ostream& print(std::ostream&,const QueryResult&);
</code></pre>
<pre class=" language-.cpp"><code class="language-.cpp">TextQuery::TextQuery(std::ifstream &ifs):input(new vector<string>)
{
    LineNum lineNo{0};
    for(string line,std::getline(ifs,line);++lineNo)
    {
        input->push_back(line);
        std::isstringstream line_stream(line);
        for(string text，word;line_stream>>text;word.clear())
        {
            std::remove_copy_if(text.begin(),text.end(),std::back_inserter(word),ispuct);
            auto &nos = result[word];
            if(!nos)nos.reset(new std::set<lineNum>);
            nos->insert(lineNum);
        }
    }
}

QueryResult TextQuery::query(const string& str) const
{
    static shared_ptr<set<LineNum>> nodata(new set<LineNum>);
    auto found = result.find(str);
    if(found == result.end())return QueryResult(str,nodata,input);
    else return QueryResult(str,found->second,input);
}

std::ostream & print(std::ostream &out,const QueryResult &qr)
{
    out << qr.word << " occurs " << qr.nos->size() << (qr.nos->size() > 1 ? " times" : " time") << std::endl;
    for (auto i : *qr.nos)
        out << "\t(line " << i+1 << ") " << qr.input->at(i) << std::endl;
    return out;
}
</code></pre>
<h1 id="第13章-拷贝控制"><a href="#第13章-拷贝控制" class="headerlink" title="第13章 拷贝控制"></a>第13章 拷贝控制</h1><h2 id="13-1-拷贝、赋值与销毁"><a href="#13-1-拷贝、赋值与销毁" class="headerlink" title="13.1 拷贝、赋值与销毁"></a>13.1 拷贝、赋值与销毁</h2><h3 id="13-1-1-拷贝构造函数"><a href="#13-1-1-拷贝构造函数" class="headerlink" title="13.1.1 拷贝构造函数"></a>13.1.1 拷贝构造函数</h3><ul>
<li>如果一个构造函数的第一个参数是自身类类型的引用（几乎总是const引用），且任何额外参数都有默认值，则此构造函数是拷贝构造函数。<pre><code>class Foo
&#123;
public:
    Foo();   // default constructor
    Foo(const Foo&amp;);   // copy constructor
    // ...
&#125;;
</code></pre>
</li>
<li>由于拷贝构造函数在一些情况下会被隐式使用，因此通常不会声明为explicit的。</li>
<li>如果类未定义自己的拷贝构造函数，编译器会为类合成一个。一般情况下，合成拷贝构造函数（synthesized copy constructor）会将其参数的非static成员逐个拷贝到正在创建的对象中。<pre><code>class Sales_data
&#123;
public:
    // other members and constructors as before
    // declaration equivalent to the synthesized copy constructor
    Sales_data(const Sales_data&amp;);    
private:
    std::string bookNo;
    int units_sold = 0;
    double revenue = 0.0;
&#125;;

// equivalent to the copy constructor that would be synthesized for Sales_data
Sales_data::Sales_data(const Sales_data &amp;orig):
    bookNo(orig.bookNo),    // uses the string copy constructor
    units_sold(orig.units_sold),    // copies orig.units_sold
    revenue(orig.revenue)   // copies orig.revenue
    &#123; &#125; // empty bod
</code></pre>
</li>
<li>使用直接初始化时，实际上是要求编译器按照函数匹配规则来选择与实参最匹配的构造函数。使用拷贝初始化时，是要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。<pre><code>string dots(10, &#39;.&#39;);   // direct initialization
string s(dots);         // direct initialization
string s2 = dots;       // copy initialization
string null_book = &quot;9-999-99999-9&quot;;    // copy initialization
string nines = string(100, &#39;9&#39;);       // copy initialization
</code></pre>
</li>
<li>拷贝初始化通常使用拷贝构造函数来完成。但如果一个类拥有移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。</li>
<li>发生拷贝的情况：<ul>
<li>使用&#x3D;定义变量</li>
<li>将对象作为实参传递给非引用实参。</li>
<li>从返回类型为非引用类型的函数返回对象。</li>
<li>用花括号列表初始化数组中的元素或聚合类中的成员。</li>
</ul>
</li>
<li>当传递一个实参或者从函数返回一个值时，不能隐式使用explicit构造函数。</li>
<li>如果类未定义自己的拷贝赋值运算符，编译器会为类合成一个。一般情况下，合成拷贝赋值运算符（synthesized copy-assignment operator）会将其右侧运算对象的非static成员逐个赋值给左侧运算对象的对应成员，之后返回左侧运算对象的引用。<pre><code>// equivalent to the synthesized copy-assignment operator
Sales_data&amp; Sales_data::operator=(const Sales_data &amp;rhs)
&#123;
    bookNo = rhs.bookNo;    // calls the string::operator=
    units_sold = rhs.units_sold;    // uses the built-in int assignment
    revenue = rhs.revenue;  // uses the built-in double
    assignment...
    return *this;   // return a reference to this object
&#125;
</code></pre>
</li>
</ul>
<h3 id="12-1-2-拷贝赋值运算符"><a href="#12-1-2-拷贝赋值运算符" class="headerlink" title="12.1.2 拷贝赋值运算符"></a>12.1.2 拷贝赋值运算符</h3><ul>
<li>重载运算符（overloaded operator）的参数表示运算符的运算对象。如果一个运算符是成员函数，则其左侧运算对象会绑定到隐式的this参数上。赋值运算符通常应该返回一个指向其左侧运算对象的引用。<pre><code>class Foo
&#123;
public:
    Foo&amp; operator=(const Foo&amp;);  // assignment operator
    // ...
&#125;;
</code></pre>
</li>
<li>标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值是左侧运算对象的引用。</li>
<li>如果类未定义自己的拷贝赋值运算符，编译器会为类合成一个。一般情况下，合成拷贝赋值运算符（synthesized copy-assignment operator）会将其右侧运算对象的非static成员逐个赋值给左侧运算对象的对应成员，之后返回左侧运算对象的引用。<pre><code>// equivalent to the synthesized copy-assignment operator
Sales_data&amp; Sales_data::operator=(const Sales_data &amp;rhs)
&#123;
    bookNo = rhs.bookNo;    // calls the string::operator=
    units_sold = rhs.units_sold;    // uses the built-in int assignment
    revenue = rhs.revenue;  // uses the built-in double
    assignment
    return *this;   // return a reference to this object
&#125;
</code></pre>
</li>
</ul>
<h3 id="12-1-3-析构函数"><a href="#12-1-3-析构函数" class="headerlink" title="12.1.3 析构函数"></a>12.1.3 析构函数</h3><ul>
<li>析构函数负责释放对象使用的资源，并销毁对象的非static数据成员。</li>
<li>析构函数的名字由波浪号~接类名构成，它没有返回值，也不接受参数。<pre><code>class Foo
&#123;
public:
    ~Foo(); // destructor
    // ...
&#125;;
</code></pre>
</li>
<li>由于析构函数不接受参数，所以它不能被重载。</li>
<li>如果类未定义自己的析构函数，编译器会为类合成一个。合成析构函数（synthesized destructor）的函数体为空。</li>
</ul>
<h3 id="13-1-4-三五准则"><a href="#13-1-4-三五准则" class="headerlink" title="13.1.4 三五准则"></a>13.1.4 三五准则</h3><ul>
<li>需要析构函数的类一般也需要拷贝和赋值操作。</li>
<li>需要拷贝操作的类一般也需要赋值操作，反之亦然。</li>
</ul>
<h3 id="13-1-5-使用-x3D-default"><a href="#13-1-5-使用-x3D-default" class="headerlink" title="13.1.5 使用&#x3D;default"></a>13.1.5 使用&#x3D;default</h3><ul>
<li>可以通过将拷贝控制成员定义为&#x3D;default来显式地要求编译器生成合成版本。</li>
<li>在类内使用&#x3D;default修饰成员声明时，合成的函数是隐式内联的。如果不希望合成的是内联函数，应该只对成员的类外定义使用&#x3D;default。</li>
</ul>
<h3 id="13-1-6-阻止拷贝"><a href="#13-1-6-阻止拷贝" class="headerlink" title="13.1.6 阻止拷贝"></a>13.1.6 阻止拷贝</h3><ul>
<li>在C++11新标准中，将拷贝构造函数和拷贝赋值运算符定义为删除的函数（deleted function）可以阻止类对象的拷贝。删除的函数是一种虽然进行了声明，但是却不能以任何方式使用的函数。定义删除函数的方式是在函数的形参列表后面添加&#x3D;delete。<pre><code>struct NoCopy
&#123;
    NoCopy() = default; // use the synthesized default constructor
    NoCopy(const NoCopy&amp;) = delete; // no copy
    NoCopy &amp;operator=(const NoCopy&amp;) = delete; // no assignment
    ~NoCopy() = default; // use the synthesized destructor
    // other members
&#125;;
</code></pre>
</li>
<li>&#x3D;delete和&#x3D;default有两点不同：<ul>
<li>&#x3D;delete可以对任何函数使用；&#x3D;default只能对具有合成版本的函数使用。</li>
<li>&#x3D;delete必须出现在函数第一次声明的地方；&#x3D;default既能出现在类内，也能出现在类外。</li>
</ul>
</li>
<li>析构函数不能是删除的函数。对于析构函数被删除的类型，不能定义该类型的变量或者释放指向该类型动态分配对象的指针。</li>
<li>如果一个类中有数据成员不能默认构造、拷贝或销毁，则对应的合成拷贝控制成员将被定义为删除的。</li>
<li>在旧版本的C++标准中，类通过将拷贝构造函数和拷贝赋值运算符声明为private成员来阻止类对象的拷贝。并且只声明该函数而定义，子类访问。在新标准中建议使用&#x3D;delete而非private。</li>
</ul>
<h2 id="13-2-拷贝控制和资源管理"><a href="#13-2-拷贝控制和资源管理" class="headerlink" title="13.2 拷贝控制和资源管理"></a>13.2 拷贝控制和资源管理</h2><h3 id="13-2-1-行为像值的类"><a href="#13-2-1-行为像值的类" class="headerlink" title="13.2.1 行为像值的类"></a>13.2.1 行为像值的类</h3><pre><code>class HasPtr
&#123;
public:
    HasPtr(const std::string &amp;s = std::string()):
        ps(new std::string(s)), i(0) &#123; &#125;
    // each HasPtr has its own copy of the string to which ps points
    HasPtr(const HasPtr &amp;p):
        ps(new std::string(*p.ps)), i(p.i) &#123; &#125;
    HasPtr&amp; operator=(const HasPtr &amp;);
    ~HasPtr() &#123; delete ps; &#125;
    
private:
    std::string *ps;
    int i;
&#125;;
</code></pre>
<ul>
<li>编写赋值运算符有两点需要注意：<ul>
<li>即使将一个对象赋予它自身，赋值运算符也能正确工作。</li>
<li>赋值运算符通常结合了拷贝构造函数和析构函数的工作。</li>
</ul>
</li>
<li>编写赋值运算符时，一个好的方法是先将右侧运算对象拷贝到一个局部临时对象中。拷贝完成后，就可以安全地销毁左侧运算对象的现有成员了。<pre><code>HasPtr&amp; HasPtr::operator=(const HasPtr &amp;rhs)
&#123;
    auto newp = new string(*rhs.ps);    // copy the underlying string
    delete ps;   // free the old memory
    ps = newp;   // copy data from rhs into this object
    i = rhs.i;
    return *this;   // return this object
&#125;
</code></pre>
</li>
</ul>
<h3 id="13-3-2-定义行为像指针的类"><a href="#13-3-2-定义行为像指针的类" class="headerlink" title="13.3.2 定义行为像指针的类"></a>13.3.2 定义行为像指针的类</h3><pre><code>class HasPtr
&#123;
public:
    // constructor allocates a new string and a new counter, which it sets to 1
    HasPtr(const std::string &amp;s = std::string()):
        ps(new std::string(s)), i(0), use(new std::size_t(1)) &#123;&#125;
    // copy constructor copies all three data members and increments the counter
    HasPtr(const HasPtr &amp;p):
        ps(p.ps), i(p.i), use(p.use) &#123; ++*use; &#125;
    HasPtr&amp; operator=(const HasPtr&amp;);
    ~HasPtr();

private:
    std::string *ps;
    int i;
    std::size_t *use; // member to keep track of how many objects share *ps
&#125;;
HasPtr::~HasPtr()
&#123;
    if (--*use == 0)
    &#123;   // if the reference count goes to 0
        delete ps;   // delete the string
        delete use;  // and the counter
    &#125;
&#125;

HasPtr&amp; HasPtr::operator=(const HasPtr &amp;rhs)
&#123;
    ++*rhs.use;    // increment the use count of the right-hand operand
    if (--*use == 0)
    &#123;   // then decrement this object&#39;s counter
        delete ps; // if no other users
        delete use; // free this object&#39;s allocated members
    &#125;
    ps = rhs.ps;    // copy data from rhs into this object
    i = rhs.i;
    use = rhs.use;
    return *this;   // return this object
&#125;
</code></pre>
<h2 id="13-3-交换操作"><a href="#13-3-交换操作" class="headerlink" title="13.3 交换操作"></a>13.3 交换操作</h2><ul>
<li>通常，管理类外资源的类会定义swap函数。如果一个类定义了自己的swap函数，算法将使用自定义版本，否则将使用标准库定义的swap。</li>
<li>一些算法在交换两个元素时会调用swap函数，其中每个swap调用都应该是未加限定的。如果存在类型特定的swap版本，其匹配程度会优于std中定义的版本（假定作用域中有using声明）。</li>
<li>与拷贝控制成员不同，swap函数并不是必要的。但是对于分配了资源的类，定义swap可能是一种重要的优化手段。</li>
<li>定义了swap的类通常用swap来实现赋值运算符。在这种版本的赋值运算符中，右侧运算对象以值方式传递，然后将左侧运算对象与右侧运算对象的副本进行交换（拷贝并交换，copy and swap）。这种方式可以正确处理自赋值情况。<pre><code>// note rhs is passed by value, which means the HasPtr copy constructor
// copies the string in the right-hand operand into rhs
HasPtr&amp; HasPtr::operator=(HasPtr rhs)
&#123;
    // swap the contents of the left-hand operand with the local variable rhs
    swap(*this, rhs);   // rhs now points to the memory this object had used
    return *this;       // rhs is destroyed, which deletes the pointer in rhs
&#125;
</code></pre>
</li>
</ul>
<h2 id="13-4-拷贝控制实例"><a href="#13-4-拷贝控制实例" class="headerlink" title="13.4 拷贝控制实例"></a>13.4 拷贝控制实例</h2><h2 id="13-5-动态内存管理类"><a href="#13-5-动态内存管理类" class="headerlink" title="13.5 动态内存管理类"></a>13.5 动态内存管理类</h2><h2 id="13-6-对象移动"><a href="#13-6-对象移动" class="headerlink" title="13.6 对象移动"></a>13.6 对象移动</h2><h1 id="第14章-操作重载和类型转换"><a href="#第14章-操作重载和类型转换" class="headerlink" title="第14章 操作重载和类型转换"></a>第14章 操作重载和类型转换</h1><h2 id="14-1-基本概念"><a href="#14-1-基本概念" class="headerlink" title="14.1 基本概念"></a>14.1 基本概念</h2><ul>
<li>重载的运算符是具有特殊名字的函数，它们的名字由关键字operator和其后要定义的运算符号组成。</li>
<li>重载运算符函数的参数数量和该运算符作用的运算对象数量一样多。对于二元运算符来说，左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数。除了重载的函数调用运算符operator()之外，其他重载运算符不能含有默认实参。</li>
<li>如果一个运算符函数是类的成员函数，则它的第一个运算对象会绑定到隐式的this指针上。因此成员运算符函数的显式参数数量比运算对象的数量少一个。</li>
<li>当运算符作用于内置类型的运算对象时，无法改变该运算符的含义。</li>
<li>只能重载大多数已有的运算符，无权声明新的运算符号。</li>
<li>重载运算符的优先级和结合律与对应的内置运算符一致。</li>
<li>可以像调用普通函数一样直接调用运算符函数。<pre><code>// equivalent calls to a nonmember operator function
data1 + data2;              // normal expression
operator+(data1, data2);    // equivalent function call
data1 += data2;             // expression-based &#39;&#39;call&#39;&#39;
data1.operator+=(data2);    // equivalent call to a member operator function
</code></pre>
</li>
<li>通常情况下，不应该重载逗号,、取地址&amp;、逻辑与&amp;&amp;和逻辑或||运算符。</li>
<li>建议只有当操作的含义对于用户来说清晰明了时才使用重载运算符，重载运算符的返回类型也应该与其内置版本的返回类型兼容。</li>
<li>如果类中含有算术运算符或位运算符，则最好也提供对应的复合赋值运算符。</li>
<li>把运算符定义为成员函数时，它的左侧运算对象必须是运算符所属类型的对象。<pre><code>string s = &quot;world&quot;;
string t = s + &quot;!&quot;;     // ok: we can add a const char* to a string
string u = &quot;hi&quot; + s;    // would be an error if + were a member of string
</code></pre>
</li>
<li>如何选择将运算符定义为成员函数还是普通函数：<ul>
<li>赋值&#x3D;、下标[]、调用()和成员访问箭头-&gt;运算符必须是成员函数。</li>
<li>复合赋值运算符一般是成员函数，但并非必须。</li>
<li>改变对象状态或者与给定类型密切相关的运算符，如递增、递减、解引用运算符，通常是成员函数。</li>
<li>具有对称性的运算符可能转换任意一端的运算对象，如算术、相等性、关系和位运算符，通常是普通函数。</li>
</ul>
</li>
</ul>
<h2 id="14-2-输出运算符"><a href="#14-2-输出运算符" class="headerlink" title="14.2 输出运算符"></a>14.2 输出运算符</h2><h3 id="14-2-1-重载输出运算符"><a href="#14-2-1-重载输出运算符" class="headerlink" title="14.2.1 重载输出运算符"></a>14.2.1 重载输出运算符</h3><ul>
<li>通常情况下，输出运算符的第一个形参是ostream类型的普通引用，第二个形参是要打印类型的常量引用，返回值是它的ostream形参。<pre><code>ostream &amp;operator&lt;&lt;(ostream &amp;os, const Sales_data &amp;item)
&#123;
    os &lt;&lt; item.isbn() &lt;&lt; &quot; &quot; &lt;&lt; item.units_sold &lt;&lt; &quot; &quot;
        &lt;&lt; item.revenue &lt;&lt; &quot; &quot; &lt;&lt; item.avg_price();
    return os;
&#125;
</code></pre>
</li>
<li>输出运算符应该尽量减少格式化操作。</li>
<li>输入输出运算符必须是非成员函数。而由于IO操作通常需要读写类的非公有数据，所以输入输出运算符一般被声明为友元。</li>
</ul>
<h3 id="14-2-2-重载输入运算符-gt-gt"><a href="#14-2-2-重载输入运算符-gt-gt" class="headerlink" title="14.2.2 重载输入运算符&gt;&gt;"></a>14.2.2 重载输入运算符&gt;&gt;</h3><ul>
<li>通常情况下，输入运算符的第一个形参是要读取的流的普通引用，第二个形参是要读入的目的对象的普通引用，返回值是它的第一个形参。</li>
</ul>
<pre><code>istream &amp;operator&gt;&gt;(istream &amp;is, Sales_data &amp;item)
&#123;
    double price;   // no need to initialize; we&#39;ll read into price before we use it
    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;
    if (is)    // check that the inputs succeeded
        item.revenue = item.units_sold * price;
    else
        item = Sales_data();    // input failed: give the object the default state
    return is;
&#125;
</code></pre>
<ul>
<li>输入运算符必须处理输入失败的情况，而输出运算符不需要。</li>
<li>当读取操作发生错误时，输入操作符应该负责从错误状态中恢复。</li>
<li>如果输入的数据不符合规定的格式，即使从技术上看IO操作是成功的，输入运算符也应该设置流的条件状态以标示出失败信息。通常情况下，输入运算符只设置failbit状态。eofbit、badbit等错误最好由IO标准库自己标示。</li>
</ul>
<h2 id="14-3-算数运算符"><a href="#14-3-算数运算符" class="headerlink" title="14.3 算数运算符"></a>14.3 算数运算符</h2><ul>
<li>通常情况下，算术和关系运算符应该定义为非成员函数，以便两侧的运算对象进行转换。其次，由于这些运算符一般不会改变运算对象的状态，所以形参都是常量引用。</li>
<li>算术运算符通常会计算它的两个运算对象并得到一个新值，这个值通常存储在一个局部变量内，操作完成后返回该局部变量的副本作为结果（返回类型建议设置为原对象的const类型）。<pre><code>// assumes that both objects refer to the same book
Sales_data operator+(const Sales_data &amp;lhs, const Sales_data &amp;rhs)
&#123;
    Sales_data sum = lhs;   // copy data members from lhs into sum
    sum += rhs;     // add rhs into sum
    return sum;
&#125;
</code></pre>
</li>
<li>如果类同时定义了算术运算符合相关的复合运算符，通常情况下应该使用复合赋值来实现算术运算符。</li>
</ul>
<h3 id="14-3-1-相等运算符"><a href="#14-3-1-相等运算符" class="headerlink" title="14.3.1 相等运算符"></a>14.3.1 相等运算符</h3><ul>
<li>相等运算符设计准则：<ul>
<li>如果类在逻辑上有相等性的含义，则应该定义operator&#x3D;&#x3D;而非一个普通的命名函数。这样做便于使用标准库容器和算法，也更容易记忆。</li>
<li>通常情况下，operator&#x3D;&#x3D;应该具有传递性。</li>
<li>如果类定义了operator&#x3D;&#x3D;，则也应该定义operator!&#x3D;。operator&#x3D;&#x3D;和operator!&#x3D;中的一个应该把具体工作委托给另一个。<pre><code>bool operator==(const Sales_data &amp;lhs, const Sales_data &amp;rhs)
&#123;
    return lhs.isbn() == rhs.isbn() &amp;&amp;
        lhs.units_sold == rhs.units_sold &amp;&amp;
        lhs.revenue == rhs.revenue;
&#125;

bool operator!=(const Sales_data &amp;lhs, const Sales_data &amp;rhs)
&#123;
    return !(lhs == rhs);
&#125;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="14-3-2-关系运算符"><a href="#14-3-2-关系运算符" class="headerlink" title="14.3.2 关系运算符"></a>14.3.2 关系运算符</h3><ul>
<li>定义了相等运算符的类通常也会定义关系运算符。因为关联容器和一些算法要用到小于运算符，所以定义operator&lt;会比较实用。</li>
<li>关系运算符设计准则：<ul>
<li>定义顺序关系，令其与关联容器中对关键字的要求保持一致。</li>
<li>如果类定义了operator&#x3D;&#x3D;，则关系运算符的定义应该与operator&#x3D;&#x3D;保持一致。特别是，如果两个对象是不相等的，那么其中一个对象应该小于另一个对象。</li>
<li>只有存在唯一一种逻辑可靠的小于关系时，才应该考虑为类定义operator&lt;。</li>
</ul>
</li>
</ul>
<h2 id="14-4-赋值运算符"><a href="#14-4-赋值运算符" class="headerlink" title="14.4 赋值运算符"></a>14.4 赋值运算符</h2><ul>
<li>赋值运算符必须定义为成员函数，复合赋值运算符通常也是如此。这两类运算符都应该返回其左侧运算对象的引用<pre><code>StrVec &amp;StrVec::operator=(initializer_list&lt;string&gt; il)
&#123;
    // alloc_n_copy allocates space and copies elements from the given range
    auto data = alloc_n_copy(il.begin(), il.end());
    free();     // destroy the elements in this object and free the space
    elements = data.first;      // update data members to point to the new
    space
    first_free = cap = data.second;
    return *this;
&#125;

// member binary operator: left-hand operand is bound to the implicit this pointer
// assumes that both objects refer to the same book
Sales_data&amp; Sales_data::operator+=(const Sales_data &amp;rhs)
&#123;
    units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    return *this;
&#125;
</code></pre>
</li>
</ul>
<h2 id="14-5-下标运算符"><a href="#14-5-下标运算符" class="headerlink" title="14.5 下标运算符"></a>14.5 下标运算符</h2><ul>
<li>下标运算符必须定义为成员函数。</li>
<li>类通常会定义两个版本的下标运算符：一个返回普通引用，另一个是类的常量成员并返回常量引用。<pre><code>class StrVec
&#123;
public:
    std::string&amp; operator[](std::size_t n)
    &#123; return elements[n]; &#125;
    const std::string&amp; operator[](std::size_t n) const
    &#123; return elements[n]; &#125;

private:
    std::string *elements;  // pointer to the first element in the array
&#125;
</code></pre>
</li>
</ul>
<h2 id="14-6-递增递减运算符"><a href="#14-6-递增递减运算符" class="headerlink" title="14.6 递增递减运算符"></a>14.6 递增递减运算符</h2><ul>
<li>定义递增和递减运算符的类应该同时定义前置和后置版本，这些运算符通常定义为成员函数。</li>
<li>为了与内置操作保持一致，前置递增或递减运算符应该返回运算后对象的引用。<pre><code>// prefix: return a reference to the incremented/decremented object
StrBlobPtr&amp; StrBlobPtr::operator++()
&#123;
    ++curr;     // advance the current state
    return *this;
&#125;
</code></pre>
</li>
<li>后置递增或递减运算符接受一个额外的（不被使用）int类型形参，该形参的唯一作用就是区分运算符的前置和后置版本。<pre><code>class StrBlobPtr
&#123;
public:
    // increment and decrement
    StrBlobPtr&amp; operator++();    // prefix operators
    StrBlobPtr&amp; operator--();
    StrBlobPtr operator++(int);  // postfix operators
    StrBlobPtr operator--(int);
&#125;;
</code></pre>
</li>
<li>为了与内置操作保持一致，后置递增或递减运算符应该返回运算前对象的原值（返回类型建议设置为原对象的const类型）.</li>
<li>如果想通过函数调用的方式使用后置递增或递减运算符，则必须为它的整型参数传递一个值。</li>
</ul>
<h2 id="14-7-成员访问运算符"><a href="#14-7-成员访问运算符" class="headerlink" title="14.7 成员访问运算符"></a>14.7 成员访问运算符</h2><ul>
<li>箭头运算符必须定义为成员函数，解引用运算符通常也是如此。</li>
<li>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的类的对象。<pre><code>class StrBlobPtr
&#123;
public:
    std::string&amp; operator*() const
    &#123;
        return (*p)[curr];   // (*p) is the vector to which this object points
    &#125;
    std::string* operator-&gt;() const
    &#123;   // delegate the real work to the dereference operator
        return &amp; this-&gt;operator*();
    &#125;
&#125;;
</code></pre>
</li>
<li>对于形如point-&gt;mem的表达式来说，point必须是指向类对象的指针或者是一个重载了operator-&gt;的类的对象。point类型不同，point-&gt;mem的含义也不同。<ul>
<li>如果point是指针，则调用内置箭头运算符，表达式等价于(*point).mem。</li>
<li>如果point是重载了operator-&gt;的类的对象，则使用point.operator-&gt;()的结果来获取mem，表达式等价于(point.opeator-&gt;())-&gt;mem。其中，如果该结果是一个指针，则执行内置操作，否则重复调用当前操作。</li>
</ul>
</li>
</ul>
<h2 id="14-8-函数调用运算符"><a href="#14-8-函数调用运算符" class="headerlink" title="14.8 函数调用运算符"></a>14.8 函数调用运算符</h2><ul>
<li>函数调用运算符必须定义为成员函数。一个类可以定义多个不同版本的调用运算符，相互之间必须在参数数量或类型上有所区别。<pre><code>class PrintString
&#123;
public:
    PrintString(ostream &amp;o = cout, char c = &#39; &#39;):
        os(o), sep(c) &#123; &#125;
    void operator()(const string &amp;s) const
    &#123;
        os &lt;&lt; s &lt;&lt; sep;
    &#125;
    
private:
    ostream &amp;os;   // stream on which to write
    char sep;      // character to print after each output
&#125;;

PrintString printer;  // uses the defaults; prints to cout
printer(s);     // prints s followed by a space on cout
</code></pre>
</li>
<li>如果类定义了调用运算符，则该类的对象被称作函数对象（function object），函数对象常常作为泛型算法的实参。<pre><code>for_each(vs.begin(), vs.end(), PrintString(cerr, &#39;\n&#39;));  
</code></pre>
</li>
</ul>
<h3 id="14-8-1-lambda是函数对象"><a href="#14-8-1-lambda是函数对象" class="headerlink" title="14.8.1 lambda是函数对象"></a>14.8.1 lambda是函数对象</h3><ul>
<li>编写一个lambda后，编译器会将该表达式转换成一个未命名类的未命名对象，类中含有一个重载的函数调用运算符。<pre><code>// sort words by size, but maintain alphabetical order for words of the same size
stable_sort(words.begin(), words.end(),
    [](const string &amp;a, const string &amp;b) &#123; return a.size() &lt; b.size(); &#125;);

// acts like an unnamed object of a class that would look something like
class ShorterString
&#123;
public:
    bool operator()(const string &amp;s1, const string &amp;s2) const
    &#123;
        return s1.size() &lt; s2.size();
    &#125;
&#125;;
</code></pre>
</li>
<li>lambda默认不能改变它捕获的变量。因此在默认情况下，由lambda产生的类中的函数调用运算符是一个const成员函数。如果lambda被声明为可变的，则调用运算符就不再是const函数了。</li>
<li>lambda通过引用捕获变量时，由程序负责确保lambda执行时该引用所绑定的对象确实存在。因此编译器可以直接使用该引用而无须在lambda产生的类中将其存储为数据成员。相反，通过值捕获的变量被拷贝到lambda中，此时lambda产生的类必须为每个值捕获的变量建立对应的数据成员，并创建构造函数，用捕获变量的值来初始化数据成员。</li>
<li>lambda产生的类不包含默认构造函数、赋值运算符和默认析构函数，它是否包含默认拷贝&#x2F;移动构造函数则通常要视捕获的变量类型而定。</li>
</ul>
<h3 id="14-8-2-标准库定义的函数对象（Library-Defined-Function-Objects）"><a href="#14-8-2-标准库定义的函数对象（Library-Defined-Function-Objects）" class="headerlink" title="14.8.2 标准库定义的函数对象（Library-Defined Function Objects）"></a>14.8.2 标准库定义的函数对象（Library-Defined Function Objects）</h3><ul>
<li>标准库在头文件functional中定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。这些类都被定义为模板的形式，可以为其指定具体的应用类型（即调用运算符的形参类型）。<img src="/2020/01/09/c/c-primer/%E8%A1%A814.2.png" class="" title="表14.2.png">)</li>
<li>关系运算符的函数对象类通常被用来替换算法中的默认运算符，这些类对于指针同样适用。<pre><code>vector&lt;string *&gt; nameTable;    // vector of pointers
// error: the pointers in nameTable are unrelated, so &lt; is undefined
sort(nameTable.begin(), nameTable.end(),
        [](string *a, string *b) &#123; return a &lt; b; &#125;);
// ok: library guarantees that less on pointer types is well defined
sort(nameTable.begin(), nameTable.end(), less&lt;string*&gt;());
</code></pre>
</li>
</ul>
<h3 id="14-8-3-可调用对象语与function"><a href="#14-8-3-可调用对象语与function" class="headerlink" title="14.8.3 可调用对象语与function"></a>14.8.3 可调用对象语与function</h3><ul>
<li>调用形式指明了调用返回的类型以及传递给调用的实参类型。不同的可调用对象可能具有相同的调用形式。</li>
<li>标准库function类型是一个模板，定义在头文件functional中，用来表示对象的调用形式。<img src="/2020/01/09/c/c-primer/%E8%A1%A814.3.png" class="" title="表14.3.png">)</li>
<li>创建一个具体的function类型时必须提供其所表示的对象的调用形式。<pre><code>// ordinary function
int add(int i, int j) &#123; return i + j; &#125;
// function-object class
struct div
&#123;
    int operator()(int denominator, int divisor)
    &#123;
        return denominator / divisor;
    &#125;
&#125;;

function&lt;int(int, int)&gt; f1 = add;      // function pointer
function&lt;int(int, int)&gt; f2 = div();    // object of a function-object class
function&lt;int(int, int)&gt; f3 = [](int i, int j) &#123; return i * j; &#125;;  // lambda
                                
cout &lt;&lt; f1(4,2) &lt;&lt; endl;   // prints 6
cout &lt;&lt; f2(4,2) &lt;&lt; endl;   // prints 2
cout &lt;&lt; f3(4,2) &lt;&lt; endl;   // prints 8
</code></pre>
</li>
<li>不能直接将重载函数的名字存入function类型的对象中，这样做会产生二义性错误。消除二义性的方法是使用lambda或者存储函数指针而非函数名字。</li>
<li>C++11新标准库中的function类与旧版本中的unary_function和binary_function没有关系，后两个类已经被bind函数代替。</li>
</ul>
<h2 id="14-9-重载、类型转换、运算符"><a href="#14-9-重载、类型转换、运算符" class="headerlink" title="14.9 重载、类型转换、运算符"></a>14.9 重载、类型转换、运算符</h2><h3 id="14-9-1-类型转换运算符"><a href="#14-9-1-类型转换运算符" class="headerlink" title="14.9.1 类型转换运算符"></a>14.9.1 类型转换运算符</h3><ul>
<li>类型转换运算符是类的一种特殊成员函数，负责将一个类类型的值转换成其他类型。它不能声明返回类型，形参列表也必须为空，一般形式如下：<br>  <code>operator type() const;</code></li>
<li>类型转换运算符可以面向除了void以外的任意类型（该类型要能作为函数的返回类型）进行定义。</li>
<li>隐式的用户定义类型转换可以置于一个标准（内置）类型转换之前或之后，并与其一起使用。</li>
<li>应该避免过度使用类型转换函数。如果在类类型和转换类型之间不存在明显的映射关系，则这样的类型转换可能具有误导性.</li>
<li>C++11引入了显示的类型转换运算符（explicit conversion operator）。和显式构造函数一样，编译器通常不会将显式类型转换运算符用于隐式类型转换。<pre><code>class SmallInt
&#123;
public:
    // the compiler won&#39;t automatically apply this conversion
    explicit operator int() const &#123; return val; &#125;
    // other members as before
&#125;;

SmallInt si = 3;    // ok: the SmallInt constructor is not explicit
si + 3;     // error: implicit is conversion required, but operator int is explicit
static_cast&lt;int&gt;(si) + 3;    // ok: explicitly request the conversion
</code></pre>
</li>
<li>如果表达式被用作条件，则编译器会隐式地执行显式类型转换。<ul>
<li>if、while、do-while语句的条件部分。</li>
<li>for语句头的条件表达式。</li>
<li>条件运算符? :的条件表达式。</li>
<li>逻辑非运算符!、逻辑或运算符||、逻辑与运算符&amp;&amp;的运算对象。</li>
</ul>
</li>
</ul>
<h3 id="14-9-2-避免有二义性的类型转换"><a href="#14-9-2-避免有二义性的类型转换" class="headerlink" title="14.9.2 避免有二义性的类型转换"></a>14.9.2 避免有二义性的类型转换</h3><ul>
<li>如果一个类中包含一个或者多个类型转换，必须确保在类类型中。</li>
<li>两种情况下可能产生多重转换路径：<ul>
<li>A类定义了一个接受B类对象的转换构造函数，同时B类定义了一个转换目标是A类的类型转换运算符。</li>
<li>类定义了多个类型转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。</li>
</ul>
</li>
<li>可以通过显式调用类型转换运算符或转换构造函数解决二义性问题，但不能使用强制类型转换，因为强制类型转换本身也存在二义性。</li>
<li>通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标都是算术类型的转换。</li>
<li>使用两个用户定义的类型转换时，如果转换前后存在标准类型转换，则由标准类型转换决定最佳匹配。</li>
<li>调用重载函数时，如果需要额外的标准类型转换，则该转换只有在所有可行函数都请求同一个用户定义类型转换时才有用。如果所需的用户定义类型转换不止一个，即使其中一个调用能精确匹配而另一个调用需要额外的标准类型转换，也会产生二义性错误。</li>
</ul>
<h3 id="14-9-3-函数匹配与重载运算符"><a href="#14-9-3-函数匹配与重载运算符" class="headerlink" title="14.9.3 函数匹配与重载运算符"></a>14.9.3 函数匹配与重载运算符</h3><ul>
<li>表达式中运算符的候选函数集包括成员函数，也包括非成员函数。</li>
<li>如果类既定义了转换目标是算术类型的类型转换，也定义了重载的运算符，则会遇到重载运算符与内置运算符的二义性问题。</li>
</ul>
<h1 id="第15章-面型对象程序设计"><a href="#第15章-面型对象程序设计" class="headerlink" title="第15章 面型对象程序设计"></a>第15章 面型对象程序设计</h1><h2 id="15-1-oop：概述"><a href="#15-1-oop：概述" class="headerlink" title="15.1 oop：概述"></a>15.1 oop：概述</h2><ul>
<li>面向对象程序设计（object-oriented programming）的核心思想是数据抽象（封装）、继承和动态绑定（多态）。</li>
<li>通过继承（inheritance）联系在一起的类构成一种层次关系。通常在层次关系的根部有一个基类（base class），其他类则直接或间接地从基类继承而来，这些继承得到的类叫做派生类（derived class）。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</li>
<li>对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类应该将这些函数声明为虚函数（virtual function）。方法是在函数名称前添加virtual关键字。<pre><code>class Quote
&#123;
public:
    std::string isbn() const;
    virtual double net_price(std::size_t n) const;
&#125;;
</code></pre>
</li>
<li>派生类必须通过类派生列表（class derivation list）明确指出它是从哪个或哪些基类继承而来的。类派生列表的形式首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以添加访问说明符。   <pre><code>class Bulk_quote : public Quote
&#123; // Bulk_quote inherits from Quote
public:
    double net_price(std::size_t) const override;
&#125;;
</code></pre>
</li>
<li>派生类必须在其内部对所有重新定义的虚函数进行声明。</li>
<li>使用基类的引用或指针调用一个虚函数时将发生动态绑定（dynamic binding），也叫运行时绑定（run-time binding）。函数的运行版本将由实参决定。</li>
</ul>
<h2 id="15-2-定义基类和派生类"><a href="#15-2-定义基类和派生类" class="headerlink" title="15.2 定义基类和派生类"></a>15.2 定义基类和派生类</h2><h3 id="15-2-1-定义基类"><a href="#15-2-1-定义基类" class="headerlink" title="15.2.1 定义基类"></a>15.2.1 定义基类</h3><ul>
<li>基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</li>
<li>除构造函数之外的任何非静态函数都能定义为虚函数。virtual关键字只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明为虚函数，则该函数在派生类中隐式地也是虚函数。</li>
<li>成员函数如果没有被声明为虚函数，则其解析过程发生在编译阶段而非运行阶段。</li>
<li>派生类能访问基类的公有成员，不能访问私有成员。如果基类希望定义外部代码无法访问，但是派生类对象可以访问的成员，可以使用受保护的（protected）访问运算符进行说明。</li>
</ul>
<h3 id="15-2-2-定义派生类"><a href="#15-2-2-定义派生类" class="headerlink" title="15.2.2 定义派生类"></a>15.2.2 定义派生类</h3><ul>
<li>类派生列表中的访问说明符用于控制派生类从基类继承而来的成员是否对派生类的用户可见。</li>
<li>如果派生类没有覆盖其基类的某个虚函数，则该虚函数的行为类似于其他的普通函数，派生类会直接继承其在基类中的版本</li>
<li>C++标准并没有明确规定派生类的对象在内存中如何分布，一个对象中继承自基类的部分和派生类自定义的部分不一定是连续存储的。</li>
<li>因为在派生类对象中含有与其基类对应的组成部分，所以能把派生类的对象当作基类对象来使用，也能将基类的指针或引用绑定到派生类对象中的基类部分上。这种转换通常称为派生类到基类的（derived-to-base）类型转换，编译器会隐式执行。<pre><code>Quote item;         // object of base type
Bulk_quote bulk;    // object of derived type
Quote *p = &amp;item;   // p points to a Quote object
p = &amp;bulk;          // p points to the Quote part of bulk
Quote &amp;r = bulk;    // r bound to the Quote part of bulk
</code></pre>
</li>
<li>每个类控制它自己的成员初始化过程，派生类必须使用基类的构造函数来初始化它的基类部分。派生类的构造函数通过构造函数初始化列表来将实参传递给基类构造函数。<pre><code>Bulk_quote(const std::string&amp; book, double p, 
        std::size_t qty, double disc) :
Quote(book, p), min_qty(qty), discount(disc) &#123; &#125;
</code></pre>
</li>
<li>除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。派生类初始化时首先初始化基类部分，然后按照声明的顺序依次初始化派生类成员。派生类可以访问基类的公有成员和受保护成员。</li>
<li>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。如果某静态成员是可访问的，则既能通过基类也能通过派生类使用它。</li>
<li>已经完整定义的类才能被用作基类。</li>
<li>Base是D1的直接基类（direct base），是D2的间接基类（indirect base）。最终的派生类将包含它直接基类的子对象以及每个间接基类的子对象。<pre><code>class Base &#123; /* ... */ &#125; ;
class D1: public Base &#123; /* ... */ &#125;;
class D2: public D1 &#123; /* ... */ &#125;;
</code></pre>
</li>
<li>C++11中，在类名后面添加final关键字可以禁止其他类继承它。<pre><code>class NoDerived final &#123; /* */ &#125;;    // NoDerived can&#39;t be a base class
class Base &#123; /* */ &#125;;
// Last is final; we cannot inherit from Last
class Last final : Base &#123; /* */ &#125;;  // Last can&#39;t be a base class
class Bad : NoDerived &#123; /* */ &#125;;    // error: NoDerived is final
class Bad2 : Last &#123; /* */ &#125;;        // error: Last is final
</code></pre>
</li>
</ul>
<h3 id="15-2-3-类型转换和继承"><a href="#15-2-3-类型转换和继承" class="headerlink" title="15.2.3 类型转换和继承"></a>15.2.3 类型转换和继承</h3><ul>
<li>和内置指针一样，智能指针类也支持派生类到基类的类型转换，所以可以将一个派生类对象的指针存储在一个基类的智能指针内。</li>
<li>表达式的静态类型（static type）在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型（dynamic type）则是变量或表达式表示的内存中对象的类型，只有运行时才可知。</li>
<li>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。</li>
<li>不存在从基类到派生类的隐式类型转换，即使一个基类指针或引用绑定在一个派生类对象上也不行，因为编译器只能通过检查指针或引用的静态类型来判断转换是否合法。</li>
<li>不存在从基类到派生类的隐式类型转换，即使一个基类指针或引用绑定在一个派生类对象上也不行，因为编译器只能通过检查指针或引用的静态类型来判断转换是否合法。</li>
<li>如果已知某个基类到派生类的转换是安全的，可以使用static_cast强制覆盖掉编译器的检查工作。</li>
<li>派生类到基类的自动类型转换只对指针或引用有效，在派生类类型和基类类型之间不存在这种转换。</li>
<li>派生类到基类的转换允许我们给基类的拷贝&#x2F;移动操作传递一个派生类的对象，这些操作是基类定义的，只会处理基类自己的成员，派生类的部分被切掉（sliced down）了。<pre><code>Bulk_quote bulk;    // object of derived type
Quote item(bulk);   // uses the Quote::Quote(const Quote&amp;) constructor
item = bulk;        // calls Quote::operator=(const Quote&amp;)
</code></pre>
</li>
<li>用一个派生类对象为一个基类对象初始化或赋值时，只有该对象中的基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略掉。</li>
</ul>
<h2 id="15-3-虚函数"><a href="#15-3-虚函数" class="headerlink" title="15.3 虚函数"></a>15.3 虚函数</h2><ul>
<li>当且仅当通过指针或引用调用虚函数时，才会在运行过程解析该调用，也只有在这种情况下对象的动态类型有可能与静态类型不同。</li>
<li>在派生类中覆盖某个虚函数时，可以再次使用virtual关键字说明函数性质，但这并非强制要求。因为一旦某个函数被声明为虚函数，则在所有派生类中它都是虚函数。</li>
<li>在派生类中覆盖某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。</li>
<li>派生类可以定义一个与基类中的虚函数名字相同但形参列表不同的函数，但编译器会认为该函数与基类中原有的函数是相互独立的，此时派生类的函数并没有覆盖掉基类中的版本。</li>
<li>C++11允许派生类使用override关键字显式地注明虚函数。如果override标记了某个函数，但该函数并没有覆盖已存在的虚函数，编译器将报告错误。override位于函数参数列表之后。<pre><code>struct B
&#123;
    virtual void f1(int) const;
    virtual void f2();
    void f3();
&#125;;

struct D1 : B 
&#123;
    void f1(int) const override;    // ok: f1 matches f1 in the base
    void f2(int) override;      // error: B has no f2(int) function
    void f3() override;     // error: f3 not virtual
    void f4() override;     // error: B doesn&#39;t have a function named f4
&#125;
</code></pre>
</li>
<li>与禁止类继承类似，函数也可以通过添加final关键字来禁止覆盖操作。<pre><code>struct D2 : B
&#123;
    // inherits f2() and f3() from B and overrides f1(int)
    void f1(int) const final;   // subsequent classes can&#39;t override f1(int)
&#125;;
</code></pre>
</li>
<li>final和override关键字出现在形参列表（包括任何const或引用修饰符）以及尾置返回类型之后。</li>
<li>虚函数也可以有默认实参，每次函数调用的默认实参值由本次调用的静态类型决定。如果通过基类的指针或引用调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。</li>
<li>如果虚函数使用默认实参，则基类和派生类中定义的默认实参值最好一致。</li>
<li>使用作用域运算符::可以强制执行虚函数的某个版本，不进行动态绑定。<pre><code>// calls the version from the base class regardless of the dynamic type of baseP
double undiscounted = baseP-&gt;Quote::net_price(42);
</code></pre>
</li>
<li>通常情况下，只有成员函数或友元中的代码才需要使用作用域运算符来回避虚函数的动态绑定机制。</li>
<li>如果一个派生类虚函数需要调用它的基类版本，但没有使用作用域运算符，则在运行时该调用会被解析为对派生类版本自身的调用，从而导致无限递归。</li>
</ul>
<h2 id="15-4-抽象基类"><a href="#15-4-抽象基类" class="headerlink" title="15.4 抽象基类"></a>15.4 抽象基类</h2><ul>
<li>在类内部虚函数声明语句的分号前添加&#x3D;0可以将一个虚函数声明为纯虚（pure virtual）函数。一个纯虚函数无须定义。<br>  <code>double net_price(std::size_t) const = 0;</code></li>
<li>可以为纯虚函数提供定义，但函数体必须定义在类的外部。</li>
<li>含有（或未经覆盖直接继承）纯虚函数的类是抽象基类。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。</li>
<li>不能创建抽象基类的对象。</li>
<li>派生类构造函数只初始化它的直接基类。</li>
<li>重构（refactoring）负责重新设计类的体系以便将操作或数据从一个类移动到另一个类中。</li>
</ul>
<h2 id="15-5-访问控制与继承"><a href="#15-5-访问控制与继承" class="headerlink" title="15.5 访问控制与继承"></a>15.5 访问控制与继承</h2><ul>
<li>一个类可以使用protected关键字来声明外部代码无法访问，但是派生类对象可以访问的成员。</li>
<li>派生类的成员或友元只能通过派生类对象来访问基类的protected成员。派生类对于一个基类对象中的protected成员没有任何访问权限。<pre><code>class Base
&#123;
protected:
    int prot_mem;   // protected member
&#125;;

class Sneaky : public Base
&#123;
    friend void clobber(Sneaky&amp;);   // can access Sneaky::prot_mem
    friend void clobber(Base&amp;);     // can&#39;t access Base::prot_mem
    int j;   // j is private by default
&#125;;

// ok: clobber can access the private and protected members in Sneaky objects
void clobber(Sneaky &amp;s) &#123; s.j = s.prot_mem = 0; &#125;
// error: clobber can&#39;t access the protected members in Base
void clobber(Base &amp;b) &#123; b.prot_mem = 0; &#125;
</code></pre>
</li>
<li>基类中成员的访问说明符和派生列表中的访问说明符都会影响某个类对其继承成员的访问权限。</li>
<li>派生访问说明符对于派生类的成员及友元能否访问其直接基类的成员没有影响，对基类成员的访问权限只与基类中的访问说明符有关。</li>
<li>派生访问说明符的作用是控制派生类（包括派生类的派生类）用户对于基类成员的访问权限。<ul>
<li>如果使用公有继承，则基类的公有成员和受保护成员在派生类中属性不发生改变。</li>
<li>如果使用受保护继承，则基类的公有成员和受保护成员在派生类中变为受保护成员。</li>
<li>如果使用私有继承，则基类的公有成员和受保护成员在派生类中变为私有成员。</li>
</ul>
</li>
<li>派生类到基类转换的可访问性（假定D继承自B）：<ul>
<li>只有当D公有地继承B时，用户代码才能使用派生类到基类的转换。</li>
<li>不论D以什么方式继承B，D的成员函数和友元都能使用派生类到基类的转换。</li>
<li>如果D继承B的方式是公有的或者受保护的，则D的派生类的成员函数和友元可以使用D到B的类型转换；反之，如果D继承B的方式是私有的，则不能使用。</li>
</ul>
</li>
<li>对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类到基类的类型转换也是可访问的。</li>
<li>友元对基类的访问权限由基类自身控制，即使对于派生类中的基类部分也是如此。<pre><code>class Base
&#123;
    // added friend declaration; other members as before
    friend class Pal;   // Pal has no access to classes derived from Base
&#125;;

class Pal
&#123;
public:
    int f(Base b) &#123; return b.prot_mem; &#125;     // ok: Pal is a friend of Base
    int f2(Sneaky s) &#123; return s.j; &#125;         // error: Pal not friend of Sneaky
    // access to a base class is controlled by the base class, even inside a derived object
    int f3(Sneaky s) &#123; return s.prot_mem; &#125;  // ok: Pal is a friend
&#125;;
</code></pre>
</li>
<li>友元关系不能继承，每个类负责控制各自成员的访问权限。</li>
<li>使用using声明可以改变派生类继承的某个名字的访问级别。新的访问级别由该using声明之前的访问说明符决定。</li>
<li>派生类只能为那些它可以访问的名字提供using声明。</li>
<li>默认情况下，使用class关键字定义的派生类是私有继承的，而使用struct关键字定义的派生类是公有继承的。</li>
<li>建议显式地声明派生类的继承方式，不要仅仅依赖于默认设置。</li>
</ul>
<h2 id="15-6-继承中的类作用域"><a href="#15-6-继承中的类作用域" class="headerlink" title="15.6 继承中的类作用域"></a>15.6 继承中的类作用域</h2><ul>
<li>当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。</li>
<li>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。</li>
<li>派生类定义的成员会隐藏同名的基类成员。<pre><code>struct Base
&#123;
protected:
    int mem;
&#125;;

struct Derived : Base
&#123;
    int get_mem() &#123; return mem; &#125;   // returns Derived::mem  
protected:
    int mem;    // hides mem in the base
&#125;;
</code></pre>
</li>
<li>可以通过作用域运算符::来使用被隐藏的基类成员。<pre><code>struct Derived : Base
&#123;
    int get_base_mem() &#123; return Base::mem; &#125;
    // ...
&#125;;
</code></pre>
</li>
<li>除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。</li>
<li>和其他函数一样，成员函数无论是否是虚函数都能被重载。</li>
<li>派生类可以覆盖重载函数的0个或多个实例。如果派生类希望所有的重载版本对它来说都是可见的，那么它就需要覆盖所有版本，或者一个也不覆盖。</li>
<li>有时一个类仅需覆盖重载集合中的一些而非全部函数，此时如果我们不得不覆盖基类中的每一个版本的话，操作会极其繁琐。为了简化操作，可以为重载成员提供using声明。using声明指定了一个函数名字但不指定形参列表，所以一条基类成员函数的using声明语句就可以把该函数的所有重载实例添加到派生类作用域中。<pre><code>class Base
&#123;
private:
    int x;
    
public:
    virtual void mf1() = 0;
    virtual void mf1(int);
    virtual void mf2();
    void fm3();
    void fm3(double);
&#125;;

class Derived : public Base
&#123;
public:
    // 让Base内名为mf1和mf3的所有定义
    // 在Derived作用域内可见
    using Base::mf1;
    using Base::mf3;
    virtual void mf1();
    void fm3();
    void fm4();
&#125;;
</code></pre>
</li>
<li>类内使用using声明改变访问级别的规则同样适用于重载函数的名字。</li>
</ul>
<h2 id="15-7-构造函数与拷贝控制"><a href="#15-7-构造函数与拷贝控制" class="headerlink" title="15.7 构造函数与拷贝控制"></a>15.7 构造函数与拷贝控制</h2><h3 id="15-7-1-虚析构函数"><a href="#15-7-1-虚析构函数" class="headerlink" title="15.7.1 虚析构函数"></a>15.7.1 虚析构函数</h3><ul>
<li>一般来说，如果一个类需要析构函数，那么它也需要拷贝和赋值操作。但基类的析构函数不遵循该规则。</li>
<li>基类通常应该定义一个虚析构函数。</li>
<li>如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针会产生未定义的结果。</li>
<li>虚析构函数会阻止编译器为类合成移动操作。</li>
</ul>
<h3 id="15-7-2-合成拷贝控制与继承"><a href="#15-7-2-合成拷贝控制与继承" class="headerlink" title="15.7.2 合成拷贝控制与继承"></a>15.7.2 合成拷贝控制与继承</h3><ul>
<li>对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类直接基类的成员。</li>
<li>在实际编程中，如果基类没有默认、拷贝或移动构造函数，则一般情况下派生类也不会定义相应的操作。</li>
<li>因为基类缺少移动操作会阻止编译器为派生类合成自己的移动操作，所以当我们确实需要执行移动操作时，应该首先在基类中进行定义。</li>
</ul>
<h3 id="15-7-3-派生类的拷贝控制成员"><a href="#15-7-3-派生类的拷贝控制成员" class="headerlink" title="15.7.3 派生类的拷贝控制成员"></a>15.7.3 派生类的拷贝控制成员</h3><ul>
<li>当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类成员在内的整个对象。</li>
<li>当为派生类定义拷贝或移动构造函数时，通常使用对应的基类构造函数初始化对象的基类部分。</li>
<li>在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果想拷贝或移动基类部分，则必须在派生类的构造函数初始化列表中显式地使用基类的拷贝或移动构造函数。</li>
<li>派生类的赋值运算符必须显式地为其基类部分赋值。</li>
<li>派生类的析构函数只负责销毁派生类自己分配的资源。</li>
<li>如果构造函数或析构函数调用了某个虚函数，则应该执行与构造函数或析构函数所属类型相对应的虚函数版本。</li>
</ul>
<h3 id="15-7-4-继承的构造函数"><a href="#15-7-4-继承的构造函数" class="headerlink" title="15.7.4 继承的构造函数"></a>15.7.4 继承的构造函数</h3><ul>
<li>C++11新标准允许派生类重用（非常规方式继承）其直接基类定义的构造函数。继承方式是提供一条注明了直接基类名的using声明语句。</li>
<li>通常情况下，using声明语句只是令某个名字在当前作用域内可见。而作用于构造函数时，using声明将令编译器产生代码。对于基类的每个构造函数，编译器都会生成一个与其形参列表完全相同的派生类构造函数。如果派生类含有自己的数据成员，则这些成员会被默认初始化。</li>
<li>构造函数的using声明不会改变该函数的访问级别，不能指定explicit或constexpr属性。</li>
<li>定义在派生类中的构造函数会替换继承而来的具有相同形参列表的构造函数。</li>
<li>派生类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器会为其合成它们。</li>
<li>当一个基类构造函数含有默认实参时，这些默认值不会被继承。相反，派生类会获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认值的形参</li>
</ul>
<h3 id="15-8-容器和继承"><a href="#15-8-容器和继承" class="headerlink" title="15.8 容器和继承"></a>15.8 容器和继承</h3><ul>
<li>因为容器中不能保存不同类型的元素，所以不能把具有继承关系的多种类型的对象直接存储在容器中。容器不能和存在继承关系的类型兼容。如果想在容器中存储具有继承关系的对象，则应该存放基类的指针。</li>
</ul>
<h1 id="第16章-模板与泛型编程"><a href="#第16章-模板与泛型编程" class="headerlink" title="第16章 模板与泛型编程"></a>第16章 模板与泛型编程</h1><h2 id="16-1-定义模板"><a href="#16-1-定义模板" class="headerlink" title="16.1 定义模板"></a>16.1 定义模板</h2><h3 id="16-1-1-函数模板"><a href="#16-1-1-函数模板" class="headerlink" title="16.1.1 函数模板"></a>16.1.1 函数模板</h3><ul>
<li>函数模板可以用来生成针对特定类型的函数版本。</li>
<li>模板定义以关键字template开始，后跟一个模板参数列表（template parameter list）。模板参数列表以尖括号&lt;&gt;包围，内含用逗号分隔的一个或多个模板参数（template parameter）。<pre><code>template&lt;typename T&gt;
int compare(const T &amp;v1,const T&amp;v2)
&#123;
    if(v1&lt;v2) return -1;
    if(v2&lt;v1) return 1;
    return 0;
&#125;
</code></pre>
</li>
<li>定义模板时，模板参数列表不能为空。</li>
<li>模板参数表示在类或函数定义中用到的类型或值。当使用模板时，需要显式或隐式地指定模板实参（template argument），并将其绑定到模板参数上。</li>
<li>使用函数模板时，编译器用推断出的模板参数来实例化（instantiate）一个特定版本的函数，这些生成的函数通常被称为模板的实例（instantiation）。<pre><code>// instantiates int compare(const int&amp;, const int&amp;)
cout &lt;&lt; compare(1, 0) &lt;&lt; endl;    // T is int
// instantiates int compare(const vector&lt;int&gt;&amp;, const vector&lt;int&gt;&amp;)
vector&lt;int&gt; vec1&#123;1, 2, 3&#125;, vec2&#123;4, 5, 6&#125;;
cout &lt;&lt; compare(vec1, vec2) &lt;&lt; endl;    // T is vector&lt;int&gt;
</code></pre>
</li>
<li>模板类型参数（type parameter）可以用来指定函数的返回类型或参数类型，以及在函数体内用于变量声明和类型转换。类型参数前必须使用关键字class或typename。<pre><code>// ok: same type used for the return type and parameter
template &lt;typename T&gt;
T foo(T* p)
&#123;
    T tmp = *p; // tmp will have the type to which p points
    // ...
    return tmp;
&#125;

// error: must precede U with either typename or class
template &lt;typename T, U&gt; T calc(const T&amp;, const U&amp;);
// ok: no distinction between typename and class in a template parameter list
template &lt;typename T, class U&gt; calc (const T&amp;, const U&amp;);
</code></pre>
</li>
<li>建议使用typename而不是class来指定模板类型参数，这样更加直观。</li>
<li>模板非类型参数（nontype parameter）需要用特定的类型名来指定，表示一个值而非一个类型。非类型参数可以是整型、指向对象或函数类型的指针或左值引用。<pre><code>template&lt;unsigned N, unsigned M&gt;
int compare(const char (&amp;p1)[N], const char (&amp;p2)[M])
&#123;
    return strcmp(p1, p2);
&#125;

int compare(const char (&amp;p1)[3], const char (&amp;p2)[4]);
</code></pre>
</li>
<li>绑定到整型非类型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参必须具有静态的生存期，不能用普通局部变量或动态对象作为指针或引用非类型参数的实参。</li>
<li>函数模板也可以声明为inline或constexpr的，说明符放在模板参数列表之后，返回类型之前。<pre><code>// ok: inline specifier follows the template parameter list
template &lt;typename T&gt; inline T min(const T&amp;, const T&amp;);
// error: incorrect placement of the inline specifier
inline template &lt;typename T&gt; T min(const T&amp;, const T&amp;);
</code></pre>
</li>
<li>模板程序应该尽量减少对实参类型的要求。</li>
<li>只有当模板的一个特定版本被实例化时，编译器才会生成代码。此时编译器需要掌握生成代码所需的信息，因此函数模板和类模板成员函数的定义通常放在头文件中。</li>
<li>使用模板时，所有不依赖于模板参数的名字都必须是可见的，这是由模板的设计者来保证的。模板设计者应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声明。</li>
<li>调用者负责保证传递给模板的实参能正确支持模板所要求的操作。</li>
</ul>
<h3 id="16-1-2-类模板"><a href="#16-1-2-类模板" class="headerlink" title="16.1.2 类模板"></a>16.1.2 类模板</h3><ul>
<li>使用一个类模板时，必须提供显式模板实参（explicit template argument）列表，编译器使用这些模板实参来实例化出特定的类。<pre><code>template &lt;typename T&gt;
class Blob
&#123;
public:
    Blob();
    Blob(std::initializer_list&lt;T&gt; il);
    void push_back(const T &amp;t) &#123; data-&gt;push_back(t); &#125;
    void push_back(T &amp;&amp;t) &#123; data-&gt;push_back(std::move(t)); &#125;
    // ...
    
private:
    std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data;
&#125;;

Blob&lt;int&gt; ia;   // empty Blob&lt;int&gt;
Blob&lt;int&gt; ia2 = &#123; 0, 1, 2, 3, 4 &#125;;    // Blob&lt;int&gt; with five elements
// these definitions instantiate two distinct Blob types
Blob&lt;string&gt; names;     // Blob that holds strings
Blob&lt;double&gt; prices;    // different element type
</code></pre>
</li>
<li>一个类模板的每个实例都形成一个独立的类，相互之间没有关联。</li>
<li>如果一个类模板中的代码使用了另一个模板，通常不会将一个实际类型（或值）的名字用作其模板实参，而是将模板自己的参数用作被使用模板的实参。</li>
<li>类模板的成员函数具有和类模板相同的模板参数，因此定义在类模板外的成员函数必须以关键字template开始，后跟类模板参数列表。<pre><code>template &lt;typename T&gt;
ret-type Blob&lt;T&gt;::member-name(parm-list)
</code></pre>
</li>
<li>默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化。</li>
<li>在类模板自己的作用域内，可以直接使用模板名而不用提供模板实参。<pre><code>template &lt;typename T&gt;
class BlobPtr
&#123;
public:
    // 类模板作用域内不需要写成BlobPtr&lt;T&gt;形式
    BlobPtr&amp; operator++();
&#125;

// 类外定义时需要提供模板实参
template &lt;typename T&gt;
BlobPtr&lt;T&gt;&amp; BlobPtr&lt;T&gt;::operator++()
&#123;
    // 进入类模板作用域
    BlobPtr Ret = *this;
&#125;
</code></pre>
</li>
<li>当一个类包含一个友元声明时，类与友元各自是否是模板并无关联。如果一个类模板包含一个非模板友元，则友元可以访问所有类模板实例。如果友元自身是模板，则类可以给所有友元模板实例授予访问权限，也可以只授权给特定实例。</li>
<li>一对一友元关系:为了引用模板的一个特定实例，必须首先声明模板自身。模板声明包括模板参数列表。<pre><code>// forward declarations needed for friend declarations in Blob
template &lt;typename&gt; class BlobPtr;
template &lt;typename&gt; class Blob;    // needed for parameters in operator==

template &lt;typename T&gt;
bool operator==(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;);

template &lt;typename T&gt;
class Blob
&#123;
    // each instantiation of Blob grants access to the version of
    // BlobPtr and the equality operator instantiated with the same type
    friend class BlobPtr&lt;T&gt;;
    friend bool operator==&lt;T&gt;(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;);
&#125;;
</code></pre>
</li>
<li>通用和特定的模板友元关系:为了让模板的所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。<pre><code>// forward declaration necessary to befriend a specific instantiation of a template
template &lt;typename T&gt; class Pal;

class C
&#123; // C is an ordinary, nontemplate class
    friend class Pal&lt;C&gt;;    // Pal instantiated with class C is a friend to C
    // all instances of Pal2 are friends to C;
    // no forward declaration required when we befriend all instantiations
    template &lt;typename T&gt; friend class Pal2;
&#125;;

template &lt;typename T&gt;
class C2
&#123; // C2 is itself a class template
    // each instantiation of C2 has the same instance of Pal as a friend
    friend class Pal&lt;T&gt;;    // a template declaration for Pal must be in scope
    // all instances of Pal2 are friends of each instance of C2, prior declaration needed
    template &lt;typename X&gt; friend class Pal2;
    // Pal3 is a nontemplate class that is a friend of every instance of C2
    friend class Pal3;      // prior declaration for Pal3 not needed
&#125;;
</code></pre>
</li>
<li>C++11中，类模板可以将模板类型参数声明为友元。<pre><code>template &lt;typename Type&gt;
class Bar
&#123;
    friend Type;   // grants access to the type used to instantiate Bar
    // ...
&#125;;
</code></pre>
</li>
<li>C++11允许使用using为类模板定义类型别名。<pre><code>template&lt;typename T&gt; using twin = pair&lt;T, T&gt;;
twin&lt;string&gt; authors;   // authors is a pair&lt;string, string&gt;
</code></pre>
</li>
<li>类模板可以声明static成员。<pre><code>template &lt;typename T&gt;
class Foo
&#123;
public:
    static std::size_t count() &#123; return ctr; &#125;
    
private:
    static std::size_t ctr;
&#125;;

// instantiates static members Foo&lt;string&gt;::ctr and Foo&lt;string&gt;::count
Foo&lt;string&gt; fs;
// all three objects share the same Foo&lt;int&gt;::ctr and Foo&lt;int&gt;::count members
Foo&lt;int&gt; fi, fi2, fi3;
</code></pre>
</li>
<li>类模板的每个实例都有一个独有的static对象，而每个static成员必须有且只有一个定义。因此与定义模板的成员函数类似，static成员也应该定义成模板。<pre><code>template &lt;typename T&gt;
size_t Foo&lt;T&gt;::ctr = 0;    // define and initialize ctr
</code></pre>
</li>
</ul>
<h3 id="16-1-3-模板参数"><a href="#16-1-3-模板参数" class="headerlink" title="16.1.3 模板参数"></a>16.1.3 模板参数</h3><ul>
<li>模板参数遵循普通的作用域规则。与其他任何名字一样，模板参数会隐藏外层作用域中声明的相同名字。但是在模板内不能重用模板参数名。<pre><code>typedef double A;
template &lt;typename A, typename B&gt;
void f(A a, B b)
&#123;
    A tmp = a;   // tmp has same type as the template parameter A, not double
    double B;    // error: redeclares template parameter B
&#125;
</code></pre>
</li>
<li>由于模板参数名不能重用，所以一个名字在一个特定模板参数列表中只能出现一次。</li>
<li>与函数参数一样，声明中模板参数的名字不必与定义中的相同。</li>
<li>一个特定文件所需要的所有模板声明通常一起放置在文件开始位置，出现在任何使用这些模板的代码之前</li>
<li>模板中的代码使用作用域运算符::时，编译器无法确定其访问的名字是类型还是static成员。</li>
<li>默认情况下，C++假定模板中通过作用域运算符访问的名字是static成员。因此，如果需要使用一个模板类型参数的类型成员，就必须使用关键字typename显式地告知编译器该名字是一个类型。<pre><code>template &lt;typename T&gt;
typename T::value_type top(const T&amp; c)
&#123;
    if (!c.empty())
        return c.back();
    else
        return typename T::value_type();
&#125;
</code></pre>
</li>
<li>C++11允许为函数和类模板提供默认实参。<pre><code>// compare has a default template argument, less&lt;T&gt;
// and a default function argument, F()
template &lt;typename T, typename F = less&lt;T&gt;&gt;
int compare(const T &amp;v1, const T &amp;v2, F f = F())
&#123;
    if (f(v1, v2)) return -1;
    if (f(v2, v1)) return 1;
    return 0;
&#125;
</code></pre>
</li>
<li>如果一个类模板为其所有模板参数都提供了默认实参，在使用这些默认实参时，必须在模板名后面跟一个空尖括号对&lt;&gt;。<pre><code>template &lt;class T = int&gt;
class Numbers
&#123; // by default T is int
public:
    Numbers(T v = 0): val(v) &#123; &#125;
    // various operations on numbers
private:
    T val;
&#125;;

Numbers&lt;long double&gt; lots_of_precision;
Numbers&lt;&gt; average_precision;    // empty &lt;&gt; says we want the default type
</code></pre>
</li>
</ul>
<h3 id="16-1-4-成员模板"><a href="#16-1-4-成员模板" class="headerlink" title="16.1.4 成员模板"></a>16.1.4 成员模板</h3><ul>
<li>一个类（无论是普通类还是模板类）可以包含本身是模板的成员函数，这种成员被称为成员模板。成员模板不能是虚函数。<pre><code>class DebugDelete
&#123;
public:
    DebugDelete(std::ostream &amp;s = std::cerr): os(s) &#123; &#125;
    // as with any function template, the type of T is deduced by the compiler
    template &lt;typename T&gt;
    void operator()(T *p) const
    &#123; 
        os &lt;&lt; &quot;deleting unique_ptr&quot; &lt;&lt; std::endl;
        delete p;
    &#125;
    
private:
    std::ostream &amp;os;
&#125;;
</code></pre>
</li>
<li>在类模板外定义一个成员模板的时候，必须同时为类模板和成员模板参数列表。<pre><code>template &lt;typename T&gt;
class Blob
&#123;
    template &lt;typename It&gt;
    Blob(It b, It e);
&#125;;

template &lt;typename T&gt;   // type parameter for the class
template &lt;typename It&gt;  // type parameter for the constructor
Blob&lt;T&gt;::Blob(It b, It e):
    data(std::make_shared&lt;std::vector&lt;T&gt;&gt;(b, e))
    &#123; &#125;
</code></pre>
</li>
<li>为了实例化一个类模板的成员模板，必须同时提供类和函数模板的实参。</li>
</ul>
<h3 id="16-1-5-控制实例化"><a href="#16-1-5-控制实例化" class="headerlink" title="16.1.5 控制实例化"></a>16.1.5 控制实例化</h3><ul>
<li>因为模板在使用时才会进行实例化，所以相同的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中都会有该模板的一个实例。</li>
<li>在大型程序中，多个文件实例化相同模板的额外开销可能非常严重。C++11允许通过显式实例化（explicit instantiation）来避免这种开销。<pre><code>extern template declaration;    // instantiation declaration
template declaration;           // instantiation definition
</code></pre>
</li>
<li>declaration是一个类或函数声明，其中所有模板参数已被替换为模板实参。当编译器遇到extern模板声明时，它不会在本文件中生成实例化代码。对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。<pre><code>// templateBuild.cc
// instantiation file must provide a (nonextern) definition for every
// type and function that other files declare as extern
template int compare(const int&amp;, const int&amp;);
template class Blob&lt;string&gt;;    // instantiates all members of the class template

// Application.cc
// these template types must be instantiated elsewhere in the program
extern template class Blob&lt;string&gt;;
extern template int compare(const int&amp;, const int&amp;);
Blob&lt;string&gt; sa1, sa2;    // instantiation will appear elsewhere
// Blob&lt;int&gt; and its initializer_list constructor instantiated in this file
Blob&lt;int&gt; a1 = &#123; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;;
Blob&lt;int&gt; a2(a1);    // copy constructor instantiated in this file
int i = compare(a1[0], a2[0]);    // instantiation will appear elsewhere
</code></pre>
</li>
<li>当编译器遇到类模板的实例化定义时，它不清楚程序会使用哪些成员函数。和处理类模板的普通实例化不同，编译器会实例化该模板的所有成员，包括内联的成员函数。因此，用来显式实例化类模板的类型必须能用于模板的所有成员。</li>
</ul>
<h3 id="16-1-6-效率与灵活性"><a href="#16-1-6-效率与灵活性" class="headerlink" title="16.1.6 效率与灵活性"></a>16.1.6 效率与灵活性</h3><ul>
<li>unique_ptr在编译时绑定删除器，避免了间接调用删除器的运行时开销。shared_ptr在运行时绑定删除器，使用户重载删除器的操作更加简便。</li>
</ul>
<h2 id="16-2-模板实参推断"><a href="#16-2-模板实参推断" class="headerlink" title="16.2 模板实参推断"></a>16.2 模板实参推断</h2><ul>
<li>对于函数模板，编译器通过调用的函数实参来确定其模板参数。这个过程被称作<strong>模板实参推断</strong>。</li>
</ul>
<h3 id="16-2-1-类型转换与模板类型参数"><a href="#16-2-1-类型转换与模板类型参数" class="headerlink" title="16.2.1 类型转换与模板类型参数"></a>16.2.1 类型转换与模板类型参数</h3><ul>
<li>与非模板函数一样，调用函数模板时传递的实参被用来初始化函数的形参。如果一个函数形参的类型使用了模板类型参数，则会采用特殊的初始化规则，只有有限的几种类型转换会自动地应用于这些实参。编译器通常会生成新的模板实例而不是对实参进行类型转换。</li>
<li>有3种类型转换可以在调用中应用于函数模板：<ul>
<li>顶层const会被忽略。</li>
<li>可以将一个非const对象的引用或指针传递给一个const引用或指针形参。</li>
<li>如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。数组实参可以转换为指向其首元素的指针。函数实参可以转换为该函数类型的指针。</li>
</ul>
</li>
<li>其他的类型转换，如算术转换、派生类向基类的转换以及用户定义的转换，都不能应用于函数模板。</li>
<li>一个模板类型参数可以作为多个函数形参的类型。由于允许的类型转换有限，因此传递给这些形参的实参必须具有相同的类型，否则调用失败。</li>
<li>如果想增强函数的兼容性，可以使用两个类型参数定义函数模板。<pre><code>// argument types can differ but must be compatible
template &lt;typename A, typename B&gt;
int flexibleCompare(const A&amp; v1, const B&amp; v2)
&#123;
    if (v1 &lt; v2) return -1;
    if (v2 &lt; v1) return 1;
    return 0;
&#125;

long lng;
flexibleCompare(lng, 1024);   // ok: calls flexibleCompare(long, int)
</code></pre>
</li>
<li>函数模板中使用普通类型定义的参数可以进行正常的类型转换.<pre><code>template &lt;typename T&gt;
ostream &amp;print(ostream &amp;os, const T &amp;obj)
&#123;
    return os &lt;&lt; obj;
&#125;

print(cout, 42);   // instantiates print(ostream&amp;, int)
ofstream f(&quot;output&quot;);
print(f, 10);      // uses print(ostream&amp;, int); converts f to ostream&amp;
</code></pre>
</li>
</ul>
<h3 id="16-2-2-函数模板显示实参"><a href="#16-2-2-函数模板显示实参" class="headerlink" title="16.2.2 函数模板显示实参"></a>16.2.2 函数模板显示实参</h3><ul>
<li>某些情况下，编译器无法推断出模板实参的类型。<pre><code>// T1 cannot be deduced: it doesn&#39;t appear in the function parameter list
template &lt;typename T1, typename T2, typename T3&gt;
T1 sum(T2, T3);
</code></pre>
</li>
<li>显式模板实参（explicit template argument）可以让用户自己控制模板的实例化。提供显式模板实参的方式与定义类模板实例的方式相同。显式模板实参在尖括号&lt;&gt;中指定，位于函数名之后，实参列表之前。<pre><code>// T1 is explicitly specified; T2 and T3 are inferred from the argument types
auto val3 = sum&lt;long long&gt;(i, lng);   // long long sum(int, long)
</code></pre>
</li>
<li>显式模板实参按照从左到右的顺序与对应的模板参数匹配，只有尾部参数的显式模板实参才可以忽略，而且前提是它们可以从函数参数推断出来。<pre><code>// poor design: users must explicitly specify all three template parameters
template &lt;typename T1, typename T2, typename T3&gt;
T3 alternative_sum(T2, T1);
// error: can&#39;t infer initial template parameters
auto val3 = alternative_sum&lt;long long&gt;(i, lng);
// ok: all three parameters are explicitly specified
auto val2 = alternative_sum&lt;long long, int, long&gt;(i, lng);
</code></pre>
</li>
<li>对于模板类型参数已经显式指定了的函数实参，可以进行正常的类型转换。<pre><code>long lng;
compare(lng, 1024);         // error: template parameters don&#39;t match
compare&lt;long&gt;(lng, 1024);   // ok: instantiates compare(long, long)
compare&lt;int&gt;(lng, 1024);    // ok: instantiates compare(int, int)
</code></pre>
</li>
</ul>
<h3 id="16-2-3-尾置返回类型与类型转换"><a href="#16-2-3-尾置返回类型与类型转换" class="headerlink" title="16.2.3 尾置返回类型与类型转换"></a>16.2.3 尾置返回类型与类型转换</h3><ul>
<li>由于尾置返回出现在函数列表之后，因此它可以使用函数参数来声明返回类型。<pre><code>// a trailing return lets us declare the return type after the parameter list is seen
template &lt;typename It&gt;
auto fcn(It beg, It end) -&gt; decltype(*beg)
&#123;
    // process the range
    return *beg;   // return a reference to an element from the range
&#125;
</code></pre>
</li>
<li>标准库在头文件type_traits中定义了类型转换模板，这些模板常用于模板元程序设计。其中每个模板都有一个名为type的公有类型成员，表示一个类型。此类型与模板自身的模板类型参数相关。如果不可能（或不必要）转换模板参数，则type成员就是模板参数类型本身。<img src="/2020/01/09/c/c-primer/%E8%A1%A816.1.png" class="" title="表16.1.png">)</li>
<li>使用remove_reference可以获得引用对象的元素类型，如果用一个引用类型实例化remove_reference，则type表示被引用的类型。因为type是一个类的类型成员，所以在模板中必须使用关键字typename来告知编译器其表示一个类型。<pre><code>// must use typename to use a type member of a template parameter
template &lt;typename It&gt;
auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;::type
&#123;
    // process the range
    return *beg;  // return a copy of an element from the range
&#125;
</code></pre>
</li>
</ul>
<h3 id="16-2-4-函数指针和实参推断"><a href="#16-2-4-函数指针和实参推断" class="headerlink" title="16.2.4 函数指针和实参推断"></a>16.2.4 函数指针和实参推断</h3><ul>
<li>使用函数模板初始化函数指针或为函数指针赋值时，编译器用指针的类型来推断模板实参。<pre><code>template &lt;typename T&gt; int compare(const T&amp;, const T&amp;);
// pf1 points to the instantiation int compare(const int&amp;, const int&amp;)
int (*pf1)(const int&amp;, const int&amp;) = compare;
</code></pre>
</li>
</ul>
<h3 id="16-2-5-模板实参推断和引用"><a href="#16-2-5-模板实参推断和引用" class="headerlink" title="16.2.5 模板实参推断和引用"></a>16.2.5 模板实参推断和引用</h3><ul>
<li>当一个函数参数是模板类型参数的普通（左值）引用（形如T&amp;）时，只能传递给它一个左值（如一个变量或一个返回引用类型的表达式）。T被推断为实参所引用的类型，如果实参是const的，则T也为const类型。<pre><code>template &lt;typename T&gt; void f1(T&amp;);    // argument must be an lvalue
// calls to f1 use the referred-to type of the argument as the template parameter type
f1(i);     // i is an int; template parameter T is int
f1(ci);    // ci is a const int; template parameter T is const int
f1(5);     // error: argument to a &amp; parameter must be an lvalue
</code></pre>
</li>
<li>当一个函数参数是模板类型参数的常量引用（形如const T&amp;）时，可以传递给它任何类型的实参。函数参数本身是const时，T的类型推断结果不会是const类型。const已经是函数参数类型的一部分了，因此不会再是模板参数类型的一部分。<pre><code>template &lt;typename T&gt; void f2(const T&amp;);    // can take an rvalue
// parameter in f2 is const &amp;; const in the argument is irrelevant
// in each of these three calls, f2&#39;s function parameter is inferred as const int&amp;
f2(i);     // i is an int; template parameter T is int
f2(ci);    // ci is a const int, but template parameter T is int
f2(5);     // a const &amp; parameter can be bound to an rvalue; T is int
</code></pre>
</li>
<li>当一个函数参数是模板类型参数的右值引用（形如T&amp;&amp;）时，如果传递给它一个右值，类型推断过程类似普通左值引用函数参数的推断过程，推断出的T类型是该右值实参的类型。<pre><code>template &lt;typename T&gt; void f3(T&amp;&amp;);
f3(42);    // argument is an rvalue of type int; template parameter T is int
</code></pre>
</li>
<li>模板参数绑定的两个例外规则：<ul>
<li>如果将一个左值传递给函数的右值引用参数，且此右值引用指向模板类型参数时，编译器推断模板类型参数为实参的左值引用类型。</li>
<li>如果间接创建了一个引用的引用（通过类型别名或者模板类型参数间接定义），则这些引用会被“折叠”。右值引用的右值引用会被折叠为右值引用。其他情况下，引用都被折叠为普通左值引用。</li>
</ul>
</li>
<li>模板参数绑定的两个例外规则导致了两个结果：<ul>
<li>如果一个函数参数是指向模板类型参数的右值引用，则可以传递给它任意类型的实参。</li>
<li>如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用。</li>
</ul>
</li>
<li>当代码中涉及的类型可能是普通（非引用）类型，也可能是引用类型时，编写正确的代码就变得异常困难。</li>
<li>实际编程中，模板的右值引用参数通常用于两种情况：模板转发其实参或者模板被重载。函数模板的常用重载形式如下：<pre><code>template &lt;typename T&gt; void f(T&amp;&amp;);         // binds to nonconst rvalues
template &lt;typename T&gt; void f(const T&amp;);    // lvalues and const rvalues
</code></pre>
</li>
</ul>
<h3 id="16-2-6-理解std-move"><a href="#16-2-6-理解std-move" class="headerlink" title="16.2.6 理解std::move"></a>16.2.6 理解std::move</h3><ul>
<li>std::move的定义如下：<pre><code>template &lt;typename T&gt;
typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; t)
&#123;
    return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);
&#125;
</code></pre>
</li>
<li>std::move的工作过程：<pre><code>string s1(&quot;hi!&quot;), s2;
s2 = std::move(string(&quot;bye!&quot;));     // ok: moving from an rvalue
s2 = std::move(s1);     // ok: but after the assigment s1 has indeterminate value
</code></pre>
</li>
<li>在std::move(string(“bye!”))中传递的是右值。<ul>
<li>推断出的T类型为string。</li>
<li>remove_reference用string进行实例化。</li>
<li>remove_reference<string>的type成员是string。</li>
<li>move的返回类型是string&amp;&amp;。</li>
<li>move的函数参数t的类型为string&amp;&amp;。</li>
</ul>
</li>
<li>在std::move(s1)中传递的是左值。<ul>
<li>推断出的T类型为string&amp;。</li>
<li>remove_reference用string&amp;进行实例化。</li>
<li>remove_reference&lt;string&amp;&gt;的type成员是string。</li>
<li>move的返回类型是string&amp;&amp;。</li>
<li>move的函数参数t的类型为string&amp; &amp;&amp;，会折叠成string&amp;。</li>
</ul>
</li>
<li>可以使用static_cast显式地将一个左值转换为一个右值引用。</li>
</ul>
<h3 id="16-2-7-转发"><a href="#16-2-7-转发" class="headerlink" title="16.2.7 转发"></a>16.2.7 转发</h3><ul>
<li>某些函数需要将其一个或多个实参连同类型不变地转发给其他函数。在这种情况下，需要保持被转发实参的所有性质，包括实参的const属性以及左值&#x2F;右值属性。<pre><code>// template that takes a callable and two parameters
// and calls the given callable with the parameters &#39;&#39;flipped&#39;&#39;
// flip1 is an incomplete implementation: top-level const and references are lost
template &lt;typename F, typename T1, typename T2&gt;
void flip1(F f, T1 t1, T2 t2)
&#123;
    f(t2, t1);
&#125;

void f(int v1, int &amp;v2)   // note v2 is a reference
&#123;
    cout &lt;&lt; v1 &lt;&lt; &quot; &quot; &lt;&lt; ++v2 &lt;&lt; endl;
&#125;

f(42, i);   // f changes its argument i
flip1(f, j, 42);    // f called through flip1 leaves j unchanged
                    // void flip1(void(*fcn)(int, int&amp;), int t1, int t2)
</code></pre>
</li>
<li>上例中，j被传递给flip1的参数t1，该参数是一个普通（非引用）类型int，而非int&amp;，因此flip1(f, j, 42)调用会被实例化为void flip1(void(*fcn)(int, int&amp;), int t1, int t2)。j的值被拷贝至t1中，f中的引用参数被绑定至t1，而非j，因此j不会被修改。</li>
<li>将函数参数定义为指向模板类型参数的右值引用（形如T&amp;&amp;），通过引用折叠，可以保持翻转实参的左值&#x2F;右值属性。并且引用参数（无论是左值还是右值）可以保持实参的const属性，因为在引用类型中的const是底层的。<pre><code>template &lt;typename F, typename T1, typename T2&gt;
void flip2(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)
&#123;
    f(t2, t1);
&#125;
</code></pre>
</li>
<li>对于修改后的版本，若调用flip2(f, j, 42)，会传递给参数t1一个左值j，但此时推断出的T1类型为int&amp;，t1的类型会被折叠为int&amp;，从而解决了flip1的错误。</li>
<li>但flip2只能用于接受左值引用的函数，不能用于接受右值引用的函数。函数参数与其他变量一样，都是左值表达式。所以即使是指向模板类型的右值引用参数也只能传递给接受左值引用的函数，不能传递给接受右值引用的函数。<pre><code>void g(int &amp;&amp;i, int&amp; j)
&#123;
    cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;
&#125;

// error: can&#39;t initialize int&amp;&amp; from an lvalue
flip2(g, i, 42);  // flip2 passes an lvalue to g’s rvalue reference parameter
</code></pre>
</li>
<li>C++11在头文件utility中定义了forward。与move不同，forward必须通过显式模板实参调用，返回该显式实参类型的右值引用。即forward<T>返回类型T&amp;&amp;。</li>
<li>通常情况下，可以使用forward传递定义为指向模板类型参数的右值引用函数参数。通过其返回类型上的引用折叠，forward可以保持给定实参的左值&#x2F;右值属性<pre><code>template &lt;typename Type&gt;
intermediary(Type &amp;&amp;arg)
&#123;
    finalFcn(std::forward&lt;Type&gt;(arg));
    // ...
&#125;
</code></pre>
<ul>
<li>如果实参是一个右值，则Type是一个普通（非引用）类型，forward<Type>返回类型Type&amp;&amp;。</li>
<li>如果实参是一个左值，则通过引用折叠，Type也是一个左值引用类型，forward<Type>返回类型Type&amp;&amp; &amp;，对返回 类型进行引用折叠，得到Type&amp;。</li>
</ul>
</li>
<li>使用forward编写完善的转发函数。<pre><code>template &lt;typename F, typename T1, typename T2&gt;
void flip(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)
&#123;
    f(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));
&#125;
</code></pre>
</li>
<li>与std::move一样，对std::forward也不应该使用using声明。</li>
</ul>
<h2 id="16-3-重载与模板"><a href="#16-3-重载与模板" class="headerlink" title="16.3 重载与模板"></a>16.3 重载与模板</h2><ul>
<li>函数模板可以被另一个模板或普通非模板函数重载。</li>
<li>如果重载涉及函数模板，则函数匹配规则会受到一些影响：<ul>
<li>对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例。</li>
<li>候选的函数模板都是可行的，因为模板实参推断会排除任何不可行的模板。</li>
<li>和往常一样，可行函数（模板与非模板）按照类型转换（如果需要的话）来排序。但是可以用于函数模板调用的类型转换非常有限。</li>
<li>和往常一样，如果恰有一个函数提供比其他任何函数都更好的匹配，则选择此函数。但是如果多个函数都提供相同级别的匹配，则：<ul>
<li>如果同级别的函数中只有一个是非模板函数，则选择此函数。</li>
<li>如果同级别的函数中没有非模板函数，而有多个函数模板，且其中一个模板比其他模板更特例化，则选择此模板。</li>
<li>否则该调用有歧义。</li>
</ul>
</li>
</ul>
</li>
<li>通常，如果使用了一个没有声明的函数，代码将无法编译。但对于重载函数模板的函数而言，如果编译器可以从模板实例化出与调用匹配的版本，则缺少的声明就不再重要了。<pre><code>template &lt;typename T&gt; string debug_rep(const T &amp;t);
template &lt;typename T&gt; string debug_rep(T *p);
// the following declaration must be in scope
// for the definition of debug_rep(char*) to do the right thing
string debug_rep(const string &amp;);
string debug_rep(char *p)
&#123;
    // if the declaration for the version that takes a const string&amp; is not in scope
    // the return will call debug_rep(const T&amp;) with T instantiated to string
    return debug_rep(string(p));
&#125;
</code></pre>
</li>
<li>在定义任何函数之前，应该声明所有重载的函数版本。这样编译器就不会因为未遇到你希望调用的函数而实例化一个并非你所需要的版本。</li>
</ul>
<h2 id="16-4-可变参数模板"><a href="#16-4-可变参数模板" class="headerlink" title="16.4 可变参数模板"></a>16.4 可变参数模板</h2><ul>
<li>可变参数模板指可以接受可变数量参数的模板函数或模板类。可变数量的参数被称为参数包（parameter pack），分为两种：<ul>
<li>模板参数包（template parameter pack），表示零个或多个模板参数。</li>
<li>函数参数包（function parameter pack），表示零个或多个函数参数。</li>
</ul>
</li>
<li>用一个省略号…来指出模板参数或函数参数表示一个包。在一个模板参数列表中，class…或typename…指出接下来的参数表示零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数列表。在函数参数列表中，如果一个参数的类型是模板参数包，则此参数也是函数参数包。<pre><code>// Args is a template parameter pack; rest is a function parameter pack
// Args represents zero or more template type parameters
// rest represents zero or more function parameters
template &lt;typename T, typename... Args&gt;
void foo(const T &amp;t, const Args&amp; ... rest);
</code></pre>
</li>
<li>对于一个可变参数模板，编译器会推断模板参数类型和参数数量</li>
<li>可以使用sizeof…运算符获取参数包中的元素数量。类似sizeof，sizeof…也返回一个常量表达式，而且不会对其实参求值。<pre><code>template&lt;typename ... Args&gt;
void g(Args ... args)
&#123;
    cout &lt;&lt; sizeof...(Args) &lt;&lt; endl;    // number of type parameters
    cout &lt;&lt; sizeof...(args) &lt;&lt; endl;    // number of function parameters
&#125;
</code></pre>
</li>
</ul>
<h3 id="16-4-1-编写可变参数函数模板"><a href="#16-4-1-编写可变参数函数模板" class="headerlink" title="16.4.1 编写可变参数函数模板"></a>16.4.1 编写可变参数函数模板</h3><ul>
<li>可变参数函数通常是递归的，第一步调用参数包中的第一个实参，然后用剩余实参调用自身。为了终止递归，还需要定义一个非可变参数的函数。<pre><code>// function to end the recursion and print the last element
// this function must be declared before the variadic version of print is defined
template&lt;typename T&gt;
ostream &amp;print(ostream &amp;os, const T &amp;t)
&#123;
    return os &lt;&lt; t;   // no separator after the last element in the pack
&#125;

// this version of print will be called for all but the last element in the pack
template &lt;typename T, typename... Args&gt;
ostream &amp;print(ostream &amp;os, const T &amp;t, const Args&amp;... rest)
&#123;
    os &lt;&lt; t &lt;&lt; &quot;, &quot;;    // print the first argument
    return print(os, rest...);   // recursive call; print the other arguments
&#125;
</code></pre>
</li>
</ul>
<h3 id="16-4-2-包扩展"><a href="#16-4-2-包扩展" class="headerlink" title="16.4.2 包扩展"></a>16.4.2 包扩展</h3><ul>
<li>对于一个参数包，除了获取其大小外，唯一能对它做的事情就是扩展。当扩展一个包时，需要提供用于每个扩展元素的模式（pattern）。扩展一个包就是将其分解为构成的元素，对每个元素应用模式，获得扩展后的列表。通过在模式右边添加一个省略号…来触发扩展操作。<pre><code>template &lt;typename T, typename... Args&gt;
ostream&amp; print(ostream &amp;os, const T &amp;t, const Args&amp;... rest)   // expand Args
&#123;
    os &lt;&lt; t &lt;&lt; &quot;, &quot;;
    return print(os, rest...);   // expand rest
&#125;
</code></pre>
<ul>
<li>第一个扩展操作扩展模板参数包，为print生成函数参数列表。编译器将模式const Args&amp;应用到模板参数包Args中的每个元素上。因此该模式的扩展结果是一个以逗号分隔的零个或多个类型的列表，每个类型都形如const type&amp;。</li>
</ul>
<pre><code>print(cout, i, s, 42);   // two parameters in the pack
ostream&amp; print(ostream&amp;, const int&amp;, const string&amp;, const int&amp;);
</code></pre>
<ul>
<li>第二个扩展操作扩展函数参数包，模式是函数参数包的名字。扩展结果是一个由包中元素组成、以逗号分隔的列表。</li>
</ul>
<p>  <code>print(os, s, 42);</code></p>
</li>
<li>扩展操作中的模式会独立地应用于包中的每个元素。<pre><code>// call debug_rep on each argument in the call to print
template &lt;typename... Args&gt;
ostream &amp;errorMsg(ostream &amp;os, const Args&amp;... rest)
&#123;
    // print(os, debug_rep(a1), debug_rep(a2), ..., debug_rep(an)
    return print(os, debug_rep(rest)...);
&#125;

// passes the pack to debug_rep; print(os, debug_rep(a1, a2, ..., an))
print(os, debug_rep(rest...));   // error: no matching function to call
</code></pre>
</li>
</ul>
<h3 id="16-4-3-转发参数包（Forwarding-Parameter-Packs）"><a href="#16-4-3-转发参数包（Forwarding-Parameter-Packs）" class="headerlink" title="16.4.3 转发参数包（Forwarding Parameter Packs）"></a>16.4.3 转发参数包（Forwarding Parameter Packs）</h3><ul>
<li>在C++11中，可以组合使用可变参数模板和forward机制来编写函数，实现将其实参不变地传递给其他函数。<pre><code>// fun has zero or more parameters each of which is
// an rvalue reference to a template parameter type
template&lt;typename... Args&gt;
void fun(Args&amp;&amp;... args)    // expands Args as a list of rvalue references
&#123;
    // the argument to work expands both Args and args
    work(std::forward&lt;Args&gt;(args)...);
&#125;
</code></pre>
</li>
</ul>
<h2 id="16-5-模板特例化"><a href="#16-5-模板特例化" class="headerlink" title="16.5 模板特例化"></a>16.5 模板特例化</h2><ul>
<li>在某些情况下，通用模板的定义对特定类型是不合适的，可能编译失败或者操作不正确。如果不希望或不能使用模板版本时，可以定义类或函数模板的特例化版本。一个特例化版本就是模板的一个独立定义，其中的一个或多个模板参数被指定为特定类型。<pre><code>// first version; can compare any two types
template &lt;typename T&gt; int compare(const T&amp;, const T&amp;);
// second version to handle string literals
template&lt;size_t N, size_t M&gt;
int compare(const char (&amp;)[N], const char (&amp;)[M]);

const char *p1 = &quot;hi&quot;, *p2 = &quot;mom&quot;;
compare(p1, p2);        // calls the first template
compare(&quot;hi&quot;, &quot;mom&quot;);   // calls the template with two nontype parameters

// special version of compare to handle pointers to character arrays
template &lt;&gt;
int compare(const char* const &amp;p1, const char* const &amp;p2)
&#123;
    return strcmp(p1, p2);
&#125;
</code></pre>
</li>
<li>特例化一个函数模板时，必须为模板中的每个模板参数都提供实参。为了指明我们正在实例化一个模板，应该在关键字template后面添加一个空尖括号对&lt;&gt;。</li>
<li>特例化版本的参数类型必须与一个先前声明的模板中对应的类型相匹配。</li>
<li>定义特例化函数版本本质上是接管编译器的工作，为模板的一个特殊实例提供了定义。特例化并非重载，因此不影响函数匹配。</li>
<li>将一个特殊版本的函数定义为特例化模板还是独立的非模板函数会影响到重载函数匹配。</li>
<li>模板特例化遵循普通作用域规则。为了特例化一个模板，原模板的声明必须在作用域中。而使用模板实例时，也必须先包含特例化版本的声明。</li>
<li>通常，模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明放在文件开头，后面是这些模板的特例化版本。</li>
<li>类模板也可以特例化。与函数模板不同，类模板的特例化不必为所有模板参数提供实参，可以只指定一部分模板参数。一个类模板的部分特例化（partial specialization）版本本身还是一个模板，用户使用时必须为那些未指定的模板参数提供实参。</li>
<li>只能部分特例化类模板，不能部分特例化函数模板。</li>
<li>由于类模板的部分特例化版本是一个模板，所以需要定义模板参数。对于每个未完全确定类型的模板参数，在特例化版本的模板参数列表中都有一项与之对应。在类名之后，需要为特例化的模板参数指定实参，这些实参位于模板名之后的尖括号中，与原始模板中的参数按位置相对应。<pre><code>// 通用版本
template &lt;typename T&gt;
struct remove_reference
&#123;
    typedef T type;
&#125;;

// 部分特例化版本
template &lt;typename T&gt;
struct remove_reference&lt;T &amp;&gt;   // 左值引用
&#123;
    typedef T type;
&#125;;

template &lt;typename T&gt;
struct remove_reference&lt;T &amp;&amp;&gt;  // 右值引用
&#123;
    typedef T type;
&#125;;
</code></pre>
</li>
<li>类模板部分特例化版本的模板参数列表是原始模板参数列表的一个子集或特例化版本。</li>
<li>可以只特例化类模板的指定成员函数，而不用特例化整个模板。<pre><code>template &lt;typename T&gt;
struct Foo
&#123;
    Foo(const T &amp;t = T()): mem(t) &#123; &#125;
    void Bar() &#123; /* ... */ &#125;
    T mem;
    // other members of Foo
&#125;;

template&lt;&gt;      // we&#39;re specializing a template
void Foo&lt;int&gt;::Bar()    // we&#39;re specializing the Bar member of Foo&lt;int&gt;
&#123;
    // do whatever specialized processing that applies to ints
&#125;

Foo&lt;string&gt; fs;     // instantiates Foo&lt;string&gt;::Foo()
fs.Bar();    // instantiates Foo&lt;string&gt;::Bar()
Foo&lt;int&gt; fi;    // instantiates Foo&lt;int&gt;::Foo()
fi.Bar();    // uses our specialization of Foo&lt;int&gt;::Bar()
</code></pre>
</li>
</ul>
<h1 id="第17章-标准库特殊设施"><a href="#第17章-标准库特殊设施" class="headerlink" title="第17章 标准库特殊设施"></a>第17章 标准库特殊设施</h1><h2 id="17-1-tuple类型"><a href="#17-1-tuple类型" class="headerlink" title="17.1 tuple类型"></a>17.1 tuple类型</h2><ul>
<li>tuple是类似pair的模板，定义在头文件tuple中。与pair不同，tuple可以有任意数量的成员。如果希望将一些数据组合成单一对象，但又不想定义新数据结构时，可以使用tuple（“快速而随意”的数据结构）。<img src="/2020/01/09/c/c-primer/%E8%A1%A817.1.png" class="" title="表17.1.png">)</li>
</ul>
<h3 id="17-1-1-定义和初始化tuple（Defining-and-Initializing-tuples）"><a href="#17-1-1-定义和初始化tuple（Defining-and-Initializing-tuples）" class="headerlink" title="17.1.1 定义和初始化tuple（Defining and Initializing tuples）"></a>17.1.1 定义和初始化tuple（Defining and Initializing tuples）</h3><ul>
<li>定义tuple时需要指定每个成员的类型。创建tuple对象时，可以使用tuple的默认构造函数，它会对每个成员进行值初始化。或者给每个成员提供初始值。包含初始值的构造函数是explicit的，因此必须使用直接初始化语法。<pre><code>tuple&lt;size_t, size_t, size_t&gt; threeD = &#123; 1, 2, 3 &#125;;   // error
tuple&lt;size_t, size_t, size_t&gt; threeD&#123; 1, 2, 3 &#125;;      // ok
</code></pre>
</li>
<li>类似make_pair，make_tuple函数可以生成tuple对象。tuple的类型由初始值决定。</li>
<li>可以使用get访问tuple的成员。get是一个函数模板，使用时必须指定一个显式模板实参，表示要访问的成员索引。传递给get一个tuple实参后，会返回其指定成员的引用。<pre><code>auto book = get&lt;0&gt;(item);    // returns the first member of item
auto cnt = get&lt;1&gt;(item);     // returns the second member of item
auto price = get&lt;2&gt;(item)/cnt;    // returns the last member of item
get&lt;2&gt;(item) *= 0.8;    // apply 20% discount
</code></pre>
</li>
<li>可以使用tuple_size和tuple_element这两个辅助类模板查询tuple成员的数量和类型。<ul>
<li>tuple_size通过一个tuple类型来初始化，它有一个名为value的静态公有数据成员，类型为size_t，表示给定tuple中成员的数量。</li>
<li>tuple_element通过一个索引值（整型常量）和一个tuple类型来初始化，它有一个名为type的公有数据成员，表示给定tuple中指定成员的类型。</li>
<li>使用decltype可以确定一个对象的类型。</li>
</ul>
<pre><code>typedef decltype(item) trans;    // trans is the type of item
// returns the number of members in object&#39;s of type trans
size_t sz = tuple_size&lt;trans&gt;::value;    // returns 3
// cnt has the same type as the second member in item
tuple_element&lt;1, trans&gt;::type cnt = get&lt;1&gt;(item);    // cnt is an int
</code></pre>
</li>
<li>tuple的关系和相等运算符逐对比较两个tuple对象的成员。只有当两个tuple的成员数量相等时才可以进行比较。使用tuple的相等或不等运算符时，每对成员必须支持&#x3D;&#x3D;运算符；使用tuple的关系运算符时，每对成员必须支持&lt;运算符。</li>
<li>由于tuple定义了&lt;和&#x3D;&#x3D;运算符，因此tuple序列可以被传递给算法，无序容器的关键字也可以使用tuple类型。</li>
</ul>
<h3 id="17-1-2-使用tuple返回多个值"><a href="#17-1-2-使用tuple返回多个值" class="headerlink" title="17.1.2 使用tuple返回多个值"></a>17.1.2 使用tuple返回多个值</h3><ul>
<li>tuple的一个常见用途是从一个函数返回多个值。</li>
</ul>
<h2 id="17-2-bitset类型"><a href="#17-2-bitset类型" class="headerlink" title="17.2 bitset类型"></a>17.2 bitset类型</h2><h3 id="17-2-1-定义和初始化bitset"><a href="#17-2-1-定义和初始化bitset" class="headerlink" title="17.2.1 定义和初始化bitset"></a>17.2.1 定义和初始化bitset</h3><ul>
<li>itset类是一个模板，类似array，具有固定的大小。定义一个bitset时需要指明它包含的二进制位数。  <img src="/2020/01/09/c/c-primer/%E8%A1%A817.2.png" class="" title="表17.2.png">)</li>
<li>使用一个整型值初始化bitset时，此值会被转换为unsigned long long类型并被当作位模式处理。bitset中的二进制位就是此模式的副本。如果bitset的大小大于unsigned long long中的二进制位数，剩余的高位会被置为0。如果bitset的大小小于unsigned long long中的二进制位数，则只使用给定值的低位部分。</li>
<li>可以使用string或字符数组指针来初始化bitset，字符直接表示位模式。使用字符串表示数时，字符串中下标最小的字符对应bitset的高位。如果string包含的字符数比bitset少，则bitset的高位被置为0。</li>
</ul>
<h3 id="17-2-2-bitset操作"><a href="#17-2-2-bitset操作" class="headerlink" title="17.2.2 bitset操作"></a>17.2.2 bitset操作</h3><ul>
<li>bitset操作：  <img src="/2020/01/09/c/c-primer/%E8%A1%A817.3.png" class="" title="表17.3.png">)</li>
<li>bitset的下标运算符对const属性进行了重载。const版本的下标运算符在指定位置置位时返回true，否则返回false。非const版本返回bitset定义的一个特殊类型，用来控制指定位置的值。</li>
<li>to_ulong和to_ullong操作用来提取bitset的值。只有当bitset的大小不大于对应操作的返回值（to_ulong为unsigned long，to_ullong为unsigned long long）时，才能使用这两个操作。如果bitset中的值不能存入给定类型，则会引发overflow_error异常。</li>
<li>bitset的输入运算符从输入流读取字符，保存到临时的string对象中。遇到下列情况时停止读取：<ul>
<li>读取的字符数达到对应bitset的大小。</li>
<li>遇到不是1和0的字符。</li>
<li>遇到文件结尾。</li>
<li>输入出现错误。</li>
</ul>
</li>
<li>读取结束后用临时string对象初始化bitset。如果读取的字符数小于bitset的大小，则bitset的高位被置为0。</li>
</ul>
<h2 id="17-3-正则表达式"><a href="#17-3-正则表达式" class="headerlink" title="17.3 正则表达式"></a>17.3 正则表达式</h2><ul>
<li>正则表达式是一种描述字符序列的方法。C++11新标准增加了正则表达式库（RE库），定义在头文件regex中，包含多个组件。  <img src="/2020/01/09/c/c-primer/%E8%A1%A817.4.png" class="" title="表17.4.png">)</li>
<li>regex类表示一个正则表达式。<pre><code>// find the characters ei that follow a character other than c
string pattern(&quot;[^c]ei&quot;);
// we want the whole word in which our pattern appears
pattern = &quot;[[:alpha:]]*&quot; + pattern + &quot;[[:alpha:]]*&quot;;
regex r(pattern);    // construct a regex to find pattern
smatch results;      // define an object to hold the results of a search
// define a string that has text that does and doesn&#39;t match pattern
string test_str = &quot;receipt freind theif receive&quot;;
// use r to find a match to pattern in test_str
if (regex_search(test_str, results, r))     // if there is a match
    cout &lt;&lt; results.str() &lt;&lt; endl;     // print the matching word
</code></pre>
</li>
<li>regex_match和regex_search函数确定一个给定的字符序列与一个regex是否匹配。如果整个输入序列与表达式匹配，则regex_match函数返回true；如果输入序列中的一个子串与表达式匹配，则regex_search函数返回true。这两个函数的其中一个重载版本接受一个类型为smatch的附加参数。如果匹配成功，函数会将匹配信息保存在给定的smatch对象中。</li>
</ul>
<h3 id="17-3-1-使用正则表达式库"><a href="#17-3-1-使用正则表达式库" class="headerlink" title="17.3.1 使用正则表达式库"></a>17.3.1 使用正则表达式库</h3><ul>
<li>默认情况下，regex使用的正则表达式语言是ECMAScript。</li>
<li>定义一个regex或者对一个regex调用assign为其赋新值时，可以指定一些标志来影响regex的操作。ECMAScript、basic、extended、awk、grep和egrep这六个标志指定编写正则表达式时所使用的语言。这六个标志中必须设置其中之一，且只能设置一个。默认情况下，ECMAScript标志被设置，regex会使用ECMA-262规范，这也是很多Web浏览器使用的正则表达式语言。  <img src="/2020/01/09/c/c-primer/%E8%A1%A817.6.png" class="" title="表17.6.png">)</li>
<li>正则表达式的语法是否正确是在运行期间解析的。如果正则表达式存在错误，标准库会抛出类型为regex_error的异常。除了what操作外，regex_error还有一个名为code的成员，用来返回错误类型对应的数值编码。code返回的值是由具体实现定义的。RE库能抛出的标准错误如下，code返回对应错误的编号（从0开始）。</li>
<li>RE库为不同的输入序列都定义了对应的类型。使用时RE库类型必须与输入类型匹配。<ul>
<li>regex类保存char类型的正则表达式；wregex保存wchar_t类型的正则表达式。</li>
<li>smatch表示string类型的输入序列；cmatch表示字符数组类型的输入序列；wsmatch表示wstring类型的输入序列；wcmatch表示宽字符数组类型的输入序列。</li>
</ul>
</li>
</ul>
<h3 id="17-3-2-匹配与Regex迭代器类型"><a href="#17-3-2-匹配与Regex迭代器类型" class="headerlink" title="17.3.2 匹配与Regex迭代器类型"></a>17.3.2 匹配与Regex迭代器类型</h3><ul>
<li>regex迭代器是一种迭代器适配器，它被绑定到一个输入序列和一个regex对象上，每种输入类型都有对应的迭代器类型。</li>
<li>以sregex_iterator为例，将sregex_iterator绑定到一个string和一个regex对象时，迭代器自动定位至给定string中的第一个匹配位置。即，sregex_iterator构造函数对给定string和regex调用regex_search。解引用迭代器时，返回最近一次搜索结果的smatch对象。递增迭代器时，它调用regex_search在输入string中查找下一个匹配位置。<pre><code>// find the characters ei that follow a character other than c
string pattern(&quot;[^c]ei&quot;);
// we want the whole word in which our pattern appears
pattern = &quot;[[:alpha:]]*&quot; + pattern + &quot;[[:alpha:]]*&quot;;
regex r(pattern, regex::icase);     // we&#39;ll ignore case in doing the match
// it will repeatedly call regex_search to find all matches in file
for (sregex_iterator it(file.begin(), file.end(), r), end_it;
        it != end_it; ++it)
    cout &lt;&lt; it-&gt;str() &lt;&lt; endl;   // matched word
</code></pre>
</li>
<li>匹配类型有两个名为prefix和suffix的成员，分别返回表示输入序列中当前匹配之前和之后部分的ssub_match对象。一个ssub_match对象有两个名为str和length的成员，分别返回匹配的string和该string的长度。<pre><code>// same for loop header as before
for (sregex_iterator it(file.begin(), file.end(), r), end_it;
    it != end_it; ++it)
&#123;
    auto pos = it-&gt;prefix().length();    // size of the prefix
    pos = pos &gt; 40 ? pos - 40 : 0;       // we want up to 40 characters
    cout &lt;&lt; it-&gt;prefix().str().substr(pos)          // last part of the prefix
        &lt;&lt; &quot;\n\t\t&gt;&gt;&gt; &quot; &lt;&lt; it-&gt;str() &lt;&lt; &quot; &lt;&lt;&lt;\n&quot;    // matched word
        &lt;&lt; it-&gt;suffix().str().substr(0, 40)         // first part of the suffix
        &lt;&lt; endl;
&#125;
</code></pre>
</li>
</ul>
<h3 id="17-3-3-使用子表达式"><a href="#17-3-3-使用子表达式" class="headerlink" title="17.3.3 使用子表达式"></a>17.3.3 使用子表达式</h3><ul>
<li>正则表达式中的模式通常包含一个或多个子表达式。子表达式是模式的一部分，本身也有意义。正则表达式语法通常用括号表示子表达式。</li>
<li>匹配对象除了提供匹配整体的相关信息外，还可以用来访问模式中的每个子表达式。子匹配是按位置来访问的，第一个子匹配位置为0，表示整个模式对应的匹配，随后是每个子表达式对应的匹配。</li>
</ul>
<h3 id="17-3-4-使用regex-replace"><a href="#17-3-4-使用regex-replace" class="headerlink" title="17.3.4 使用regex_replace"></a>17.3.4 使用regex_replace</h3><ul>
<li>标准库定义了用于在正则表达式替换过程中控制匹配或格式的标志。这些标志可以传递给regex_search、regex_match函数或者smatch类的format成员。匹配和格式化标志的类型为match_flag_type，定义在命名空间regex_constants中。由于regex_constants定义在std中，因此在使用这些名字时，需要同时加上两个命名空间的限定符。</li>
<li>默认情况下，regex_replace输出整个输入序列。未与正则表达式匹配的部分会原样输出，匹配的部分按照格式字符串指定的格式输出。使用format_no_copy标志可以只输出匹配部分。</li>
</ul>
<h2 id="17-4-随机数"><a href="#17-4-随机数" class="headerlink" title="17.4 随机数"></a>17.4 随机数</h2><ul>
<li>在新标准出现之前，C和C++都依赖于一个简单的C库函数rand来生成随机数。该函数生成均匀分布的伪随机整数，每个随机数的范围在0和一个系统相关的最大值（至少为32767）之间。</li>
<li>头文件random中的随机数库定义了一组类来解决rand函数的一些问题：随机数引擎类（random-number engines）可以生成unsigned随机数序列；随机数分布类（random-number distribution classes）使用引擎类生成指定类型、范围和概率分布的随机数。</li>
<li>C++程序不应该使用rand函数，而应该使用default_random_engine类和恰当的分布类对象。</li>
</ul>
<h3 id="17-4-1-随机数引擎和分布"><a href="#17-4-1-随机数引擎和分布" class="headerlink" title="17.4.1 随机数引擎和分布"></a>17.4.1 随机数引擎和分布</h3><ul>
<li>随机数引擎是函数对象类，定义了一个不接受参数的调用运算符，返回一个随机unsigned整数。调用一个随机数引擎对象可以生成原始随机数。<pre><code>default_random_engine e;    // generates random unsigned integers
for (size_t i = 0; i &lt; 10; ++i)
    // e() &quot;calls&quot; the object to produce the next random number
    cout &lt;&lt; e() &lt;&lt; &quot; &quot;;
</code></pre>
</li>
<li>标准库定义了多个随机数引擎类，区别在于性能和随机性质量。每个编译器都会指定其中一个作为default_random_engine类型，此类型一般具有最常用的特性。</li>
<li>大多数情况下，随机数引擎的输出是不能直接使用的，因为生成的随机数范围通常与程序所需要的不符。</li>
<li>使用分布类对象可以得到指定范围的随机数。新标准库的uniform_int_distribution<unsigned>类型生成均匀分布的unsigned值。<pre><code>// uniformly distributed from 0 to 9 inclusive
uniform_int_distribution&lt;unsigned&gt; u(0,9);
default_random_engine e;    // generates unsigned random integers
for (size_t i = 0; i &lt; 10; ++i)
    // u uses e as a source of numbers
    // each call returns a uniformly distributed value in the specified range
    cout &lt;&lt; u(e) &lt;&lt; &quot; &quot;;
</code></pre>
</li>
<li>类似引擎类型，分布类型也是函数对象类。分布类型定义了一个接受一个随机数引擎参数的调用运算符。分布对象使用它的引擎参数生成随机数，并将其映射到指定的分布区间。</li>
<li>随机数发生器指分布对象和引擎对象的组合</li>
<li>rand函数的生成范围在0到RAND_MAX之间，随机数引擎生成的unsigned整数在一个系统定义的范围内。一个引擎类型的范围可以通过调用该类型对象的min和max成员来获得。</li>
<li>即使随机数发生器生成的数看起来是随机的，但对于一个给定的发生器，每次运行程序时它都会返回相同的数值序列。</li>
<li>如果函数需要局部的随机数发生器，应该将其（包括引擎和分布对象）定义为static对象，这样随机数发生器就能在函数调用期间保持状态。否则每次调用函数都会生成相同的序列。<pre><code>// returns a vector of 100 uniformly distributed random numbers
vector&lt;unsigned&gt; good_randVec()
&#123;
    // because engines and distributions retain state, they usually should be
    // defined as static so that new numbers are generated on each call
    static default_random_engine e;
    static uniform_int_distribution&lt;unsigned&gt; u(0,9);
    vector&lt;unsigned&gt; ret;
    for (size_t i = 0; i &lt; 100; ++i)
        ret.push_back(u(e));
    return ret;
&#125;
</code></pre>
</li>
<li>通过为引擎提供一个种子（seed），可以让引擎在程序每次运行时生成不同的序列。种子是一个数值，引擎利用它从序列中的一个新位置重新开始生成随机数。</li>
<li>为引擎设置种子有两种方式：<ul>
<li>在创建对象时提供种子。</li>
<li>调用引擎的seed成员设置种子。</li>
</ul>
<pre><code>default_random_engine e1;    // uses the default seed
default_random_engine e2(2147483646);   // use the given seed value
default_random_engine e3;    // uses the default seed value
e3.seed(32767);     // call seed to set a new seed value
</code></pre>
</li>
<li>选择种子的常用方法是调用系统函数time。该函数定义在头文件ctime中，返回从一个特定时刻到当前经过的秒数。time函数接受单个指针参数，指向用于写入时间的数据结构。如果指针为空，则函数简单地返回时间。<pre><code>default_random_engine e1(time(0));   // a somewhat random seed
</code></pre>
</li>
<li>由于time函数返回以秒计算的时间，因此用time返回值作为种子的方式只适用于生成种子的间隔为秒级或更长时间的应用。另外如果程序作为一个自动过程的一部分反复运行，这种方式也会无效，可能多次使用的是相同的种子。</li>
</ul>
<h3 id="17-4-2-其他随机数分布"><a href="#17-4-2-其他随机数分布" class="headerlink" title="17.4.2 其他随机数分布"></a>17.4.2 其他随机数分布</h3><ul>
<li>从rand函数获得随机浮点数的一个常用但不正确的方法是用rand的结果除以RAND_MAX。但因为随机整数的精度通常低于随机浮点数，所以使用这种方法时，有一些浮点值永远不会被生成。</li>
<li>使用新标准库的uniform_real_distribution类型可以获得随机浮点数。<pre><code>default_random_engine e;    // generates unsigned random integers
// uniformly distributed from 0 to 1 inclusive
uniform_real_distribution&lt;double&gt; u(0,1);
for (size_t i = 0; i &lt; 10; ++i)
    cout &lt;&lt; u(e) &lt;&lt; &quot; &quot;;
</code></pre>
</li>
<li>除了总是生成bool类型的bernouilli_distribution外，其他分布类型都是模板。每个模板都接受单个类型参数，指定分布生成的结果类型。</li>
<li>分布类型限制了可以作为模板类型的参数类型，一些模板只能生成浮点数，而其他模板只能生成整数。分布类型还定义了一个默认模板类型参数，整型分布的默认参数是int，浮点数分布的默认参数是double。使用默认类型时应该在模板名后使用空尖括号。<pre><code>// empty &lt;&gt; signify we want to use the default result type
uniform_real_distribution&lt;&gt; u(0,1);    // generates double by default
</code></pre>
</li>
<li>bernouilli_distribution类型是一个普通类，而非模板。该分布返回一个bool值，其中true的概率是一个常数，默认为0.5。</li>
<li>由于引擎会返回相同的随机数序列，因此需要在循环中使用引擎时，必须在循环体外定义引擎对象。否则每次循环都会创建新引擎，生成相同序列。同样，分布对象也需要保持运行状态，也必须在循环体外定义。</li>
</ul>
<h2 id="17-5-io库再探"><a href="#17-5-io库再探" class="headerlink" title="17.5 io库再探"></a>17.5 io库再探</h2><h3 id="17-5-1-格式化输入与输出"><a href="#17-5-1-格式化输入与输出" class="headerlink" title="17.5.1 格式化输入与输出"></a>17.5.1 格式化输入与输出</h3><ul>
<li>除了条件状态外，每个iostream对象还维护着一个格式状态来控制IO格式化细节。</li>
<li>标准库定义了一组操纵符（manipulator）来修改流的格式状态。操纵符是一个函数或对象，会影响流的状态，并能作为输入和输出运算符的运算对象。类似输入和输出运算符，操纵符也返回它所处理的流对象。</li>
<li>操纵符用于两大类输出控制：控制数值的输出格式，控制补白的数量和位置。</li>
<li>操纵符改变流的格式状态时，通常改变后的状态对所有后续IO都生效。大多数改变格式状态的操纵符都是设置&#x2F;复原成对的，一个操纵符用于设置新格式，另一个用于恢复正常格式。</li>
<li>默认情况下，bool值输出为1（true）或0（false）。对流使用boolalpha操纵符可以输出true或false，还原格式时使用noboolalpha操纵符。<pre><code>cout &lt;&lt; &quot;default bool values: &quot; &lt;&lt; true &lt;&lt; &quot; &quot; &lt;&lt; false
&lt;&lt; &quot;\nalpha bool values: &quot; &lt;&lt; boolalpha
&lt;&lt; true &lt;&lt; &quot; &quot; &lt;&lt; false &lt;&lt; endl;

default bool values: 1 0
alpha bool values: true false
</code></pre>
</li>
<li>默认情况下，整型值的输入输出使用十进制。可以使用hex、oct和dec操纵符将其改为十六进制、八进制或改回十进制。<pre><code>cout &lt;&lt; &quot;default: &quot; &lt;&lt; 20 &lt;&lt; &quot; &quot; &lt;&lt; 1024 &lt;&lt; endl;
cout &lt;&lt; &quot;octal: &quot; &lt;&lt; oct &lt;&lt; 20 &lt;&lt; &quot; &quot; &lt;&lt; 1024 &lt;&lt; endl;
cout &lt;&lt; &quot;hex: &quot; &lt;&lt; hex &lt;&lt; 20 &lt;&lt; &quot; &quot; &lt;&lt; 1024 &lt;&lt; endl;
cout &lt;&lt; &quot;decimal: &quot; &lt;&lt; dec &lt;&lt; 20 &lt;&lt; &quot; &quot; &lt;&lt; 1024 &lt;&lt; endl;

default: 20 1024
octal: 24 2000
hex: 14 400
decimal: 20 1024
</code></pre>
</li>
<li>hex、oct和dec操纵符只影响整型运算对象，浮点值的表示形式不受影响。</li>
<li>默认情况下，在输出数值时，没有可见的标识指出当前使用的进制模式。如果需要输出八进制或十六进制值，应该使用showbase操纵符。对流应用showbase后，在输出结果中会显示进制，显示模式和指定整型常量进制的规范相同。<ul>
<li>前导0x表示十六进制。</li>
<li>前导0表示八进制。</li>
<li>无前导字符表示十进制。</li>
</ul>
</li>
<li>还原格式时使用noshowbase操纵符。<pre><code>cout &lt;&lt; showbase;    // show the base when printing integral values
cout &lt;&lt; &quot;default: &quot; &lt;&lt; 20 &lt;&lt; &quot; &quot; &lt;&lt; 1024 &lt;&lt; endl;
cout &lt;&lt; &quot;in octal: &quot; &lt;&lt; oct &lt;&lt; 20 &lt;&lt; &quot; &quot; &lt;&lt; 1024 &lt;&lt; endl;
cout &lt;&lt; &quot;in hex: &quot; &lt;&lt; hex &lt;&lt; 20 &lt;&lt; &quot; &quot; &lt;&lt; 1024 &lt;&lt; endl;
cout &lt;&lt; &quot;in decimal: &quot; &lt;&lt; dec &lt;&lt; 20 &lt;&lt; &quot; &quot; &lt;&lt; 1024 &lt;&lt; endl;
cout &lt;&lt; noshowbase;   // reset the state of the stream

default: 20 1024
in octal: 024 02000
in hex: 0x14 0x400
in decimal: 20 1024
</code></pre>
</li>
<li>默认情况下，十六进制值（包括前导字符）以小写格式输出。使用uppercase操纵符可以输出大写字母。还原格式时使用nouppercase操纵符。<pre><code>cout &lt;&lt; uppercase &lt;&lt; showbase &lt;&lt; hex
&lt;&lt; &quot;printed in hexadecimal: &quot; &lt;&lt; 20 &lt;&lt; &quot; &quot; &lt;&lt; 1024
&lt;&lt; nouppercase &lt;&lt; noshowbase &lt;&lt; dec &lt;&lt; endl;

printed in hexadecimal: 0X14 0X400
</code></pre>
</li>
<li>浮点数的输出格式涉及三个方面：<ul>
<li>输出精度（即输出多少个数字）。</li>
<li>十六进制、定点十进制或者科学记数法形式输出。</li>
<li>没有小数部分的浮点值是否输出小数点。</li>
</ul>
</li>
<li>默认情况下，浮点值按六位数字精度输出；如果浮点值没有小数部分，则不输出小数点；根据浮点数的值选择输出为定点十进制或科学计数法形式：非常大或非常小的值输出为科学记数法形式，其他值输出为定点十进制形式。</li>
<li>默认情况下，精度控制输出的数字总位数。输出时，浮点值按照当前精度四舍五入而非截断。</li>
<li>调用IO对象的precision成员或者使用setprecision操纵符可以改变精度。<ul>
<li>precision成员是重载的。一个版本接受一个int值，将精度设置为此值，并返回旧精度值。另一个版本不接受参数，直接返回当前精度值。</li>
<li>setprecision操纵符接受一个参数来设置精度。</li>
</ul>
</li>
<li>setprecision操纵符和其他接受参数的操纵符都定义在头文件iomanip中。<pre><code>// cout.precision reports the current precision value
cout &lt;&lt; &quot;Precision: &quot; &lt;&lt; cout.precision()
    &lt;&lt; &quot;, Value: &quot; &lt;&lt; sqrt(2.0) &lt;&lt; endl;
// cout.precision(12) asks that 12 digits of precision be printed
cout.precision(12);
cout &lt;&lt; &quot;Precision: &quot; &lt;&lt; cout.precision()
    &lt;&lt; &quot;, Value: &quot; &lt;&lt; sqrt(2.0) &lt;&lt; endl;
// alternative way to set precision using the setprecision manipulator
cout &lt;&lt; setprecision(3);
cout &lt;&lt; &quot;Precision: &quot; &lt;&lt; cout.precision()
    &lt;&lt; &quot;, Value: &quot; &lt;&lt; sqrt(2.0) &lt;&lt; endl;

Precision: 6, Value: 1.41421
Precision: 12, Value: 1.41421356237
Precision: 3, Value: 1.41
</code></pre>
</li>
<li>操纵符可以强制流使用科学记数法、定点十进制或十六进制形式输出浮点值。<ul>
<li>scientific使用科学记数法表示浮点值。</li>
<li>fixed使用定点十进制表示浮点值。</li>
<li>hexfloat（新标准库）使用十六进制表示浮点值。</li>
<li>defaultfloat（新标准库）将流恢复到默认状态。</li>
</ul>
</li>
<li>除非程序需要控制浮点数的表示方式，否则最好由标准库来选择计数法。<pre><code>cout &lt;&lt; &quot;default format: &quot; &lt;&lt; 100 * sqrt(2.0) &lt;&lt; &#39;\n&#39;
    &lt;&lt; &quot;scientific: &quot; &lt;&lt; scientific &lt;&lt; 100 * sqrt(2.0) &lt;&lt; &#39;\n&#39;
    &lt;&lt; &quot;fixed decimal: &quot; &lt;&lt; fixed &lt;&lt; 100 * sqrt(2.0) &lt;&lt; &#39;\n&#39;
    &lt;&lt; &quot;hexadecimal: &quot; &lt;&lt; hexfloat &lt;&lt; 100 * sqrt(2.0) &lt;&lt; &#39;\n&#39;
    &lt;&lt; &quot;use defaults: &quot; &lt;&lt; defaultfloat &lt;&lt; 100 * sqrt(2.0) &lt;&lt; &#39;\n&#39;;

default format: 141.421
scientific: 1.414214e+002
fixed decimal: 141.421356
hexadecimal: 0x1.1ad7bcp+7
use defaults: 141.421
</code></pre>
</li>
<li>scientific、fixed和hexfloat操纵符会改变流的精度含义。执行这些操纵符后，精度控制的将是小数点后面的数字位数，而默认情况下控制的是数字总位数。</li>
<li>默认情况下，当浮点值的小数部分为0时，不显示小数点。使用showpoint操纵符可以强制输出小数点，noshowpoint操纵符还原默认行为。<pre><code>cout &lt;&lt; 10.0 &lt;&lt; endl;        // prints 10
cout &lt;&lt; showpoint &lt;&lt; 10.0    // prints 10.0000
    &lt;&lt; noshowpoint &lt;&lt; endl;  // revert to default format for the decimal point
</code></pre>
</li>
<li>按列输出时，通常需要非常精细地控制数据格式。<ul>
<li>setw指定下一个数字或字符串值的最小空间。</li>
<li>left表示左对齐输出。</li>
<li>right表示右对齐输出（默认格式）。</li>
<li>internal控制负数的符号位置，它左对齐符号，右对齐值，中间空间用空格填充。</li>
<li>setfill指定一个字符代替默认的空格进行补白。</li>
</ul>
</li>
<li>setw类似endl，不改变输出流的内部状态，只影响下一次输出的大小。</li>
<li>默认情况下，输入运算符会忽略空白字符（空格符、制表符、换行符、换纸符和回车符）。使用noskipws操纵符可以让输入运算符读取空白符，skipws操纵符还原默认行为。<pre><code>cin &gt;&gt; noskipws;    // set cin so that it reads whitespace
while (cin &gt;&gt; ch)
    cout &lt;&lt; ch;
cin &gt;&gt; skipws;      // reset cin to the default state so that it discards whitespace
</code></pre>
</li>
</ul>
<h3 id="17-5-2-未格式化的输入-x2F-输出操作（Unformatted-Input-x2F-Output-Operations）"><a href="#17-5-2-未格式化的输入-x2F-输出操作（Unformatted-Input-x2F-Output-Operations）" class="headerlink" title="17.5.2 未格式化的输入&#x2F;输出操作（Unformatted Input&#x2F;Output Operations）"></a>17.5.2 未格式化的输入&#x2F;输出操作（Unformatted Input&#x2F;Output Operations）</h3><ul>
<li>标准库提供了一组低层操作，支持未格式化IO（unformatted IO）。这些操作可以将一个流当作无解释的字节序列来处理。</li>
<li>一些未格式化操作每次处理流的一个字节，它们会读取而不是忽略空白符。</li>
<li>使用未格式化IO操作get和put可以读取和写入一个字符。<pre><code>char ch;
while (cin.get(ch))
    cout.put(ch);
</code></pre>
</li>
<li>有时读取完一个字符后才发现目前无法处理该字符，希望将其放回流中。标准库提供了三种方法退回字符。<ul>
<li>peek返回输入流中下一个字符的副本，但不会将其从流中删除。</li>
<li>unget使输入流向后移动，令最后读取的值回到流中。即使不知道最后从流中读取了什么值，也可以调用unget。</li>
<li>putback是特殊版本的unget，它退回从流中读取的最后一个值，但它接受一个参数，该参数必须与最后读取的值相同。</li>
</ul>
</li>
<li>一般情况下，在读取下一个值之前，标准库保证程序可以退回最多一个值。</li>
<li>peek和无参数的get函数都以int类型从输入流返回字符。这些函数使用int的原因是可以返回文件尾标记。char范围中的每个值都表示一个真实字符，因此没有额外的值可以表示文件尾。返回int的函数先将要返回的字符转换为unsigned char，再将结果提升为int。因此即使字符集中有字符映射到负值，返回的int也是正值。而标准库使用负值表示文件尾，这样就能保证文件尾与任何合法字符的值都不相同。头文件cstdio定义了一个名为EOF的常量值，可以用它检测函数返回的值是否是文件尾。<pre><code>int ch;    // use an int, not a char to hold the return from get()
// loop to read and write all the data in the input
while ((ch = cin.get()) != EOF)
    cout.put(ch);
</code></pre>
</li>
<li>一个常见的编程错误是将get或peek函数的返回值赋给char而非int对象，但编译器不能发现这个错误。<pre><code>char ch;   // using a char here invites disaster!
// the return from cin.get is converted to char and then compared to an int
while ((ch = cin.get()) != EOF)
    cout.put(ch);
</code></pre>
</li>
<li>当get返回EOF时，该值会先被转换为unsigned char，之后提升得到的int值与EOF值不再相等，因此循环永远不会停止。</li>
<li>一些未格式化IO操作一次处理大块数据，这些操作可以提高程序执行速度，但需要自己分配并管理用来保存和提取数据的字符数组。</li>
<li>get和getline函数接受相同的参数，它们的行为类似但不相同。两个函数都一直读取数据，直到遇到下列情况之一：<ul>
<li>已经读取了size - 1个字符。</li>
<li>遇到了文件尾（EOF）。</li>
<li>遇到了分隔符。</li>
</ul>
</li>
<li>两个函数的区别在于处理分隔符的方式：get将分隔符留在输入流中作为下一个字符，而getline读取并丢弃分隔符。两个函数都不会将分隔符保存在结果数组中。</li>
<li>读取流数据时的一个常见错误是忘记从流中删除分隔符。</li>
<li>一些操作可能从输入流中读取了未知个数的字节，使用gcount函数可以确定上一次未格式化输入操作读取了多少字符。gcount函数应该在任何后续未格式化输入操作前调用，将字符退回流的操作也属于未格式化输入操作。如果在调用gcount前使用了peek、unget或putback操作，则gcount的返回值为0。</li>
<li>使用clear、ignore和sync函数可以清空输入流中的数据。读到非法字符时，输入流将处于错误状态。为了继续获取输入数据，先调用clear函数重置流的错误标记。再调用ignore清空流中指定大小的数据，或者调用sync直接清空流中所有数据。numeric_limits<streamsize>::max()返回流的缓冲区大小。<pre><code>// 重置错误标志
cin.clear();

// 清除流中所有数据
cin.clear();
cin.ignore(numeric_limits&lt;streamsize&gt;::max());

// 清除流中一行数据
cin.ignore(numeric_limits&lt;streamsize&gt;::max(), &#39;\n&#39;);
</code></pre>
</li>
</ul>
<h3 id="17-5-3-流随机访问（Random-Access-to-a-Stream）"><a href="#17-5-3-流随机访问（Random-Access-to-a-Stream）" class="headerlink" title="17.5.3 流随机访问（Random Access to a Stream）"></a>17.5.3 流随机访问（Random Access to a Stream）</h3><ul>
<li>随机IO本质上是依赖于操作系统的。</li>
<li>为了支持随机访问，IO类型通过维护一个标记来确定下一次读写操作的位置。seek函数用于移动标记，tell函数用于获取标记。标准库实际上定义了两对seek和tell函数，一对用于输入流（后缀为g，表示get），一对用于输出流（后缀为p，表示put）。</li>
<li>虽然标准库为所有流类型都定义了seek和tell函数，但它们是否有意义取决于流绑定到哪个设备。在大多数系统中，绑定到cin、cout、cerr和clog的流不支持随机访问。对这些流可以调用seek和tell函数，但在运行时会出现错误，流也会被置为无效状态。</li>
<li>从逻辑上考虑，seek和tell函数的使用范围如下：<ul>
<li>可以对istream、ifstream、istringstream类型使用g版本。</li>
<li>可以对istream、ifstream、istringstream类型使用g版本。</li>
<li>可以对iostream、fstream、stringstream类型使用g和p版本。</li>
</ul>
</li>
<li>一个流中只有一个标记——不存在独立的读标记和写标记。fstream和stringstream类型可以读写同一个流。在这些类型中，有单一的缓冲区用于保存读写的数据，同时标记也只有一个，表示缓冲区中的当前位置。标准库将两个版本的seek和tell函数都映射到这个标记。</li>
<li>由于流中只有一个标记，因此在切换读写操作时，必须使用seek函数来重定位标记。</li>
<li>seek函数有两个重载版本：一个版本使用绝对地址移动流标记；另一个版本使用指定位置和偏移量移动流标记。<pre><code>// set the marker to a fixed position
seekg(new_position);    // set the read marker to the given pos_type location
seekp(new_position);    // set the write marker to the given pos_type location
// offset some distance ahead of or behind the given starting point
seekg(offset, from);    // set the read marker offset distance from from
seekp(offset, from);    // offset has type off_type
</code></pre>
</li>
<li>参数new_position和offset的类型分别是pos_type和off_type，这两个类型都是机器相关的，定义在头文件istream和ostream中。pos_type表示文件位置，而off_type表示距离当前位置的偏移量，偏移量可以是正数也可以是负数。</li>
<li>tellg和tellp函数返回一个pos_type值，表示流的当前位置。</li>
</ul>
<h1 id="第18章-用于大型工程的工具"><a href="#第18章-用于大型工程的工具" class="headerlink" title="第18章 用于大型工程的工具"></a>第18章 用于大型工程的工具</h1><h2 id="18-1-异常处理"><a href="#18-1-异常处理" class="headerlink" title="18.1 异常处理"></a>18.1 异常处理</h2><ul>
<li>异常处理机制允许程序中独立开发的部分能够在运行期间就出现的问题进行通信并做出相应的处理，使问题检测和解决过程相互分离。</li>
</ul>
<h3 id="18-1-1-抛出异常"><a href="#18-1-1-抛出异常" class="headerlink" title="18.1.1 抛出异常"></a>18.1.1 抛出异常</h3><ul>
<li>在C++中，通过抛出（throwing）一条表达式来引发（raised）一个异常。被抛出的表达式类型和当前的调用链共同决定了应该使用哪段处理代码（handler）来处理该异常。被选中的处理代码是在调用链中与抛出对象类型匹配且距离最近的代码。</li>
<li>执行一个throw语句时，跟在throw后面的语句将不再执行。程序的控制权从throw转移到与之匹配的catch语句中。该catch可能是同一个函数中的局部catch，也可能位于直接或间接调用了发生异常的函数的另一个函数中。控制权的转移意味着两个问题：<ul>
<li>沿着调用链的函数可能会提前退出。</li>
<li>一旦程序开始执行异常处理代码，则沿着调用链创建的对象会被销毁。</li>
</ul>
</li>
<li>抛出异常后，程序暂停执行当前函数并立即寻找对应catch语句的过程叫做栈展开（stack unwinding）。栈展开沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的catch语句为止。如果没有对应的catch语句，则退出主函数后查找过程结束。<ul>
<li>如果找到了匹配的catch语句，则程序进入该子句并执行其中的代码。catch语句执行结束后，程序会转移到与try块关联的最后一个catch语句之后的位置继续执行。</li>
<li>如果没有找到匹配的catch语句，程序会调用标准库的terminate函数，终止运行。</li>
</ul>
</li>
<li>在栈展开过程中，位于调用链上的语句块可能会提前退出，其中的局部对象也会被销毁。如果异常发生在构造函数或者数组及容器的元素初始化过程中，则当前的对象可能只构造了一部分，此时必须确保已构造的成员能被正确销毁。</li>
<li>如果一个块分配了资源，并且在执行资源释放代码前发生了异常，则资源不会被释放。</li>
<li>由于栈展开可能会调用析构函数，因此析构函数不应该抛出不能被它自身处理的异常。即，如果析构函数需要执行某个可能引发异常的操作，则该操作应该被放置在一个try语句块中，并在析构函数内部得到处理。实际编程中，析构函数仅仅是释放资源，不太可能引发异常。所有的标准库类型都能确保它们的析构函数不会引发异常。</li>
<li>编译器使用异常抛出表达式对异常对象（exception object）进行拷贝初始化，因此throw语句中的表达式必须具有完全类型。如果该表达式是类类型，则相应的类必须含有可访问的析构函数和拷贝&#x2F;移动构造函数。如果该表达式是数组或函数类型，则表达式会被转换成对应的指针类型。</li>
<li>抛出一条表达式时，该表达式的静态编译类型决定了异常对象的类型。如果throw表达式解引用一个基类指针，而该指针实际指向派生类对象，则只有基类部分会被抛出。</li>
<li>抛出指针时必须确保在任何对应的处理代码中，指针指向的对象一定存在。</li>
</ul>
<h3 id="18-1-2-捕获异常"><a href="#18-1-2-捕获异常" class="headerlink" title="18.1.2 捕获异常"></a>18.1.2 捕获异常</h3><ul>
<li>catch语句（catch clause）中的异常声明（exception declaration）类似只包含一个形参的函数形参列表。声明的类型决定了处理代码所能捕获的异常类型。该类型必须是完全类型，可以是左值引用，但不能是右值引用。如果catch无须访问抛出的表达式，则可以忽略捕获形参的名字。</li>
<li>进入catch语句后，使用异常对象初始化异常声明中的参数。catch参数的特性和函数参数类似。<ul>
<li>如果catch的参数类型是非引用类型，则该参数是异常对象的一个副本，改变参数不会影响异常对象本身。</li>
<li>如果catch的参数类型是引用类型，则该参数是异常对象的一个别名，改变参数就是改变异常对象本身。</li>
<li>在继承体系中，如果catch的参数类型是基类类型，则可以使用其派生类类型的异常对象对其初始化。<ul>
<li>catch的参数是基类非引用类型时，异常对象会被切除一部分。</li>
<li>catch的参数是基类引用类型时，以常规方式绑定到异常对象。</li>
</ul>
</li>
</ul>
</li>
<li>异常声明的静态类型决定了catch语句所能执行的操作。如果catch的参数是基类类型，则无法使用派生类特有的成员。</li>
<li>通常情况下，如果catch接受的异常与某个继承体系有关，则最好将catch参数定义为引用类型。</li>
<li>查找异常处理代码时，最终结果是第一个与异常匹配的catch语句，但这未必是最佳匹配。因此，越特殊的catch越应该位于整个catch列表的前端。当程序使用具有继承关系的异常时，派生类异常的处理代码应该位于基类异常的处理代码之前。</li>
<li>异常和异常声明的匹配规则比函数参数严格，绝大多数类型转换都不能使用。<ul>
<li>允许从非常量到常量的类型转换。</li>
<li>允许从派生类到基类的类型转换。</li>
<li>数组被转换成指向数组元素类型的指针，函数被转换成指向该函数类型的指针。</li>
</ul>
</li>
<li>除此之外，包括标准算术类型转换和类类型转换在内的其他所有转换规则都不能在catch匹配过程中使用。</li>
<li>有时一个单独的catch语句不能完整处理某个异常。执行完一些校正操作后，当前的catch可能会让位于调用链上层的函数继续处理异常。一个catch语句通过重新抛出（rethrowing）的操作将异常传递给另一个catch语句。重新抛出是一条不包含表达式的throw语句。</li>
<li>有时一个单独的catch语句不能完整处理某个异常。执行完一些校正操作后，当前的catch可能会让位于调用链上层的函数继续处理异常。一个catch语句通过重新抛出（rethrowing）的操作将异常传递给另一个catch语句。重新抛出是一条不包含表达式的throw语句。</li>
<li>有时一个单独的catch语句不能完整处理某个异常。执行完一些校正操作后，当前的catch可能会让位于调用链上层的函数继续处理异常。一个catch语句通过重新抛出（rethrowing）的操作将异常传递给另一个catch语句。重新抛出是一条不包含表达式的throw语句。</li>
<li>catch(…)通常与重新抛出语句一起使用。</li>
<li>如果catch(…)与其他catch语句一起使用，则catch(…)必须位于最后，否则catch(…)后面的catch语句永远不会被匹配。</li>
</ul>
<h3 id="18-1-3-函数try语句块与构造函数"><a href="#18-1-3-函数try语句块与构造函数" class="headerlink" title="18.1.3 函数try语句块与构造函数"></a>18.1.3 函数try语句块与构造函数</h3><ul>
<li>要想处理构造函数初始值列表抛出的异常，必须将构造函数写成函数try语句块（function try block）的形式。函数try语句块使得一组catch语句可以同时处理构造函数体和构造函数初始化过程中的异常。<pre><code>template &lt;typename T&gt;
Blob&lt;T&gt;::Blob(std::initializer_list&lt;T&gt; il) try :
    data(std::make_shared&lt;std::vector&lt;T&gt;&gt;(il))
&#123;
    /* empty body */
&#125;
catch(const std::bad_alloc &amp;e)
&#123;
    handle_out_of_memory(e);
&#125;
</code></pre>
</li>
<li>函数try语句块的catch语句会在结尾处隐式地重新抛出异常，通知上层函数对象构造失败。上层函数需要继续处理该异常。在初始化构造函数参数时发生的异常不属于函数try语句块处理的范围。</li>
</ul>
<h3 id="18-1-4-noexcept异常说明"><a href="#18-1-4-noexcept异常说明" class="headerlink" title="18.1.4 noexcept异常说明"></a>18.1.4 noexcept异常说明</h3><ul>
<li>在C++11中，可以通过提供noexcept说明（noexcept specification）来指出某个函数不会抛出异常。<pre><code>void recoup(int) noexcept;  // won&#39;t throw
void alloc(int);            // might throw
</code></pre>
</li>
<li>noexcept说明的出现位置：<ul>
<li>关键字noexcept位于函数的参数列表之后，尾置返回类型之前。</li>
<li>对于一个函数来说，noexcept说明必须同时出现在该函数的所有声明和定义语句中。</li>
<li>函数指针的声明和定义也可以指定noexcept。</li>
<li>在typedef或类型别名中不能使用noexcept。</li>
<li>在成员函数中，关键字noexcept位于const或引用限定符之后，final、override或虚函数的&#x3D;0之前。</li>
</ul>
</li>
<li>编译器并不会在编译时检查noexcept说明。如果一个函数在指定了noexcept的同时又含有throw语句或其他可能抛出异常的操作，仍然会通过编译（个别编译器可能会提出警告）。</li>
<li>一旦noexcept函数抛出异常，程序会调用terminate函数终止运行（该过程是否执行栈展开未作规定）。因此noexcept可以用于两种情况：<ul>
<li>确认函数不会抛出异常。</li>
<li>不知道该如何处理函数抛出的异常。</li>
</ul>
</li>
<li>指明某个函数不会抛出异常可以让调用者不必再考虑异常处理操作。</li>
<li>早期的C++版本设计了一套更详细的异常说明方案。函数可以使用一个关键字throw，后面跟上用括号包围的异常类型列表，用于指定函数可能抛出的异常类型。关键字throw出现的位置与C++11的noexcept相同。该方案在C++11中被取消。但如果一个函数被声明为throw()的，则也说明该函数不会抛出异常。</li>
<li>noexcept说明符接受一个可选的实参，该实参必须能转换为bool类型。如果实参为true，则函数不会抛出异常；如果实参为false，则函数可能抛出异常。<pre><code>void recoup(int) noexcept(true);    // recoup won&#39;t throw
void alloc(int) noexcept(false);    // alloc can throw
</code></pre>
</li>
<li>noexcept运算符（noexcept operator）是一个一元运算符，返回bool类型的右值常量表达式，表示给定的运算对象是否会抛出异常。和sizeof类似，noexcept运算符也不会对运算对象求值。</li>
<li>当e调用的函数都含有noexcept说明且e本身不含有throw语句时，上述表达式返回true，否则返回false。noexcept运算符通常在noexcept说明符的实参中使用。<br>  <code>void f() noexcept(noexcept(g()));   // f has same exception specifier as g</code></li>
<li>函数指针与该指针指向的函数必须具有一致的异常说明。如果某个函数指针是noexcept的，则该指针只能指向noexcept函数；如果显式或隐式地说明了函数指针可能抛出异常，则该指针可以指向任何函数。<pre><code>// both recoup and pf1 promise not to throw
void (*pf1)(int) noexcept = recoup;
// ok: recoup won&#39;t throw; it doesn&#39;t matter that pf2 might
void (*pf2)(int) = recoup;
pf1 = alloc;    // error: alloc might throw but pf1 said it wouldn&#39;t
pf2 = alloc;    // ok: both pf2 and alloc might throw
</code></pre>
</li>
<li>如果一个虚函数是noexcept的，则后续派生出来的虚函数必须也是noexcept的。如果基类的虚函数允许抛出异常，则派生类的对应函数既可以允许，也可以禁止抛出异常。<pre><code>class Base
&#123;
public:
    virtual double f1(double) noexcept;   // doesn&#39;t throw
    virtual int f2() noexcept(false);   // can throw
    virtual void f3();   // can throw
&#125;;

class Derived : public Base
&#123;
public:
    double f1(double);   // error: Base::f1 promises not to throw
    int f2() noexcept(false);   // ok: same specification as Base::f2
    void f3() noexcept;   // ok: Derived f3 is more restrictive
&#125;;
</code></pre>
</li>
<li>编译器合成拷贝控制成员时，也会生成一个异常声明。如果所有的成员和基类操作都含有noexcept说明，则合成成员也是noexcept的。</li>
</ul>
<h3 id="18-1-5-异常类层次"><a href="#18-1-5-异常类层次" class="headerlink" title="18.1.5 异常类层次"></a>18.1.5 异常类层次</h3><ul>
<li>标准库异常类的继承体系： <img src="/2020/01/09/c/c-primer/%E8%A1%A818.1.png" class="" title="表18.1.png">)</li>
<li>exception类型只定义了拷贝构造函数、拷贝赋值运算符、一个虚析构函数和一个名为what的虚成员。what函数返回一个const char*，指向一个以NULL结尾的字符数组，并且不会抛出异常。</li>
<li>exception、bad_cast和bad_alloc类型定义了默认构造函数。runtime_error和logic_error类型没有默认构造函数，但是有一个接受C风格字符串或string类型实参的构造函数，该实参通常用于提供错误信息。what函数返回用于初始化异常对象的错误信息。</li>
<li>实际编程中通常会自定义exception（或者exception的标准库派生类）的派生类以扩展其继承体系。这些面向具体应用的异常类表示了与应用相关的异常状态。</li>
</ul>
<h2 id="18-2-命名空间"><a href="#18-2-命名空间" class="headerlink" title="18.2 命名空间"></a>18.2 命名空间</h2><ul>
<li>大型应用程序通常会使用多个独立开发的库，其中某些名字可能会相互冲突。多个库将名字放置在全局命名空间中会产生命名空间污染（namespace pollution）。</li>
<li>命名空间分割了全局命名空间，其中每个命名空间都是一个作用域。</li>
</ul>
<h3 id="18-2-1-命名空间定义"><a href="#18-2-1-命名空间定义" class="headerlink" title="18.2.1 命名空间定义"></a>18.2.1 命名空间定义</h3><ul>
<li>命名空间的定义包含两部分：关键字namespace和随后的命名空间名字。在命名空间名字后面是一系列由花括号包围的声明和定义。能出现在全局作用域中的声明就也能出现在命名空间中。<pre><code>namespace cplusplus_primer
&#123;
    class Sales_data &#123; / * ... * /&#125;;
    Sales_data operator+(const Sales_data&amp;, const Sales_data&amp;);
    class Query &#123; /* ... */ &#125;;
    class Query_base &#123; /* ... */&#125;;
&#125;   // like blocks, namespaces do not end with a semicolon
</code></pre>
</li>
<li>命名空间作用域后面不需要分号结束。</li>
<li>和其他名字一样，命名空间的名字也必须在定义它的作用域内保持唯一。命名空间可以定义在全局作用域内，也可以定义在其他命名空间中，但是不能定义在函数或类的内部。</li>
<li>每个命名空间都是一个作用域，不同命名空间内可以有相同名字的成员。</li>
<li>定义在某个命名空间中的名字可以被该命名空间内的其他成员直接访问，也可以被这些成员内嵌作用域中的任何单位访问。位于该命名空间之外的代码则必须明确指出所使用的名字属于哪个命名空间。<br>  <code>cplusplus_primer::Query q = cplusplus_primer::Query(&quot;hello&quot;);</code></li>
<li>命名空间的定义可以是不连续的。</li>
<li>如果之前没有名为nsp的命名空间定义，则上述代码创建一个新的命名空间；否则，上述代码打开已经存在的命名空间定义并为其添加新的成员声明。</li>
<li>利用命名空间不连续的特性可以将几个独立的接口和实现文件组成一个命名空间。此时，命名空间的组织方式类似管理自定义类和函数的方式。<ul>
<li>命名空间的一部分成员用于定义类，以及声明作为类接口的函数和对象。这些成员应该放置在头文件中。</li>
<li>命名空间成员的定义部分放置在另外的源文件中。源文件需要包含对应的头文件。</li>
</ul>
</li>
<li>程序中的某些实体只能定义一次，如非内联函数、静态数据成员等，命名空间中定义的名字也需要满足该要求。<pre><code>// ---- Sales_data.h----
// #includes should appear before opening the namespace
# include &lt;string&gt;
namespace cplusplus_primer
&#123;
    class Sales_data &#123; /* ... */&#125;;
    Sales_data operator+(const Sales_data&amp;, const Sales_data&amp;);
    // declarations for the remaining functions in the Sales_data interface
&#125;

// ---- Sales_data.cc----
// be sure any #includes appear before opening the namespace
# include &quot;Sales_data.h&quot;
namespace cplusplus_primer
&#123;
    // definitions for Sales_data members and overloaded operators
&#125;
</code></pre>
</li>
<li>通常情况下，#include不应该出现在命名空间内部。否则头文件中的所有名字都会被定义为该命名空间的成员。</li>
<li>定义多个类型不相关的命名空间时应该使用单独的文件分别表示每个类型。</li>
<li>可以在命名空间的外部定义该命名空间的成员。命名空间对于名字的声明必须在作用域内，同时该名字的定义需要明确指出其所属的命名空间。<pre><code>// namespace members defined outside the namespace must use qualified names
cplusplus_primer::Sales_data
cplusplus_primer::operator+(const Sales_data&amp; lhs, const Sales_data&amp; rhs)
&#123;
    Sales_data ret(lhs);
    // ...
&#125;
</code></pre>
</li>
<li>模板特例化必须定义在原始模板所属的命名空间中。可以在命名空间内部添加模板特例化声明，而在外部对其进行定义。<pre><code>// we must declare the specialization as a member of std
namespace std
&#123;
    template &lt;&gt; struct hash&lt;Sales_data&gt;;
&#125;

// having added the declaration for the specialization to std
// we can define the specialization outside the std namespace
template &lt;&gt; struct std::hash&lt;Sales_data&gt;
&#123;
    size_t operator()(const Sales_data&amp; s) const
    &#123;
        return hash&lt;string&gt;()(s.bookNo) ^
            hash&lt;unsigned&gt;()(s.units_sold) ^
            hash&lt;double&gt;()(s.revenue);
    &#125;
    // other members as before
&#125;;
</code></pre>
</li>
<li>全局作用域中定义的名字被隐式添加到全局命名空间（global namespace）中。全局命名空间以隐式方式声明，在所有程序中都存在。</li>
<li>作用域运算符::可以用于全局命名空间的成员。因为全局命名空间是隐式声明的，所以它并没有名字。</li>
<li>命名空间可以嵌套。嵌套的命名空间同时也是一个嵌套的作用域，它嵌套在外层命名空间的作用域内。内层命名空间声明的名字会隐藏外层命名空间的同名成员。在嵌套的命名空间中定义的名字只在内层命名空间中有效，外层命名空间中的代码在访问时需要在名字前添加限定符。</li>
<li>C++11新增了内联命名空间（inline namespace）。和一般的嵌套命名空间不同，内联命名空间中的名字可以被外层命名空间直接使用。定义内联命名空间的方式是在namespace前添加关键字inline。inline必须出现在该命名空间第一次定义的地方。<pre><code>inline namespace FifthEd
&#123;
    // namespace for the code from the Primer Fifth Edition
&#125;

namespace FifthEd
&#123;   // implicitly inline
    class Query_base &#123; /* ... */ &#125;;
    // other Query-related declarations
&#125;
</code></pre>
</li>
<li>当应用程序的代码在两次发布之间发生了改变时，通常会使用内联命名空间。<pre><code>namespace FourthEd
&#123;
    class Item_base &#123; /* ... */&#125;;
    class Query_base &#123; /* ... */&#125;;
    // other code from the Fourth Edition
&#125;

namespace cplusplus_primer
&#123;
    #include &quot;FifthEd.h&quot;
    #include &quot;FourthEd.h&quot;
&#125;
</code></pre>
</li>
<li>因为FifthEd是内联的，所以形如cplusplus_primer::的代码可以直接获得FifthEd的成员。如果想使用早期版本，则必须加上完整的外层命名空间名字。</li>
<li>未命名的命名空间（unnamed namespace）指关键字namespace后紧跟以花括号包围的一系列声明语句。未命名的命名空间中定义的变量拥有静态生命周期：它们在第一次使用前创建，直到程序结束才销毁。</li>
<li>一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件。每个文件定义自己的未命名的命名空间。如果一个头文件定义了未命名的命名空间，则该命名空间中定义的名字在每个包含该头文件的文件中对应不同实体。</li>
<li>定义在未命名的命名空间中的名字可以直接使用，不能对其使用作用域运算符。</li>
<li>定义在未命名的命名空间中的名字的作用域与该命名空间所在的作用域相同。如果未命名的命名空间定义在最外层作用域中，则该命名空间中的名字必须要与全局作用域中的名字有所区别。<pre><code>int i; // global declaration for i
namespace
&#123;
    int i;
&#125;
// ambiguous: defined globally and in an unnested, unnamed namespace
i = 10;

namespace local
&#123;
    namespace
    &#123;
        int i;
    &#125;
&#125;
// ok: i defined in a nested unnamed namespace is distinct from global i
local::i = 42;
</code></pre>
</li>
<li>在标准C++引入命名空间的概念之前，程序需要将名字声明为static的以令其对整个文件有效。在文件中进行静态声明的做法是从C语言继承而来的。在C语言中，声明为static的全局实体在其所在的文件之外不可见。该做法已经被C++标准取消，现在应该使用未命名的命名空间。</li>
</ul>
<h3 id="18-2-2-使用命名空间成员"><a href="#18-2-2-使用命名空间成员" class="headerlink" title="18.2.2 使用命名空间成员"></a>18.2.2 使用命名空间成员</h3><ul>
<li>可以使用关键字namespace和&#x3D;为命名空间定义别名（namespace alias）。别名必须出现在命名空间的定义之后。<br>  <code>namespace primer = cplusplus_primer;</code></li>
<li>一个命名空间可以有多个别名，它们都与命名空间的原名等价。</li>
<li>一条using声明（using declaration）一次只引入命名空间的一个成员。</li>
<li>using声明的有效范围从using声明语句开始，一直到using声明所在的作用域结束为止。在此过程中，外层作用域的同名实体会被隐藏。未加限定的名字只能在using声明所在的作用域及其内层作用域中使用。</li>
<li>using声明可以出现在全局作用域、局部作用域、命名空间作用域和类的作用域中。在类的作用域中使用时，using声明只能指向基类成员。</li>
<li>和using声明不同，using指示使某个命名空间中的所有名字都可见</li>
<li>using指示可以出现在全局作用域、局部作用域和命名空间作用域中，不能出现在类的作用域中。</li>
<li>如果对std等命名空间使用了using指示而未做任何特殊控制的话，会重新引入多个库之间的名字冲突问题。</li>
<li>using指示具有将命名空间成员提升到包含命名空间本身和using指示的最近外层作用域的能力。<pre><code>// namespace A and function f are defined at global scope
namespace A
&#123;
    int i, j;
&#125;

void f()
&#123;
    using namespace A;  // injects the names from A into the global scope
    cout &lt;&lt; i * j &lt;&lt; endl;  // uses i and j from namespace A
    // ...
&#125;
</code></pre>
</li>
<li>当命名空间被注入到其外层作用域之后，该命名空间中定义的名字可能会与其外层作用域的成员冲突。这种冲突允许存在，但是要想使用冲突的名字，就必须明确指出名字的版本。<pre><code>namespace blip
&#123;
    int i = 16, j = 15, k = 23;
    // other declarations
&#125;
int j = 0;  // ok: j inside blip is hidden inside a namespace

void manip()
&#123;
    // using directive; the names in blip are &#39;&#39;added&#39;&#39; to the global scope
    using namespace blip;   // clash between ::j and blip::j
    // detected only if j is used
    ++i;    // sets blip::i to 17
    ++j;    // error ambiguous: global j or blip::j?
    ++::j;  // ok: sets global j to 1
    ++blip::j;    // ok: sets blip::j to 16
    int k = 97;   // local k hides blip::k
    ++k;    // sets local k to 98
&#125;
</code></pre>
</li>
<li>头文件如果在其顶层作用域中使用using声明或using指示，则会将名字注入到包含该头文件的所有文件中。通常，头文件只负责定义接口部分的名字，而不定义实现部分的名字。因此，头文件最多只能在它的函数或命名空间内使用using声明或using指示。</li>
<li>相比于使用using指示，在程序中对命名空间中的每个成员分别使用using声明效果更好。<ul>
<li>如果程序使用了多个不同的库，而这些库中的名字通过using指示变得可见，则全局命名空间污染问题将重新出现。</li>
<li>using指示引发的二义性错误只有在使用了冲突名字的地方才会被发现。而using声明引发的二义性错误在声明处就能发现。</li>
</ul>
</li>
<li>建议在命名空间本身的实现文件中使用using指示。</li>
</ul>
<h3 id="18-2-3-类、命名空间与作用域"><a href="#18-2-3-类、命名空间与作用域" class="headerlink" title="18.2.3 类、命名空间与作用域"></a>18.2.3 类、命名空间与作用域</h3><ul>
<li>对命名空间内部名字的查找遵循常规查找规则：由内向外依次查找每个外层作用域。只有位于开放的块中且在使用点之前声明的名字才会被考虑。</li>
<li>对于位于命名空间中的类来说，名字的常规查找规则依然适用：当成员函数使用某个名字时，首先在该成员中查找，然后在类（包括基类）中查找，接着在外层作用域中查找。</li>
<li>可以从函数的限定名推断出名字查找时检查作用域的顺序，限定名以相反的顺序指出被查找的作用域。</li>
<li>命名空间中名字的隐藏规则有一个例外：传递给函数一个类类型的对象、指向类的引用或指针时，除了在常规作用域查找名字外，还会查找实参类所属的命名空间。该例外允许概念上作为类接口一部分的非成员函数无须单独的using声明就能被程序使用。<pre><code>std::string s;
std::cin &gt;&gt; s;
// 等价于
std::operator&gt;&gt;(std::cin, s);

// 若该规则不存在，则必须为&gt;&gt;运算符提供using声明
using std::operator&gt;&gt;;
// 或者显式使用std::operator&gt;&gt;
std::operator&gt;&gt;(std::cin, s);
</code></pre>
</li>
<li>标准库定义的move和forward模板函数接受一个右值引用形参，可以匹配任何类型。如果应用程序也定义了一个接受单一参数的move和forward函数，则不管形参是什么类型，都会与标准库的版本冲突。对于这两个函数来说，冲突大多是无意的，因此建议使用它们的含有限定语的完整版本（即std::move、std::forward）。</li>
<li>如果一个未声明的类或函数第一次出现在友元声明中，则会被认定是离它最近的外层命名空间的成员。</li>
</ul>
<h3 id="18-2-4-重载与命名空间"><a href="#18-2-4-重载与命名空间" class="headerlink" title="18.2.4 重载与命名空间"></a>18.2.4 重载与命名空间</h3><ul>
<li>using声明和using指示能将某些函数添加到候选函数集。</li>
<li>确定候选函数集时，会在函数的每个实参类（以及实参类的基类）所属的命名空间中搜索候选函数。这些命名空间中所有与被调用函数同名的函数都会被添加到候选集当中，即使其中某些函数在调用语句处不可见也是如此。</li>
<li>using声明语句声明的是一个名字，而非一个特定的函数。一个using声明囊括了重载函数的所有版本以确保不违反命名空间的接口。<pre><code>using NS::print(int);   // error: cannot specify a parameter list
using NS::print;        // ok: using declarations specify names only
</code></pre>
</li>
<li>一个using声明引入的函数将重载该声明语句所属作用域中已有的其他同名函数。如果using声明出现在局部作用域中，则引入的名字会隐藏外层作用域的相关声明。如果using声明所在的作用域中已经有一个函数与引入的函数同名且形参列表相同，则该using声明会引发错误。除此之外，using声明将为引入的名字添加额外的重载实例，并最终扩充候选函数集的规模。</li>
<li>using指示将命名空间的成员提升到外层作用域中，如果命名空间的某个函数与该命名空间所属作用域中的函数同名，则命名空间的函数会被添加到重载集合中。</li>
<li>与using声明不同，using指示引入一个与已有函数形参列表完全相同的函数并不会引发错误。但需要明确指出调用的是命名空间中的函数版本还是当前作用域中的版本。</li>
<li>如果存在多个using指示，则来自每个命名空间的名字都会成为候选函数集的一部分。</li>
</ul>
<h2 id="18-3-多重继承与虚继承"><a href="#18-3-多重继承与虚继承" class="headerlink" title="18.3 多重继承与虚继承"></a>18.3 多重继承与虚继承</h2><ul>
<li>多重继承（Multiple inheritance）是指从多个直接基类中产生派生类的能力。多重继承的派生类继承了所有父类的属性。</li>
</ul>
<h3 id="18-3-1-多重继承"><a href="#18-3-1-多重继承" class="headerlink" title="18.3.1 多重继承"></a>18.3.1 多重继承</h3><ul>
<li>派生类的派生列表中可以包含多个基类。每个基类都包含一个可选的访问说明符。和单继承相同，如果访问说明符被省略，则关键字class对应的默认访问说明符是private，关键字struct对应的是public。<pre><code>class Bear : public ZooAnimal &#123; /* ... */ &#125;;
class Panda : public Bear, public Endangered &#123; /* ... */ &#125;;
</code></pre>
</li>
<li>和单继承相同，多重继承的派生列表也只能包含已经被定义过的类，且这些类不能是final的。</li>
<li>多重继承关系中，派生类对象包含每个基类的子对象</li>
<li>构造一个多重继承的派生类对象将同时构造并初始化它的所有基类子对象。<pre><code>// explicitly initialize both base classes
Panda::Panda(std::string name, bool onExhibit)
    : Bear(name, onExhibit, &quot;Panda&quot;),
    Endangered(Endangered::critical) &#123; &#125;
// implicitly uses the Bear default constructor to initialize the Bear subobject
Panda::Panda()
    : Endangered(Endangered::critical) &#123; &#125;
</code></pre>
</li>
<li>派生类的构造函数初始值列表将实参分别传递给每个直接基类。其中基类的构造顺序与派生列表中基类的出现顺序一致，与构造函数初始值列表中基类的顺序无关。</li>
<li>C++11允许派生类从它的一个或多个基类中继承构造函数，但如果从多个基类中继承了相同的构造函数（即形参列表完全相同），程序会产生错误。<pre><code>struct Base1
&#123;
    Base1() = default;
    Base1(const std::string&amp;);
    Base1(std::shared_ptr&lt;int&gt;);
&#125;;

struct Base2
&#123;
    Base2() = default;
    Base2(const std::string&amp;);
    Base2(int);
&#125;;

// error: D1 attempts to inherit D1::D1 (const string&amp;) from both base classes
struct D1: public Base1, public Base2
&#123;
    using Base1::Base1;   // inherit constructors from Base1
    using Base2::Base2;   // inherit constructors from Base2
&#125;;
</code></pre>
</li>
<li>如果一个类从它的多个基类中继承了相同的构造函数，则必须为该构造函数定义其自己的版本。<pre><code>struct D2: public Base1, public Base2
&#123;
    using Base1::Base1;    // inherit constructors from Base1
    using Base2::Base2;    // inherit constructors from Base2
    // D2 must define its own constructor that takes a string
    D2(const string &amp;s): Base1(s), Base2(s) &#123; &#125;
    D2() = default;   // needed once D2 defines its own constructor
&#125;;
</code></pre>
</li>
<li>和单继承相同，多重继承的派生类如果定义了自己的拷贝&#x2F;赋值构造函数和赋值运算符，则必须在完整的对象上执行这些操作。只有当派生类使用的是合成版本的拷贝、移动或赋值成员时，才会自动处理其基类部分。在合成版本的拷贝控制成员中，每个基类分别使用自己的对应成员隐式地完成构造、赋值或销毁等工作。</li>
</ul>
<h3 id="18-3-2-类型转换与多个基类"><a href="#18-3-2-类型转换与多个基类" class="headerlink" title="18.3.2 类型转换与多个基类"></a>18.3.2 类型转换与多个基类</h3><ul>
<li>多重继承和单继承相同，某个可访问基类的指针或引用可以直接指向派生类对象。</li>
<li>编译器不会在派生类向基类的几种转换中进行比较和选择。<pre><code>void print(const Bear&amp;);
void print(const Endangered&amp;);

Panda ying_yang(&quot;ying_yang&quot;);
print(ying_yang);   // error: ambiguous
</code></pre>
</li>
<li>和单继承相同，对象、指针和引用的静态类型决定了我们可以使用的成员。</li>
</ul>
<h3 id="18-3-3-多重继承下的类作用域"><a href="#18-3-3-多重继承下的类作用域" class="headerlink" title="18.3.3 多重继承下的类作用域"></a>18.3.3 多重继承下的类作用域</h3><ul>
<li>在单继承中，派生类的作用域嵌套在直接基类和间接基类的作用域中。名称查找沿着继承体系自底向上进行，直到找到所需的名字。派生类的名字会隐藏基类的同名成员。在多重继承中，相同的查找过程在所有基类中同时进行。如果名字在多个基类中都被找到，则会产生二义性错误。</li>
<li>派生类可以从多个基类中分别继承名字相同的成员，但是在使用该名字时必须明确指出其版本。避免潜在二义性的最好方法是在派生类中定义新的版本。</li>
</ul>
<h3 id="18-3-4-虚继承"><a href="#18-3-4-虚继承" class="headerlink" title="18.3.4 虚继承"></a>18.3.4 虚继承</h3><ul>
<li>尽管在派生列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类。派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接继承某个基类，然后通过另一个基类再次间接继承该类。</li>
<li>默认情况下，派生类含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了多次，则派生类中会包含该类的多个子对象。这种默认情况对某些类并不适用。例如iostream，它直接继承自istream和ostream，而istream和ostream都继承自base_ios，所以iostream继承了base_ios两次。如果iostream对象包含base_ios的两份拷贝，则无法在同一个缓冲区中进行读写操作。</li>
<li>虚继承可以让某个类共享它的基类，其中共享的基类子对象称为虚基类（virtual base class）。在该机制下，不论虚基类在继承体系中出现了多少次，派生类都只包含唯一一个共享的虚基类子对象。</li>
<li>通常情况下，使用虚继承的类层次是由一个人或一个项目组一次性设计完成的。对于一个独立开发的类来说，很少需要基类中的某一个是虚基类，况且新基类的开发者也无法改变已存在的类体系。</li>
<li>虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。</li>
<li>指定虚基类的方式是在派生列表中添加关键字virtual。<pre><code>// the order of the keywords public and virtual is not significant
class Raccoon : public virtual ZooAnimal &#123; /* ... */ &#125;;
class Bear : virtual public ZooAnimal &#123; /* ... */ &#125;;
</code></pre>
</li>
<li>如果某个类指定了虚基类，则该类的派生仍按照常规方式进行。</li>
<li>不论基类是不是虚基类，派生类对象都能被可访问基类的指针或引用操作。</li>
<li>因为在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被直接访问，而且不会产生二义性。此外，如果虚基类的成员只被一条派生路径覆盖，则也可以直接访问该成员。但如果成员被多个基类覆盖，则一般情况下派生类必须为该成员定义新的版本。例如，假设类B定义了一个名为X的成员，D1和D2都从B虚继承得到，D继承了D1和D2。则在D的作用域中，X通过D的两个基类都是可见的。如果通过D的对象使用X，则有三种可能性：<ul>
<li>如果D1和D2中都没有X的定义，则X会被解析为B的成员，此时不存在二义性。</li>
<li>如果D1和D2中的某一个定义了X，派生类的X会比共享虚基类B的X优先级更高，此时同样没有二义性。</li>
<li>如果D1和D2都定义了X，则直接访问X会产生二义性问题。</li>
</ul>
</li>
</ul>
<h3 id="18-3-5-构造函数与虚继承"><a href="#18-3-5-构造函数与虚继承" class="headerlink" title="18.3.5 构造函数与虚继承"></a>18.3.5 构造函数与虚继承</h3><ul>
<li>在虚派生中，虚基类是由最低层的派生类初始化的。如果按普通规则处理，虚基类将会在多条继承路径上被重复初始化。</li>
<li>继承体系中的每个类都可能在某个时刻成为“最低层的派生类”。只要能创建虚基类的派生类对象，该派生类的构造函数就必须初始化它的虚基类。即使虚基类不是派生类的直接基类，构造函数也可以进行初始化。</li>
<li>构造含有虚基类的对象时，首先使用提供给最低层派生类构造函数的初始值初始化该对象的虚基类子部分，之后再按照直接基类在派生列表中出现的顺序依次对其初始化。</li>
<li>一个类可以有多个虚基类，此时这些虚子对象按照它们在派生列表中出现的顺序依次构造。</li>
</ul>
<h1 id="第19章-特殊工具与技术"><a href="#第19章-特殊工具与技术" class="headerlink" title="第19章 特殊工具与技术"></a>第19章 特殊工具与技术</h1><h2 id="19-1-控制内存分配（Controlling-Memory-Allocation）"><a href="#19-1-控制内存分配（Controlling-Memory-Allocation）" class="headerlink" title="19.1 控制内存分配（Controlling Memory Allocation）"></a>19.1 控制内存分配（Controlling Memory Allocation）</h2><h3 id="19-1-1-重载new和delete（Overloading-new-and-delete）"><a href="#19-1-1-重载new和delete（Overloading-new-and-delete）" class="headerlink" title="19.1.1 重载new和delete（Overloading new and delete）"></a>19.1.1 重载new和delete（Overloading new and delete）</h3><p>使用<code>new</code>表达式时，实际执行了三步操作：</p>
<ul>
<li><code>new</code>表达式调用名为<code>operator new</code>（或<code>operator new[]</code>）的标准库函数。该函数分配一块足够大、原始、未命名的内存空间以便存储特定类型的对象（或对象数组）。</li>
<li>编译器调用对应的构造函数构造这些对象并初始化。</li>
<li>对象被分配了空间并构造完成，返回指向该对象的指针。</li>
</ul>
<p>使用<code>delete</code>表达式时，实际执行了两步操作：</p>
<ul>
<li>对指针所指向的对象（或对象数组）执行对应的析构函数。</li>
<li>编译器调用名为<code>operator delete</code>（或<code>operator delete[]</code>）的标准库函数释放内存空间。</li>
</ul>
<p>如果程序希望控制内存分配的过程，则需要定义自己的<code>operator new</code>和<code>operator delete</code>函数。编译器会用自定义版本替换标准库版本。</p>
<p>程序可以在全局作用域中定义<code>operator new</code>和<code>operator delete</code>函数，也可以将其定义为成员函数。编译器发现<code>new</code>或<code>delete</code>表达式后，将在程序中查找可供调用的<code>operator</code>函数。如果被分配或释放的对象是类类型，编译器会先在类及其基类的作用域中查找。如果该类含有<code>operator</code>成员，则表达式会调用这些成员。否则编译器会继续在全局作用域查找。如果找到自定义版本，则使用该版本的函数。如果没找到，则使用标准库定义的版本。</p>
<p>可以使用作用域运算符令<code>new</code>或<code>delete</code>表达式忽略定义在类中的函数，直接执行全局作用域版本。</p>
<p>标准库定义了<code>operator new</code>和<code>operator delete</code>函数的8个重载版本，其中前4个版本可能抛出<code>bad_alloc</code>异常，后4个版本不会抛出异常。重载这些运算符时，必须使用关键字<code>noexcept</code>指定其不抛出异常。</p>
<pre class=" language-c++"><code class="language-c++">// these versions might throw an exception
void *operator new(size_t);     // allocate an object
void *operator new[](size_t);   // allocate an array
void *operator delete(void*) noexcept;      // free an object
void *operator delete[](void*) noexcept;    // free an array
// versions that promise not to throw
void *operator new(size_t, nothrow_t&) noexcept;
void *operator new[](size_t, nothrow_t&) noexcept;
void *operator delete(void*, nothrow_t&) noexcept;
void *operator delete[](void*, nothrow_t&) noexcept
</code></pre>
<p><code>nothrow_t</code>类型是定义在头文件<em>new</em>中的一个结构体，这个类型不包含任何成员。头文件<em>new</em>还定义了一个名为<code>nothrow</code>的<code>const</code>对象，用户可以通过这个对象请求<code>new</code>的非抛出版本。</p>
<p>将<code>operator</code>函数定义为类的成员时，它们是隐式静态的，无须显式地声明<code>static</code>。因为<code>operator new</code>用在对象构造之前，<code>operator delete</code>用在对象销毁之后，所以它们必须是静态成员，而且不能操纵类的任何数据成员。</p>
<p><code>operator new</code>和<code>operator new[]</code>函数的返回类型必须是<code>void*</code>，第一个形参的类型必须是<code>size_t</code>且不能有默认实参。编译器调用<code>operator new</code>时，用存储指定类型对象所需的字节数初始化<code>size_t</code>形参；调用<code>operator new[]</code>时，传入函数的则是存储数组中所有元素所需的空间。</p>
<p>自定义<code>operator new</code>函数时可以为它提供额外的形参，用到这些自定义函数的<code>new</code>表达式必须使用<code>new</code>的定位形式传递参数。下面这种形式的<code>new</code>函数只供标准库使用，不能被用户重定义：</p>
<pre class=" language-c++"><code class="language-c++">void *operator new(size_t, void*);   // this version may not be redefined
</code></pre>
<p><code>operator delete</code>和<code>operator delete[]</code>函数的返回类型必须是<code>void</code>，第一个形参的类型必须是<code>void*</code>。函数被调用时，编译器会用指向待释放内存的指针来初始化<code>void*</code>形参。</p>
<p>将<code>operator delete</code>或<code>operator delete[]</code>定义为类的成员时，可以包含另一个类型为<code>size_t</code>的形参。该形参的初始值是第一个形参所指向对象的字节数。<code>size_t</code>形参可用于删除继承体系中的对象。如果基类有一个虚析构函数，则传递给<code>operator delete</code>的字节数会因待删除指针所指向对象的动态类型不同而有所区别。实际运行的<code>operator delete</code>函数版本也由对象的动态类型决定。</p>
<p><code>malloc</code>函数接受一个表示待分配字节数的<code>size_t</code>参数，返回指向分配空间的指针，或者返回0以表示分配失败。<code>free</code>函数接受一个<code>void*</code>参数，它是<code>malloc</code>返回的指针的副本，<code>free</code>将相关内存返回给系统。调用<code>free(0)</code>没有任何意义。</p>
<pre class=" language-c++"><code class="language-c++">void *operator new(size_t size)
{
    if (void *mem = malloc(size))
        return mem;
    else
        throw bad_alloc();
}

void operator delete(void *mem) noexcept
{
    free(mem);
}
</code></pre>
<h3 id="19-1-2-定位new表达式（Placement-new-Expressions）"><a href="#19-1-2-定位new表达式（Placement-new-Expressions）" class="headerlink" title="19.1.2 定位new表达式（Placement new Expressions）"></a>19.1.2 定位new表达式（Placement new Expressions）</h3><p>在C++的早期版本中，<code>allocator</code>类还不是标准库的一部分。如果程序想分开内存分配和初始化过程，需要直接调用<code>operator new</code>和<code>operator delete</code>函数。它们类似<code>allocator</code>类的<code>allocate</code>和<code>deallocate</code>成员，负责分配或释放内存空间，但不会构造或销毁对象。</p>
<p>不能使用<code>allocator</code>类的<code>construct</code>函数在<code>operator new</code>分配的内存空间中构造对象，而应该使用定位<code>new</code>表达式构造。</p>
<pre class=" language-c++"><code class="language-c++">new (place_address) type
new (place_address) type (initializers)
new (place_address) type [size]
new (place_address) type [size] { braced initializer list }
</code></pre>
<p>其中<em>place_address</em>是一个指针。<em>initializers</em>是一个以逗号分隔的初始值列表（可能为空），该列表用于构造新分配的对象。</p>
<p>当仅通过一个地址值调用定位<code>new</code>时，它会使用<code>operator new(size_t, void*)</code>函数（用户无法重载的版本）。该函数不分配任何内存，直接返回指针形参。然后由<code>new</code>表达式负责在指定的地址初始化对象。</p>
<p>传递给<code>construct</code>函数的指针必须指向同一个<code>allocator</code>对象分配的空间，但是传递给定位<code>new</code>的指针无须指向<code>operator new</code>分配的内存，甚至不需要指向动态内存。</p>
<p>调用析构函数会销毁对象，但不会释放内存。如果需要的话，可以重新使用该空间。</p>
<h2 id="19-2-运行时类型识别（Run-Time-Type-Identification）"><a href="#19-2-运行时类型识别（Run-Time-Type-Identification）" class="headerlink" title="19.2 运行时类型识别（Run-Time Type Identification）"></a>19.2 运行时类型识别（Run-Time Type Identification）</h2><p>运行时类型识别（RTTI）的功能由两个运算符实现：</p>
<ul>
<li><code>typeid</code>运算符，用于返回表达式的类型。</li>
<li><code>dynamic_cast</code>运算符，用于将基类的指针或引用安全地转换为派生类的指针或引用。</li>
</ul>
<p>RTTI运算符适用于以下情况：想通过基类对象的指针或引用执行某个派生类操作，并且该操作不是虚函数。</p>
<h3 id="19-2-1-dynamic-cast运算符（The-dynamic-cast-Operator）"><a href="#19-2-1-dynamic-cast运算符（The-dynamic-cast-Operator）" class="headerlink" title="19.2.1 dynamic_cast运算符（The dynamic_cast Operator）"></a>19.2.1 dynamic_cast运算符（The dynamic_cast Operator）</h3><p><code>dynamic_cast</code>运算符的形式如下：</p>
<pre class=" language-c++"><code class="language-c++">dynamic_cast<type*>(e)
dynamic_cast<type&>(e)
dynamic_cast<type&&>(e)
</code></pre>
<p>其中<em>type</em>是一个类类型，并且通常情况下该类型应该含有虚函数。在第一种形式中，<em>e</em>必须是一个有效指针；在第二种形式中，<em>e</em>必须是一个左值；在第三种形式中，<em>e</em>不能是左值。在所有形式中，<em>e</em>的类型必须符合以下条件之一：</p>
<ul>
<li><em>e</em>是<em>type</em>的公有派生类。</li>
<li><em>e</em>是<em>type</em>的公有基类。</li>
<li><em>e</em>和<em>type</em>类型相同。</li>
</ul>
<p>如果条件符合，则类型转换成功，否则转换失败。转换失败可能有两种结果：</p>
<ul>
<li><p>如果<code>dynamic_cast</code>语句的转换目标是指针类型，则结果为0。</p>
<pre class=" language-c++"><code class="language-c++">if (Derived *dp = dynamic_cast<Derived*>(bp))
{
    // use the Derived object to which dp points
}
else
{   // bp points at a Base object
    // use the Base object to which bp points
}
</code></pre>
</li>
<li><p>如果<code>dynamic_cast</code>语句的转换目标是引用类型，则抛出<code>bad_cast</code>异常（定义在头文件<em>typeinfo</em>中）。</p>
<pre class=" language-c++"><code class="language-c++">void f(const Base &b)
{
    try 
    {
        const Derived &d = dynamic_cast<const Derived&>(b);
        // use the Derived object to which b referred
    }
    catch (bad_cast)
    {
        // handle the fact that the cast failed
    }
}
</code></pre>
</li>
</ul>
<p>在条件判断部分执行<code>dynamic_cast</code>可以确保类型转换和结果检查在同一条表达式中完成。</p>
<p>可以对一个空指针执行<code>dynamic_cast</code>，结果是所需类型的空指针。</p>
<h3 id="19-2-2-typeid运算符（The-typeid-Operator）"><a href="#19-2-2-typeid运算符（The-typeid-Operator）" class="headerlink" title="19.2.2 typeid运算符（The typeid Operator）"></a>19.2.2 typeid运算符（The typeid Operator）</h3><p><code>typeid</code>表达式的形式是<code>typeid(e)</code>，其中<em>e</em>可以是任意表达式或类型名称。<code>typeid</code>的结果是一个指向常量对象的引用，该对象的类型是标准库<code>type_info</code>（定义在头文件<em>typeinfo</em>中）或<code>type_info</code>的公有派生类型。</p>
<p><code>typeid</code>可以作用于任何类型的表达式，其中的顶层<code>const</code>会被忽略。如果表达式是一个引用，则<code>typeid</code>返回该引用所指对象的类型。当<code>typeid</code>作用于数组或函数时，不会执行向指针的标准类型转换。</p>
<p>当<code>typeid</code>的运算对象不属于类类型或者是一个不包含任何虚函数的类时，<code>typeid</code>返回其静态类型。而当运算对象是至少包含一个虚函数的类的左值时，<code>typeid</code>的结果直到运行期间才会确定。</p>
<p>通常情况下，<code>typeid</code>用于比较两条表达式的类型是否相同，或者比较一条表达式的类型是否与指定类型相同。</p>
<pre class=" language-c++"><code class="language-c++">C++Derived *dp = new Derived;
Base *bp = dp;   // both pointers point to a Derived object
// compare the type of two objects at run time
if (typeid(*bp) == typeid(*dp))
{
    // bp and dp point to objects of the same type
}
// test whether the run-time type is a specific type
if (typeid(*bp) == typeid(Derived))
{
    // bp actually points to a Derived
}
</code></pre>
<p><code>typeid</code>应该作用于对象。当<code>typeid</code>作用于指针时，返回的结果是该指针的静态编译类型。</p>
<pre class=" language-c++"><code class="language-c++">// test always fails: the type of bp is pointer to Base
if (typeid(bp) == typeid(Derived))
{
    // code never executed
}
</code></pre>
<p>只有当类型含有虚函数时，编译器才会对<code>typeid</code>的表达式求值以确定返回类型。对于<code>typeid(*p)</code>，如果指针<em>p</em>所指向的类型不包含虚函数，则<em>p</em>可以是一个无效指针。否则<code>*p</code>会在运行期间求值，此时<em>p</em>必须是一个有效指针。如果<em>p</em>是空指针，<code>typeid(*p)</code>会抛出<code>bad_typeid</code>异常。</p>
<h3 id="19-2-3-使用RTTI（Using-RTTI）"><a href="#19-2-3-使用RTTI（Using-RTTI）" class="headerlink" title="19.2.3 使用RTTI（Using RTTI）"></a>19.2.3 使用RTTI（Using RTTI）</h3><p>使用RTTI可以为具有继承关系的类实现相等运算符。</p>
<p>相等运算符的形参是基类的引用。</p>
<pre class=" language-c++"><code class="language-c++">class Base
{
    friend bool operator==(const Base&, const Base&);
public:
    // interface members for Base
protected:
    virtual bool equal(const Base&) const;
    // data and other implementation members of Base
};

class Derived: public Base
{
public:
    // other interface members for Derived
protected:
    bool equal(const Base&) const;
    // data and other implementation members of Derived
};
</code></pre>
<p>使用<code>typeid</code>检查两个运算对象的类型是否一致，类型一致才会继续判断每个数据成员的取值是否相同。</p>
<pre class=" language-c++"><code class="language-c++">bool operator==(const Base &lhs, const Base &rhs)
{
    // returns false if typeids are different; otherwise makes a virtual call to equal
    return typeid(lhs) == typeid(rhs) && lhs.equal(rhs);
}
</code></pre>
<p>每个类定义的<code>equal</code>函数负责比较类型自己的数据成员。<code>equal</code>函数的形参都是基类的引用，但是在比较之前需要先把运算对象转换成自己的类型。</p>
<pre class=" language-c++"><code class="language-c++">bool Derived::equal(const Base &rhs) const
{
    // we know the types are equal, so the cast won't throw
    auto r = dynamic_cast<const Derived&>(rhs);
    // do the work to compare two Derived objects and return the result
}

bool Base::equal(const Base &rhs) const
{
// do whatever is required to compare to Base objects
}
</code></pre>
<h3 id="19-2-4-type-info类（The-type-info-Class）"><a href="#19-2-4-type-info类（The-type-info-Class）" class="headerlink" title="19.2.4 type_info类（The type_info Class）"></a>19.2.4 type_info类（The type_info Class）</h3><p><code>type_info</code>类的精确定义会根据编译器的不同而略有差异。但是C++规定<code>type_info</code>必须定义在头文件<em>typeinfo</em>中，并且至少提供以下操作：</p>
)

<p><code>type_info</code>类一般是作为一个基类出现，所以它还应该提供一个公有虚析构函数。当编译器希望提供额外的类型信息时，通常在<code>type_info</code>的派生类中完成。</p>
<p><code>type_info</code>类没有默认构造函数，而且它的拷贝和移动构造函数以及赋值运算符都被定义为删除的。创建<code>type_info</code>对象的唯一方式就是使用<code>typeid</code>运算符。</p>
<p>对于某种给定类型来说，<code>name</code>成员的返回值因编译器而异并且不一定与在程序中使用的名字一致。对于<code>name</code>返回值的唯一要求就是类型不同则返回的字符串必须有所区别。</p>
<h2 id="19-3-枚举类型（Enumerations）"><a href="#19-3-枚举类型（Enumerations）" class="headerlink" title="19.3 枚举类型（Enumerations）"></a>19.3 枚举类型（Enumerations）</h2><p>和类一样，每个枚举类型都定义了一种新的类型。枚举属于字面值常量类型。</p>
<p>C++包含两种枚举：</p>
<ul>
<li><p>限定作用域的枚举（scoped enumeration，C++11新增）。定义形式是关键字<code>enum class</code>（或<code>enum struct</code>）后接枚举类型名字以及用花括号包围、以逗号分隔的枚举成员（enumerator）列表。</p>
<pre class=" language-c++"><code class="language-c++">enum class open_modes
{
    input,
    output,
    append
};
</code></pre>
</li>
<li><p>不限定作用域的枚举（unscoped enumeration）。定义时省略关键字<code>class</code>（或<code>struct</code>），枚举类型名字是可选的。</p>
<pre class=" language-c++"><code class="language-c++">C++// unscoped enumeration
enum color
{
    red,
    yellow,
    green
};
// unnamed, unscoped enum
enum
{
    floatPrec = 6,
    doublePrec = 10,
    double_doublePrec = 10
};
</code></pre>
<p>如果枚举是未命名的，则只能在定义该枚举时一同定义它的对象。</p>
</li>
</ul>
<p>在限定作用域的枚举类型中，枚举成员的名字遵循常规作用域规则，并且在枚举类型的作用域外是不可访问的。与之相反，在不限定作用域的枚举类型中，枚举成员的作用域与枚举类型本身的作用域相同。</p>
<pre class=" language-c++"><code class="language-c++">enum color { red, yellow, green };   // unscoped enumeration
enum stoplight { red, yellow, green };   // error: redefines enumerators
enum class peppers { red, yellow, green };   // ok: enumerators are hidden
color eyes = green;    // ok: enumerators are in scope for an unscoped enumeration
peppers p = green;     // error: enumerators from peppers are not in scope
// color::green is in scope but has the wrong type
color hair = color::red;      // ok: we can explicitly access the enumerators
peppers p2 = peppers::red;    // ok: using red from peppers
</code></pre>
<p>默认情况下，枚举值从0开始，依次加1。也可以直接为枚举成员指定特定的值。</p>
<pre class=" language-c++"><code class="language-c++">enum class intTypes
{
    charTyp = 8, shortTyp = 16, intTyp = 16,
    longTyp = 32, long_longTyp = 64
};
</code></pre>
<p>枚举值可以不唯一。如果没有显式提供初始值，则当前枚举成员的值等于之前枚举成员的值加1。</p>
<p>枚举成员是<code>const</code>的，因此在初始化枚举成员时提供的初始值必须是常量表达式。</p>
<p>可以在任何需要常量表达式的地方使用枚举成员。如：</p>
<ul>
<li>定义枚举类型的<code>constexpr</code>变量。</li>
<li>将枚举类型对象作为<code>switch</code>语句的表达式，而将枚举值作为<code>case</code>标签。</li>
<li>将枚举类型作为非类型模板形参使用。</li>
<li>在类的定义中初始化枚举类型的静态数据成员。</li>
</ul>
<p>初始化枚举对象或者给枚举对象赋值时，必须使用该类型的一个枚举成员或者该类型的另一个对象。即使某个整型值恰好与枚举成员的值相等，也不能用其初始化枚举对象。</p>
<pre class=" language-c++"><code class="language-c++">open_modes om = 2;        // error: 2 is not of type open_modes
om = open_modes::input;   // ok: input is an enumerator of open_modes
</code></pre>
<p>不限定作用域的枚举类型对象或枚举成员能自动转换成整型。</p>
<pre class=" language-c++"><code class="language-c++">int i = color::red;     // ok: unscoped enumerator implicitly converted to int
int j = peppers::red;   // error: scoped enumerations are not implicitly converted
</code></pre>
<p>枚举是由某种整数类型表示的。C++11中，可以在枚举名字后面指定用来表示枚举成员的整型类型。</p>
<pre class=" language-c++"><code class="language-c++">enum intValues : unsigned long long
{ 
    /*...*/ 
};
</code></pre>
<p>如果没有指定枚举的潜在类型，则默认情况下限定作用域的枚举成员类型是<code>int</code>。不限定作用域的枚举成员不存在默认类型。</p>
<p>C++11中可以提前声明枚举。枚举的前置声明必须指定（无论隐式或显式）其成员的类型。</p>
<pre class=" language-c++"><code class="language-c++">// forward declaration of unscoped enum named intValues
enum intValues : unsigned long long;    // unscoped, must specify a type
enum class open_modes;    // scoped enums can use int by default
</code></pre>
<h2 id="19-4-类成员指针（Pointer-to-Class-Member）"><a href="#19-4-类成员指针（Pointer-to-Class-Member）" class="headerlink" title="19.4 类成员指针（Pointer to Class Member）"></a>19.4 类成员指针（Pointer to Class Member）</h2><p>成员指针（pointer to member）是指可以指向类的非静态成员的指针。</p>
<p>成员指针的类型包括类的类型和成员的类型。初始化成员指针时，会令其指向类的某个成员，但是不指定该成员所属的对象。直到使用成员指针时，才提供成员所属的对象。</p>
<h3 id="19-4-1-数据成员指针（Pointers-to-Data-Members）"><a href="#19-4-1-数据成员指针（Pointers-to-Data-Members）" class="headerlink" title="19.4.1 数据成员指针（Pointers to Data Members）"></a>19.4.1 数据成员指针（Pointers to Data Members）</h3><p>声明成员指针时必须在<code>*</code>前添加<code>classname::</code>以表示当前定义的指针可以指向<em>classname</em>的成员。</p>
<pre class=" language-c++"><code class="language-c++">class Screen
{
public:
    typedef std::string::size_type pos;
    char get_cursor() const { return contents[cursor]; }
    char get() const;
    char get(pos ht, pos wd) const;
    
private:
    std::string contents;
    pos cursor;
    pos height, width;
}

// pdata can point to a string member of a const (or non const) Screen object
const string Screen::*pdata;
</code></pre>
<p>初始化或者给成员指针赋值时，需要指定它所指向的成员。</p>
<pre class=" language-c++"><code class="language-c++">pdata = &Screen::contents;
</code></pre>
<p>成员指针使用<code>.*</code>和<code>-&gt;*</code>来获得其指向对象的成员。</p>
<pre class=" language-c++"><code class="language-c++">Screen myScreen, *pScreen = &myScreen;
// .* dereferences pdata to fetch the contents member from the object myScreen
auto s = myScreen.*pdata;
// ->* dereferences pdata to fetch contents from the object to which pScreen points
s = pScreen->*pdata;
</code></pre>
<p>常规的访问控制规则对成员指针同样有效。数据成员一般是私有的，因此通常不能直接获得数据成员的指针。如果类希望外部代码能访问它的私有数据成员，可以定义一个函数，令其返回指向私有成员的指针。</p>
<h3 id="19-4-2-成员函数指针（Pointers-to-Member-Functions）"><a href="#19-4-2-成员函数指针（Pointers-to-Member-Functions）" class="headerlink" title="19.4.2 成员函数指针（Pointers to Member Functions）"></a>19.4.2 成员函数指针（Pointers to Member Functions）</h3><p>类似于其他函数指针，指向成员函数的指针也需要指定目标函数的返回类型和形参列表。如果成员函数是<code>const</code>成员或引用成员，则指针也必须包含<code>const</code>或引用限定符。</p>
<pre class=" language-c++"><code class="language-c++">// pmf is a pointer that can point to a Screen member function that is const
// that returns a char and takes no arguments
auto pmf = &Screen::get_cursor;
</code></pre>
<p>如果成员函数存在重载问题，则必须显式声明指针指向的函数类型。</p>
<pre class=" language-c++"><code class="language-c++">char (Screen::*pmf2)(Screen::pos, Screen::pos) const;
pmf2 = &Screen::get;
</code></pre>
<p>和普通函数指针不同，在成员函数和指向该成员的指针之间不存在自动转换规则。</p>
<pre class=" language-c++"><code class="language-c++">// pmf points to a Screen member that takes no arguments and returns char
pmf = &Screen::get;    // must explicitly use the address-of operator
pmf = Screen::get;     // error: no conversion to pointer for member functions
</code></pre>
<p>成员函数指针使用<code>.*</code>和<code>-&gt;*</code>来调用类的成员函数。</p>
<pre class=" language-c++"><code class="language-c++">Screen myScreen, *pScreen = &myScreen;
// call the function to which pmf points on the object to which pScreen points
char c1 = (pScreen->*pmf)();
// passes the arguments 0, 0 to the two-parameter version of get on the object myScreen
char c2 = (myScreen.*pmf2)(0, 0);
</code></pre>
<p>可以使用类型别名来增强含有成员指针的代码的可读性。</p>
<h3 id="19-2-3-将成员函数用作可调用对象（Using-Member-Functions-as-Callable-Objects）"><a href="#19-2-3-将成员函数用作可调用对象（Using-Member-Functions-as-Callable-Objects）" class="headerlink" title="19.2.3 将成员函数用作可调用对象（Using Member Functions as Callable Objects）"></a>19.2.3 将成员函数用作可调用对象（Using Member Functions as Callable Objects）</h3><p>成员指针不是一个可调用对象，不支持函数调用运算符。</p>
<pre class=" language-c++"><code class="language-c++">auto fp = &string::empty;   // fp points to the string empty function
// error: must use .* or ->* to call a pointer to member
find_if(svec.begin(), svec.end(), fp);
</code></pre>
<p>从成员函数指针获取可调用对象的一种方法是使用标准库模板<code>function</code>。</p>
<pre class=" language-c++"><code class="language-c++">function<bool (const string&)> fcn = &string::empty;
find_if(svec.begin(), svec.end(), fcn);
</code></pre>
<p>定义一个<code>function</code>对象时，必须指定该对象所能表示的函数类型（即可调用对象的形式）。如果可调用对象是一个成员函数，则第一个形参必须表示该成员是在哪个对象上执行的。</p>
<p>使用标准库功能<code>mem_fn</code>（定义在头文件<em>functional</em>中）可以让编译器推断成员的类型。和<code>function</code>一样，<code>mem_fn</code>可以从成员指针生成可调用对象。但<code>mem_fn</code>可以根据成员指针的类型推断可调用对象的类型，无须显式指定。</p>
<pre class=" language-c++"><code class="language-c++">find_if(svec.begin(), svec.end(), mem_fn(&string::empty));
</code></pre>
<p><code>mem_fn</code>生成的可调用对象可以通过对象和指针调用。</p>
<pre class=" language-c++"><code class="language-c++">auto f = mem_fn(&string::empty);    // f takes a string or a string*
f(*svec.begin());   // ok: passes a string object; f uses .* to call empty
f(&svec[0]);        // ok: passes a pointer to string; f uses .-> to call empty
</code></pre>
<h2 id="19-5-嵌套类（Nested-Classes）"><a href="#19-5-嵌套类（Nested-Classes）" class="headerlink" title="19.5 嵌套类（Nested Classes）"></a>19.5 嵌套类（Nested Classes）</h2><p>一个类可以定义在另一个类的内部，前者被称为嵌套类或嵌套类型（nested type）。嵌套类通常用于定义作为实现部分的类。</p>
<p>外层类的对象和嵌套类的对象是相互独立的。在嵌套类对象中不包含任何外层类定义的成员，在外层类对象中也不包含任何嵌套类定义的成员。</p>
<p>嵌套类的名字在外层类作用域中是可见的，在外层类作用域之外不可见。</p>
<p>外层类对嵌套类的成员没有特殊的访问权限，嵌套类对外层类的成员也没有特殊的访问权限。</p>
<p>嵌套类在其外层类中定义了一个类型成员。和其他成员类似，该类型的访问权限由外层类的访问说明符决定。</p>
<p>嵌套类必须声明在类的内部，但是可以定义在类的内部或外部。在外层类之外定义嵌套类时，必须用外层类的名字限定嵌套类的名字。</p>
<pre class=" language-c++"><code class="language-c++">class TextQuery
{
    class QueryResult;  // nested class to be defined later
};

// we're defining the QueryResult class that is a member of class TextQuery
class TextQuery::QueryResult 
{
    /*...*/
};
</code></pre>
<p>在嵌套类在其外层类之外完成真正的定义之前，它都是一个不完全类型。</p>
<h2 id="19-6-union：一种节省空间的类（union-A-Space-Saving-Class）"><a href="#19-6-union：一种节省空间的类（union-A-Space-Saving-Class）" class="headerlink" title="19.6 union：一种节省空间的类（union: A Space-Saving Class）"></a>19.6 union：一种节省空间的类（union: A Space-Saving Class）</h2><p>联合（union）是一种特殊的类。一个联合可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。给联合的某个成员赋值之后，其他成员会变为未定义状态。分配给联合对象的存储空间至少要能容纳它的最大数据成员。</p>
<p>联合不能包含引用类型的成员。在C++11中，含有构造函数或析构函数的类类型也可以作为联合的成员类型。</p>
<p>联合可以为其成员指定<code>public</code>、<code>protected</code>和<code>private</code>等保护标记。默认情况下，联合的成员都是公有的。</p>
<p>联合可以定义包括构造函数和析构函数在内的成员函数。但是由于联合既不能继承自其他类，也不能作为基类使用，所以在联合中不能含有虚函数。</p>
<p>定义联合时，首先是关键字<code>union</code>，随后是该联合的名字（可选）以及在花括号内的一组成员声明。</p>
<pre class=" language-c++"><code class="language-c++">// objects of type Token have a single member, which could be of any of the listed types
union Token
{
    // members are public by default
    char cval;
    int ival;
    double dval;
};
</code></pre>
<p>默认情况下，联合是未初始化的。可以像显式初始化聚合类一样显式初始化联合，提供的初始值会被用于初始化第一个成员。</p>
<pre class=" language-c++"><code class="language-c++">Token first_token = { 'a' };   // initializes the cval member
</code></pre>
<p>可以使用通用的成员访问运算符访问联合对象的成员。</p>
<pre class=" language-c++"><code class="language-c++">last_token.cval = 'z';
pt->ival = 42;
</code></pre>
<p>匿名联合（anonymous union）是一个未命名的联合，并且在右花括号和分号之间没有任何声明。一旦定义了一个匿名联合，编译器就会自动地为该联合创建一个未命名的对象。在匿名联合的定义所在的作用域内，该联合的成员都是可以直接访问的。</p>
<pre class=" language-c++"><code class="language-c++">union
{   // anonymous union
    char cval;
    int ival;
    double dval;
};  // defines an unnamed object, whose members we can access directly

cval = 'c';   // assigns a new value to the unnamed, anonymous union object
ival = 42;    // that object now holds the value 42
</code></pre>
<p>匿名联合不能包含<code>protected</code>和<code>private</code>成员，也不能定义成员函数。</p>
<p>C++的早期版本规定，在联合中不能含有定义了构造函数或拷贝控制成员的类类型成员。C++11取消了该限制。但是如果联合的成员类型定义了自己的构造函数或拷贝控制成员，该联合的用法会比只含有内置类型成员的联合复杂得多。</p>
<ul>
<li>当联合只包含内置类型的成员时，可以使用普通的赋值语句改变联合的值。但是如果想将联合的值改为类类型成员对应的值，或者将类类型成员的值改为一个其他值，则必须构造或析构该类类型的成员。</li>
<li>当联合只包含内置类型的成员时，编译器会按照成员顺序依次合成默认构造函数或拷贝控制成员。但是如果联合含有类类型成员，并且该类型自定义了默认构造函数或拷贝控制成员，则编译器会为该联合合成对应的版本并将其声明为删除的。</li>
</ul>
<p>对于联合来说，构造或销毁类类型成员的操作非常复杂。通常情况下，可以把含有类类型成员的联合内嵌在另一个类中，这个类可以管理并控制与联合的类类型成员相关的状态转换。</p>
<h2 id="19-7-局部类（Local-Classes）"><a href="#19-7-局部类（Local-Classes）" class="headerlink" title="19.7 局部类（Local Classes）"></a>19.7 局部类（Local Classes）</h2><p>类可以定义在某个函数的内部，这种类被称为局部类。局部类定义的类型只能在定义它的作用域内可见。</p>
<p>局部类的所有成员（包括成员函数）都必须完整定义在类的内部，因此局部类的作用与嵌套类相比相差很远。</p>
<p>局部类中不允许声明静态数据成员。</p>
<p>局部类只能访问外层作用域定义的类型名、静态变量以及枚举成员，不能使用普通局部变量。</p>
<pre class=" language-c++"><code class="language-c++">int a, val;
void foo(int val)
{
    static int si;
    enum Loc { a = 1024, b };
    // Bar is local to foo
    struct Bar 
    {
        Loc locVal;    // ok: uses a local type name
        int barVal;
        void fooBar(Loc l = a)  // ok: default argument is Loc::a
        {
            barVal = val;    // error: val is local to foo
            barVal = ::val;  // ok: uses a global object
            barVal = si;     // ok: uses a static local object
            locVal = b;      // ok: uses an enumerator
        }
    };
    // . . .
}
</code></pre>
<p>常规的访问保护规则对于局部类同样适用。外层函数对局部类的私有成员没有任何访问特权。局部类可以将外层函数声明为友元。</p>
<p>可以在局部类的内部再嵌套一个类。此时嵌套类的定义可以出现在局部类之外，不过嵌套类必须定义在与局部类相同的作用域中。</p>
<pre class=" language-c++"><code class="language-c++">void foo()
{
    class Bar
    {
    public:
        class Nested;   // declares class Nested
    };
    
    // definition of Nested
    class Bar::Nested
    {
    };
}
</code></pre>
<p>局部类内的嵌套类也是一个局部类，必须遵循局部类的各种规定。</p>
<h2 id="19-8-固有的不可移植的特性（Inherently-Nonportable-Features）"><a href="#19-8-固有的不可移植的特性（Inherently-Nonportable-Features）" class="headerlink" title="19.8 固有的不可移植的特性（Inherently Nonportable Features）"></a>19.8 固有的不可移植的特性（Inherently Nonportable Features）</h2><h3 id="19-8-1位域（Bit-fields）"><a href="#19-8-1位域（Bit-fields）" class="headerlink" title="19.8.1位域（Bit-fields）"></a>19.8.1位域（Bit-fields）</h3><p>类可以将其非静态数据成员定义成位域，在一个位域中含有一定数量的二进制位。当程序需要向其他程序或硬件设备传递二进制数据时，通常会使用位域。</p>
<p>位域的声明形式是在成员名字之后紧跟一个冒号和一个常量表达式，该表达式用于指定成员所占的二进制位数。</p>
<p>位域的类型必须是整型或枚举类型。因为带符号位域的行为是由具体实现确定的，所以通常情况下使用无符号类型保存位域。位域类型的大小不能小于位域结构的总大小。</p>
<pre class=" language-c++"><code class="language-c++">struct Descriptor
{
    // error: should use unsigned long long
    unsigned int LimitLow : 16;
    unsigned int BaseLow : 24;
    unsigned int Attribute : 16;
    unsigned int BaseHigh : 8;
}
</code></pre>
<p>定义位域时建议结合<code>#pragma pack</code>指令将结构体对齐值修改为1，防止数据结构错位。</p>
<pre class=" language-c++"><code class="language-c++">// 保存原始对齐值，设置新对齐
#pragma pack(push, 1)
// 结构体定义……
// 恢复原始对齐值
#pragma pack(pop)
</code></pre>
<p>位域成员按定义顺序在内存中由低地址向高地址排列，具体布局与机器相关。</p>
<p>取地址符<code>&amp;</code>不能作用于位域，因此任何指针都无法指向类的位域。</p>
<p>如果可能的话，类内部连续定义的位域会压缩在同一整数的相邻位，从而提供存储压缩。</p>
<p>访问位域的方式与访问类的其他数据成员的方式类似。操作超过1位的位域时，通常会使用内置的位运算符。</p>
<pre class=" language-c++"><code class="language-c++">File &File::open(File::modes m)
{
    mode |= READ;   // set the READ bit by default
    // other processing
    if (m & WRITE)  // if opening READ and WRITE
        // processing to open the file in read/write mode
        return *this;
}
</code></pre>
<h3 id="19-8-2-volatile限定符（volatile-Qualifier）"><a href="#19-8-2-volatile限定符（volatile-Qualifier）" class="headerlink" title="19.8.2 volatile限定符（volatile Qualifier）"></a>19.8.2 volatile限定符（volatile Qualifier）</h3><p>当对象的值可能在程序的控制或检测之外被改变时（如子线程），应该将该对象声明为<code>volatile</code>。关键字<code>volatile</code>的作用是告知编译器不要优化这样的对象。</p>
<p><code>volatile</code>的确切含义与机器有关，只能通过查阅编译器文档来理解。要想让一个使用了<code>volatile</code>的程序在移植到新机器或新编译器后仍然有效，通常需要对该程序进行一些修改。</p>
<p><code>volatile</code>的用法和<code>const</code>类似，都是对类型的额外修饰。二者相互之间并没有影响。</p>
<pre class=" language-c++"><code class="language-c++">volatile int display_register;   // int value that might change
volatile Task *curr_task;        // curr_task points to a volatile object
volatile int iax[max_size];      // each element in iax is volatile
</code></pre>
<p>类可以将成员函数定义为<code>volatile</code>的。<code>volatile</code>对象只能调用<code>volatile</code>成员函数。</p>
<p><code>volatile</code>和指针的关系类似<code>const</code>。可以声明<code>volatile</code>指针、指向<code>volatile</code>对象的指针和指向<code>volatile</code>对象的<code>volatile</code>指针。</p>
<pre class=" language-c++"><code class="language-c++">volatile int v;      // v is a volatile int
int *volatile vip;   // vip is a volatile pointer to int
volatile int *ivp;   // ivp is a pointer to volatile int

// vivp is a volatile pointer to volatile int
volatile int *volatile vivp;
int *ip = &v;   // error: must use a pointer to volatile
*ivp = &v;      // ok: ivp is a pointer to volatile
vivp = &v;      // ok: vivp is a volatile pointer to volatile
</code></pre>
<p>不能使用合成的拷贝&#x2F;移动构造函数和赋值运算符初始化<code>volatile</code>对象或者给<code>volatile</code>对象赋值。合成的成员接受的形参类型是非<code>volatile</code>常量引用，不能把非<code>volatile</code>引用绑定到<code>volatile</code>对象上。</p>
<p>如果类需要拷贝、移动或赋值它的<code>volatile</code>对象，则必须自定义拷贝或移动操作。</p>
<pre class=" language-c++"><code class="language-c++">class Foo
{
public:
    Foo(const volatile Foo&); // copy from a volatile object
    // assign from a volatile object to a nonvolatile object
    Foo& operator=(volatile const Foo&);
    // assign from a volatile object to a volatile object
    Foo& operator=(volatile const Foo&) volatile;
    // remainder of class Foo
};
</code></pre>
<h3 id="19-8-3-链接指示：extern-“C”（Linkage-Directives：extern-“C”）"><a href="#19-8-3-链接指示：extern-“C”（Linkage-Directives：extern-“C”）" class="headerlink" title="19.8.3 链接指示：extern “C”（Linkage Directives：extern “C”）"></a>19.8.3 链接指示：extern “C”（Linkage Directives：extern “C”）</h3><p>C++程序有时需要调用使用其他语言编写的函数，最常见的是调用C语言函数。其他语言中的函数名字也必须在C++中进行声明。对于这些函数，编译器检查其调用的方式与处理普通C++函数的方式相同，但是生成的代码有所区别。C++使用链接指示指出任意非C++函数所用的语言。</p>
<p>链接指示有单个形式和复合形式，其不能出现在类定义或函数定义的内部。同样的链接指示必须出现在函数的每个声明处。</p>
<pre class=" language-c++"><code class="language-c++">// illustrative linkage directives that might appear in the C++ header <cstring>
// single-statement linkage directive
extern "C" size_t strlen(const char *);
// compound-statement linkage directive
extern "C"
{
    int strcmp(const char*, const char*);
    char *strcat(char*, const char*);
}
</code></pre>
<p>链接指示包含关键字<code>extern</code>、字符串字面值常量和一个函数声明。其中的字符串字面值常量指出了编写函数所用的语言。</p>
<p>复合形式的链接指示可以应用于整个头文件。当一个<code>#include</code>指示被放置在复合链接指示的花括号中时，头文件中的所有函数声明都会被认为是由链接指示的语言编写的。链接指示可以嵌套，因此如果头文件包含自带链接指示的函数，该函数不会受到影响。</p>
<pre class=" language-c++"><code class="language-c++">// compound-statement linkage directive
extern "C"
{
    #include <string.h>   // C functions that manipulate C-style strings
}
</code></pre>
<p>C++从C语言继承的标准库函数可以定义成C函数，但并非必须。选择使用C还是C++实现C标准库，是由每个C++实现决定的。</p>
<p>编写函数所使用的语言是函数类型的一部分。因此对于使用链接指示定义的函数来说，它的每个声明都必须使用相同的链接指示，而且指向这类函数的指针也必须使用与函数本身一样的链接指示。</p>
<pre class=" language-c++"><code class="language-c++">// pf points to a C function that returns void and takes an int
extern "C" void (*pf)(int);
</code></pre>
<p>指向C函数的指针与指向C++函数的指针是不同的类型，两者不能相互赋值或初始化（少数C++编译器支持这种赋值操作并将其视为对语言的扩展，但是从严格意义上来说它是非法的）。</p>
<pre class=" language-c++"><code class="language-c++">void (*pf1)(int);   // points to a C++ function
extern "C" void (*pf2)(int);    // points to a C function
pf1 = pf2;   // error: pf1 and pf2 have different types
</code></pre>
<p>链接指示不仅对函数本身有效，对作为返回类型或形参类型的函数指针也有效。所以如果希望给C++函数传入指向C函数的指针，必须使用类型别名。</p>
<pre class=" language-c++"><code class="language-c++">// f1 is a C function; its parameter is a pointer to a C function
extern "C" void f1(void(*)(int));
// FC is a pointer to a C function
extern "C" typedef void FC(int);
// f2 is a C++ function with a parameter that is a pointer to a C function
void f2(FC *);
</code></pre>
<p>通过链接指示定义函数，可以令C++函数在其他语言编写的程序中可用。编译器会为该函数生成适合于指定语言的代码。</p>
<pre class=" language-c++"><code class="language-c++">// the calc function can be called from C programs
extern "C" double calc(double dparm) { /* ... */ }
</code></pre>
<p>如果需要在C和C++中编译同一个源文件，可以在编译C++版本时使用预处理定义<code>__cplusplus</code>。</p>
<pre class=" language-c++"><code class="language-c++"># ifdef __cplusplus
// ok: we're compiling C++
extern "C"
# endif
int strcmp(const char*, const char*);
</code></pre>
<p>链接指示与重载函数的相互作用依赖于目标语言。C语言不支持函数重载，所以一个C链接指示只能用于说明一组重载函数中的某一个。</p>
<pre class=" language-c++"><code class="language-c++">// error: two extern "C" functions with the same name
extern "C" void print(const char*);
extern "C" void print(int);
</code></pre>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">苏北之</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://gaobo1112.github.io/2020/01/09/c/c-primer/">http://gaobo1112.github.io/2020/01/09/c/c-primer/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">苏北之</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/c-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">
                                    <span class="chip bg-color">c++,编程语言</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/01/09/qian-duan/markdown-jiao-cheng/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/17.jpg" class="responsive-img" alt="markdown教程">
                        
                        <span class="card-title">markdown教程</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-01-09
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%89%8D%E7%AB%AF/" class="post-category">
                                    前端
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/markdown/">
                        <span class="chip bg-color">markdown</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/01/08/qian-duan/bo-ke-da-jian/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/21.jpg" class="responsive-img" alt="博客搭建">
                        
                        <span class="card-title">博客搭建</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-01-08
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%89%8D%E7%AB%AF/" class="post-category">
                                    前端
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/hexo/">
                        <span class="chip bg-color">hexo</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <a href="/about" target="_blank">苏北之</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1181062873" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1181062873" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"live2d-widget-model-haru/01"},"display":{"position":"left","width":300,"height":360},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>
