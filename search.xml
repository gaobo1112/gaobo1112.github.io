<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>unity3D游戏开发学习.md</title>
      <link href="/2020/08/21/you-xi-kai-fa/unity/unity3d-you-xi-kai-fa-xue-xi/"/>
      <url>/2020/08/21/you-xi-kai-fa/unity/unity3d-you-xi-kai-fa-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="unity3D游戏开发"><a href="#unity3D游戏开发" class="headerlink" title="unity3D游戏开发"></a>unity3D游戏开发</h2><h3 id="第2章-编辑器结构"><a href="#第2章-编辑器结构" class="headerlink" title="第2章 编辑器结构"></a>第2章 编辑器结构</h3><h4 id="2-2-Project视图"><a href="#2-2-Project视图" class="headerlink" title="2.2 Project视图"></a>2.2 Project视图</h4><ul><li>project视图是游戏资源的集合视图。</li><li>资源可以分为外部资源和unity创建的资源，unity创建的资源也就是project&#x2F;create&#x2F;..下面可以创建的东西。</li><li>搜索资源:搜索栏右侧第一个按钮可以选择资源的类型，也可以使用t:script表示在project搜索所有的脚本。<code>p t:script</code>表示搜素所有名字包含p的脚本。</li><li>搜索标签 : 搜索栏第二个按钮可以按照标签搜索，标签需要自己设定，也可以在输入栏输入<code>I:Enimy</code>进行标签搜索。</li></ul><h4 id="2-3-Hierarchy-层次-视图"><a href="#2-3-Hierarchy-层次-视图" class="headerlink" title="2.3 Hierarchy(层次)视图"></a>2.3 Hierarchy(层次)视图</h4><ul><li>这个视图一般存放的是需要出现在游戏中的游戏对象，主要负责引用外部资源如模型、贴图等。原理是通过程序控制需要的游戏对象。</li></ul><h5 id="2-3-1-创建游戏对象"><a href="#2-3-1-创建游戏对象" class="headerlink" title="2.3.1 创建游戏对象"></a>2.3.1 创建游戏对象</h5><ol><li>预先编辑的对象：通过Hierarchy&#x2F;create创建。unity游戏对象本质是一个空的GameObect挂载了对应的属性脚本。比如camera挂载了camera脚本(组件)。</li><li>动态生成的对象:可以使用脚本创建自己需要的游戏对象到游戏中。</li></ol><h5 id="2-3-2-搜索游戏对象"><a href="#2-3-2-搜索游戏对象" class="headerlink" title="2.3.2 搜索游戏对象"></a>2.3.2 搜索游戏对象</h5><ul><li>搜索的功能比较简单，只提供了按名称搜索和按类型搜索。因为一把情况下游戏内也不要同时出现过多的游戏对象。</li></ul><h4 id="2-4-Inspector-检查-视图"><a href="#2-4-Inspector-检查-视图" class="headerlink" title="2.4 Inspector(检查)视图"></a>2.4 Inspector(检查)视图</h4><ul><li>这个视图承载了所有游戏对象以及游戏资源组件的编辑工作，选择project或者hierarchy中的游戏对象或者游戏资源，inspector视图会列出他的详细属性，原理是键入一些数据将其序列化到这个对象身上，如果是project中选择的资源，数据会保存到这个资源身上，如果是hierarchy对象，数据会保存到这个对象所在场景中。</li></ul><h5 id="2-4-1-标题栏"><a href="#2-4-1-标题栏" class="headerlink" title="2.4.1 标题栏"></a>2.4.1 标题栏</h5><p>大部分对象都有标题栏，标题栏包含以下一个部分:</p><ol><li>立方体下拉按钮: 给游戏对象的一个特殊标志，方便在创建中快速定位</li><li>第一个勾选框 : 设置是否激活</li><li>输入框 : 设置游戏对象的名字。</li><li>第二个勾选框 : 设置对象是否为静态属性，包括烘焙、遮挡剔除、寻路、等。</li><li>Tag : 给游戏对象设置一个特殊表示，可以在代码中动态获取，或者通过tag进行逻辑判断。</li><li>Layer : 给游戏对象设置一个层级，用于摄像机是否显示这个层，或者点击事件是否可以响应这个层。</li></ol><h4 id="2-5-Scene视图"><a href="#2-5-Scene视图" class="headerlink" title="2.5 Scene视图"></a>2.5 Scene视图</h4><ul><li>游戏最终画面的自由视角。</li></ul><h5 id="2-5-1-导航栏"><a href="#2-5-1-导航栏" class="headerlink" title="2.5.1 导航栏"></a>2.5.1 导航栏</h5><p>一共六个操作按钮，对应q,w,e,r,t,y,表示拖动、坐标、旋转、缩放、区域(常用UI元素)、整体(同时操作坐标旋转缩放)。</p><p>操作按钮右边第一个按钮用于设置游戏对象的操作原点，如果有多个物体选中操作，设置的是Pivot表示父对象的擦做原点就是自身坐标，如果设置的是Center表示父物体的操作目标是所有子物体的中心点。</p><p>第二个按钮设置旋转方向，如果是Global表示忽略自身的旋转，移动的时候会按照世界坐标移动，如果是Local表示使用游戏对象自身的旋转，移动会相对自身的旋转方向移动。</p><h5 id="2-5-2-标题栏"><a href="#2-5-2-标题栏" class="headerlink" title="2.5.2 标题栏"></a>2.5.2 标题栏</h5><ol><li>Shaded : 控制Scene视图中的显示，例如GI、模型网络、渲染、shadow、以及Overdraw等。</li><li>2D ： 设置Scene视图是2D模式观看还是3D，看UI的时候比较方便。</li><li>太阳图标 : 打开和关闭场景中的光源。</li><li>声音图标 : 如果hierarchy中有音频对象，在非运行模式下，打开该图标也可以听见声音。</li><li>图片图标 : 打开天空盒、雾、动画等，打开会带来一定开销。</li><li>Gizmons : Scene视图启动或者隐藏一些图标，如摄像机图标，可以自己花Gizmons然后打开观看。</li><li>搜索栏 : 根据名称模糊搜索游戏对象</li></ol><h4 id="2-6-Game视图"><a href="#2-6-Game视图" class="headerlink" title="2.6 Game视图"></a>2.6 Game视图</h4><p>游戏最终展现给玩家的样子，一般是将摄像机看到的内容显示到了这个视图，一般一个游戏中可能有多个摄像机，通过设置相机的渲染深度决定渲染的先后顺序。</p><h5 id="2-6-1-标题栏"><a href="#2-6-1-标题栏" class="headerlink" title="2.6.1 标题栏"></a>2.6.1 标题栏</h5><ol><li>Display 1 : 摄像机可以设置当前的Display层，手机不支持。</li><li>Free Aspect : 设置游戏分辨率，可以观看不同分辨率下游戏的运行情况。</li><li>Scale : 游戏画面缩小放大，可以观察更多细节。</li><li>Maximize on play : 全屏运行游戏</li><li>Mute Audio : 关闭声音，这样在每次运行的时候就不会发出音乐了。</li><li>Stats : 查看游戏运行时的性能</li><li>Gizmons : 将scene中的Gizmons也显示在game中。</li></ol><h5 id="2-6-2-导航栏视图"><a href="#2-6-2-导航栏视图" class="headerlink" title="2.6.2 导航栏视图"></a>2.6.2 导航栏视图</h5><ol><li>点击暂停按钮再点击运行游戏会被暂停到第一帧。</li><li>运行的时候使用 command + shift + p可以快速暂停。</li><li>layer可以用来编辑层，可以用来添加和删除层。也可以点眼睛来看到想要的层和不看到某些层。</li></ol><h4 id="2-8-其他功能技巧"><a href="#2-8-其他功能技巧" class="headerlink" title="2.8 其他功能技巧"></a>2.8 其他功能技巧</h4><h5 id="2-8-1-锁头"><a href="#2-8-1-锁头" class="headerlink" title="2.8.1 锁头"></a>2.8.1 锁头</h5><p>每个系统窗口都会有锁头，不同窗口功能可能不一样，拿inspector面板来说，如果锁上后，选择别的GameObject该窗口也不会改变。</p><h5 id="2-8-2-窗口菜单"><a href="#2-8-2-窗口菜单" class="headerlink" title="2.8.2 窗口菜单"></a>2.8.2 窗口菜单</h5><p>Unity每个系统窗口都有一个菜单窗口，内容如下：</p><ol><li>Normal : 表示正常面板</li><li>Debug : 组件的私有属性默认是不显示在面板上的，勾选该选择后，所有私有属性也会显示在面板中。</li><li>Lock : 锁头的功能。</li><li>Close Tab : 关闭窗口</li><li>Add Tab : 添加一个窗口，有时候需要两个面板的信息，配合锁头使用很用用。</li><li>Expand All Components : 折叠所有的组件，整理方便。</li></ol><h5 id="2-8-3-保存组件参数"><a href="#2-8-3-保存组件参数" class="headerlink" title="2.8.3 保存组件参数"></a>2.8.3 保存组件参数</h5><p>每个组件都可以保存，组件右上角第二个按钮，可以将组件的参数保存到文件中，也可以从文件中读取保存的组件数据。</p><h3 id="第3章-拓展编辑器"><a href="#第3章-拓展编辑器" class="headerlink" title="第3章 拓展编辑器"></a>第3章 拓展编辑器</h3><h4 id="3-1-拓展project视图"><a href="#3-1-拓展project视图" class="headerlink" title="3.1 拓展project视图"></a>3.1 拓展project视图</h4><h5 id="3-1-1-拓展右键菜单"><a href="#3-1-1-拓展右键菜单" class="headerlink" title="3.1.1 拓展右键菜单"></a>3.1.1 拓展右键菜单</h5><ul><li><p>编译器使用代码仅限于编辑模式，所以一般放在Editor文件夹下。Eidtor文件夹位置比较灵活，可以作为多个目录的子文件夹存在。</p></li><li><p>打印选中资源的名称的脚本编辑器:</p><pre class=" language-c#"><code class="language-c#">public class Scirpt3_2 {    /// <summary>    /// 参数1 所添加的菜单条目的路径    /// 参数2 不写为false，true则点击菜单前就会调用     /// 参数3 菜单项显示排序，值越小显示越靠前    /// </summary>    [MenuItem("Assets/MyTool/Tool1",false,2)]    static void MyTools1()    {        Debug.Log(Selection.activeObject.name);    }                [MenuItem("Assets/MyTool/Tool2", false, 1)]    static void MyTools2()    {        Debug.Log(Selection.activeObject.name);    }}</code></pre></li></ul><h5 id="3-1-2-创建菜单"><a href="#3-1-2-创建菜单" class="headerlink" title="3.1.2 创建菜单"></a>3.1.2 创建菜单</h5><ul><li><p>实现功能: 在project点击创建创建按钮创建出立方体和球体</p><pre class=" language-c#"><code class="language-c#">public class Scirpt3_2 {    [MenuItem("Assets/Create/MyCreate/Cube", false, 1)]    static void MyCreateCube()    {        GameObject.CreatePrimitive(PrimitiveType.Cube);    }    [MenuItem("Assets/Create/MyCreate/Sphere", false, 2)]    static void MyCreateSphere()    {        GameObject.CreatePrimitive(PrimitiveType.Sphere);    }}</code></pre></li></ul><h5 id="3-1-3-拓展布局"><a href="#3-1-3-拓展布局" class="headerlink" title="3.1.3 拓展布局"></a>3.1.3 拓展布局</h5><ul><li><p>实现功能：当鼠标选中一个资源后，右边将出现拓展的click按钮，点击按钮，console打印出资源的名字。</p><pre class=" language-c#"><code class="language-c#">public class Script3_3 {    //InitializeOnLoadMethod在代码编译完成后首先调用    [InitializeOnLoadMethod]    static void InitializaitonOnLoadMethod()    {        //匿名委托，委托可以看成是一种函数类型，ProjectWindowItemCallback这种函数类型赋值给ProjectWindowItemCallback，=后面就是匿名委托的某个具体的函数。        EditorApplication.projectWindowItemOnGUI = delegate (string guid, Rect rect)        {            if (Selection.activeObject &&            guid == AssetDatabase.AssetPathToGUID(AssetDatabase.GetAssetPath(Selection.activeObject)))            {                //设置拓展按钮区域                float width = 50f;                rect.x += (rect.width - width);                rect.y += 2f;                rect.width = width;                GUI.color = Color.red;                //点击事件                if (GUI.Button(rect, "click"))                {                    Debug.LogFormat("click : {0}", Selection.activeObject.name);                }                GUI.color = Color.white;            }        };    }}</code></pre></li></ul><h5 id="3-1-4-监听事件"><a href="#3-1-4-监听事件" class="headerlink" title="3.1.4 监听事件"></a>3.1.4 监听事件</h5><ul><li>通过程序来约束资源，可以通过监听资源的创建、删除、和保存等事件来实现。</li></ul><h4 id="3-2-拓展hierarchy视图"><a href="#3-2-拓展hierarchy视图" class="headerlink" title="3.2 拓展hierarchy视图"></a>3.2 拓展hierarchy视图</h4><ul><li>拓展的hierarchy视图需要在修改MenuItem的选项就可以了改成<code>GameObject/...</code>就可以在该视图下看到并执行了。</li></ul><h5 id="3-2-2-重写菜单"><a href="#3-2-2-重写菜单" class="headerlink" title="3.2.2 重写菜单"></a>3.2.2 重写菜单</h5><ul><li><p>实现功能 : 鼠标选择一个游戏对象，点击右键弹出重写的窗口。实现原理是监听点击事件，弹出窗口。</p><pre class=" language-c#"><code class="language-c#"></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c#基础.md</title>
      <link href="/2020/05/11/you-xi-kai-fa/c/c-ji-chu/"/>
      <url>/2020/05/11/you-xi-kai-fa/c/c-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="c-程序结构"><a href="#c-程序结构" class="headerlink" title="c#程序结构"></a>c#程序结构</h2><h3 id="c-helloword"><a href="#c-helloword" class="headerlink" title="c# helloword"></a>c# helloword</h3><pre class=" language-c#"><code class="language-c#">using System;namespace HelloworldTest{    class HelloWorld{        static void main(string[] arg)        {            Console.WriteLine("hello");            Console.ReadKey();        }    }}</code></pre><h3 id="c-数据类型"><a href="#c-数据类型" class="headerlink" title="c#数据类型"></a>c#数据类型</h3><h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><ul><li>值类型变量可以直接分配给一个值。它们是从类 <strong>System.ValueType</strong> 中派生的。包括bool、byte、char、decimal、double、float、int、long、sbyte、short、uint、ulong、ulong、ushort。decimal是128位精确的十位数，btye是8位的整数，带u的是无符号的数。</li></ul><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><ul><li>引用类型不包含存储在变量中的实际数据，但他们包含对对象的引用，常见的引用类型有:object,dynamic,string</li></ul><h4 id="对象object类型"><a href="#对象object类型" class="headerlink" title="对象object类型"></a>对象object类型</h4><ul><li><p>所有数据类型的基类，可以转换为任意对象类型，当一个值类型转换为对象类型时，则被称为 <strong>装箱</strong>；另一方面，当一个对象类型转换为值类型时，则被称为 <strong>拆箱</strong>。</p><pre class=" language-c#"><code class="language-c#">Object object;object = 100;//装箱int i = (int)object;//拆箱，注意不支持隐世的拆箱。</code></pre></li></ul><h4 id="动态-Dynamic-类型"><a href="#动态-Dynamic-类型" class="headerlink" title="动态(Dynamic)类型"></a>动态(Dynamic)类型</h4><ul><li><p>动态类型与对象类型相似，但是对象类型变量的类型检查是在编译时发生的，而动态类型变量的类型检查是在运行时发生的。</p><pre class=" language-c#"><code class="language-c#">dynamic dic = 100;</code></pre></li></ul><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><ul><li><p><strong>字符串（String）类型</strong> 允许您给变量分配任何字符串值。字符串（String）类型是 System.String 类的别名。它是从对象（Object）类型派生的。字符串（String）类型的值可以通过两种形式进行分配：引号和 @引号。</p><pre class=" language-c#"><code class="language-c#">String str = "hellow";String str1 = @"hello";</code></pre></li><li><p>@ 字符串中可以任意换行，换行符及缩进空格都计算在字符串长度之内。</p></li></ul><h4 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h4><ul><li>指针类型变量存储另一种类型的内存地址。C# 中的指针与 C 或 C++ 中的指针有相同的功能。</li></ul><h4 id="c-常用运算符"><a href="#c-常用运算符" class="headerlink" title="c#常用运算符"></a>c#常用运算符</h4><ul><li>sizeof(),返回数据类型的大小</li><li>typeof(),返回class的类型</li><li>is判断对象是否为某一个类型</li><li>as，强制转换即使转换失败也不会抛出异常。</li></ul><h3 id="c-循环"><a href="#c-循环" class="headerlink" title="c#循环"></a>c#循环</h3><ul><li><p>C# 也支持 foreach 循环，使用foreach可以迭代数组或者一个集合对象。</p><pre class=" language-c#"><code class="language-c#">int count = 0;foreach(int num in nums){    num++;    System.Console.WriteLien("element #{0}:{1}",num,count);}</code></pre></li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java并发编程</title>
      <link href="/2020/05/01/java/java-bing-fa-bian-cheng/"/>
      <url>/2020/05/01/java/java-bing-fa-bian-cheng/</url>
      
        <content type="html"><![CDATA[<ol><li>使用synchronized的三种方法。</li></ol><ul><li>synchronized保护的是对象而不是代码，只要访问的是同一个对象的synchronized方法，即使是不同的代码，也会被按照同步顺序执行。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test1</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Object o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//synchronized锁定的是一个对象不是代码块</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            num<span class="token operator">++</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"num ="</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Test1 test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//10000各线程都访问同一个test对象</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span><span class="token string">"thread"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>     <span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Test2</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            num<span class="token operator">++</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"num ="</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Test3</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//如果锁定的是this对象，等价于上面一种写法</span>    <span class="token punctuation">{</span>            num<span class="token operator">++</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"num ="</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Test3<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">//在静态方法里面锁定的是类对象。</span>        <span class="token punctuation">{</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>synchronized不能保证非同步的方法被同时执行。所以一般在保护变量的时候需要将所有的变量方法都加上synchronized。只有加了synchronized的方法在运行的时候才需要申请锁，其他方法不需要申请锁。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>c_001<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">test2</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        count <span class="token operator">--</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" count = "</span><span class="token operator">+</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>count<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            count<span class="token operator">--</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" count = "</span><span class="token operator">+</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        test2 test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//10000各线程都访问同一个test对象</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>test<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"thread"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>test<span class="token punctuation">.</span><span class="token function">m2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"main1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>如果只对业务的写加锁，而不对读加锁的话就会产生脏读的问题。如果业务运行脏读，可以不加锁，脏读就是可能读到了没有写完的数据。</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 对业务的写加锁 * 不对业务的读加锁 * 容易产生脏读的现象 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">test</span> <span class="token punctuation">{</span>    String name<span class="token punctuation">;</span>    <span class="token keyword">double</span> money<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span><span class="token keyword">double</span> money<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>money <span class="token operator">=</span> money<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">read</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>money<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        test test1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>test1<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>test1<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>test1<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>volatile 关键字，使一个变量在多个线程间可见</li><li>A B线程都用到一个变量，java默认是A线程中保留一份copy，这样如果B线程修改了该变量，则A线程未必知道</li><li>使用volatile关键字，会让所有线程都会读到变量的修改值</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VoliteTest</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*volatile*/</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a.start()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//System.out.println(Thread.currentThread().getName() + "running");</span>            <span class="token comment" spellcheck="true">//注意这里，如果有代码的话会去内存里面刷新值，所以flag的值会被改变。任然会退出，如果cpu空闲了就会去内存中刷新中，也就是说如果有上面的代码，cpu就会有空闲。</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a.end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        VoliteTest test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VoliteTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        new Thread(()->test.test()).start();</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>test<span class="token operator">:</span><span class="token operator">:</span>m<span class="token punctuation">,</span> <span class="token string">"m"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        test<span class="token punctuation">.</span>flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>atomicXXX多个方法之间并不构成原子性，只是单个的方法才有原子性。</li><li>锁的粒度越细越好。</li><li>锁定某个对象的时候如果该对象的属性发生改变，不会隐形锁的使用，但是如果o编程另一个对象，锁定的独享发生改变。所以应该避免将锁定对象的引用变成另个对象。</li><li>不要以字符串常量作为锁定的对象，因为字符串常量常量区，可能两个引用指向的是同一个对象，锁定的也是同一个对象，容易给人锁定的是不同对象的误解。</li><li>设计一个容器，提供两个方法，add，size，写两个线程，一个线程添加10个元素到容器中，一个线程监控元素的个数，当个数达到5的时候给出提示并结束。</li><li>带锁的对象调用wait方法，当前线程进程阻塞状态，并且释放锁。只有别的线程调用了对象的notify方法，线程才会被启动。notifyall调用等待的所有线程。wait释放锁，而notify不糊释放锁。使用countdownlatch，倒计时机制，当到0的时候门才开。调用await方法。await不需要锁定任何对象。</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//使用volatile实现</span><span class="token keyword">package</span> com<span class="token punctuation">.</span>c_003<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>LinkedList<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution1</span> <span class="token punctuation">{</span>    <span class="token keyword">volatile</span> LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Integer<span class="token punctuation">)</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Solution1 s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>        <span class="token punctuation">{</span>           <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>           <span class="token punctuation">{</span>               s1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>               System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"thread2 end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//使用wait和notify实现</span><span class="token keyword">package</span> com<span class="token punctuation">.</span>c_003<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>LinkedList<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution2</span> <span class="token punctuation">{</span>    LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Integer i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Solution2 s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">synchronized</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">5</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        s2<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"s2 end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                s2<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>s2<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    s2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        s2<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                            s2<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//使用countdownlatch是实现</span><span class="token keyword">package</span> com<span class="token punctuation">.</span>c_003<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>LinkedList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>CountDownLatch<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution3</span> <span class="token punctuation">{</span>    List  list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Integer num<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Solution3 s3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        CountDownLatch latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s3<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"size == 5"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                s3<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>接口lock的定义如下</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//普通锁和释放锁的方法。</span><span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//可以响应中断，如果被其他线程中断了抛出异常。</span><span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">//尝试获取锁，不阻塞，成功返回true</span><span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span>TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//尝试获得失败阻塞，超时抛出异常。</span><span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Condition <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//创建条件，一个lock可以关联多个条件。</span><span class="token keyword">public</span> <span class="token function">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">//常见公平锁和非公平锁</span></code></pre><ul><li>一个固定容量同步容器，拥有put和get方法，以及getCount方法，能够支持2个生产者线程以及10个消费者线程的阻塞调用,两种方法，一种使用sychronnized和wait实现，另一个中用condition实现。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> c_004<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>LinkedList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution1</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">private</span> List list<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">private</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>MAX<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">++</span>count<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//list.get(count);</span>        T t <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span>list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Solution1<span class="token operator">&lt;</span>Integer<span class="token operator">></span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution1</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Integer total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token keyword">int</span> ss <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span> <span class="token string">"get "</span> <span class="token operator">+</span> s1<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"is"</span> <span class="token operator">+</span> ss<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"producer"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    s1<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"set"</span><span class="token operator">+</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"is"</span> <span class="token operator">+</span> s1<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"consumer"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>Condition<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>Lock<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>ReentrantLock<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution2</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span>  MAX <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Condition consumer <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Condition producer <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>count<span class="token operator">></span>MAX<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                producer<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>            consumer<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        T t <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                consumer<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            t <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            count<span class="token operator">--</span><span class="token punctuation">;</span>            producer<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> t<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Solution2<span class="token operator">&lt;</span>Integer<span class="token operator">></span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token keyword">int</span> ss <span class="token operator">=</span> s2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span> <span class="token string">"get "</span> <span class="token operator">+</span> s2<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"is"</span> <span class="token operator">+</span> ss<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"producer"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    s2<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"set"</span><span class="token operator">+</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"is"</span> <span class="token operator">+</span> s2<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"consumer"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>将一个变量设置为threadlocal表示每一个线程都有一份该变量的副本。每个线程都拷贝了一份，相当于用空间换取时间。</li></ul><h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><h4 id="CopyOnWriteArrayList和CopyOnWriteArraySet"><a href="#CopyOnWriteArrayList和CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArrayList和CopyOnWriteArraySet"></a>CopyOnWriteArrayList和CopyOnWriteArraySet</h4><ul><li>适合于读操作比较多，写操作比较少的时候，内部是一个数组，但是数组是以原子的方式被整体更新的，每次修改操作都会新建一个数组，复制原来数组的到新的数组</li></ul><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><ul><li>对多个并发容器进行测试，concurrenthashmap最快，采用了分段锁的技术，将数据分为多段，而每一段都有一个独立的锁，同时在对数据进行读写的时候也采用了cas的方式。</li><li>concurrentskiplistmap是排好顺序的，所以插入元素的时候速度可能会比较慢，但是在查询的时候素的很快。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>c_005<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ConcurrentHashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ConcurrentSkipListMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>CountDownLatch<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentMapTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//        Map&lt;String,String> map = new ConcurrentHashMap&lt;>();</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        Map&lt;String,String> map = new Hashtable&lt;>();</span><span class="token comment" spellcheck="true">//        Map&lt;String,String> map = new ConcurrentSkipListMap&lt;>();</span>        Collections<span class="token punctuation">.</span><span class="token function">synchronizedMap</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        Random r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">[</span><span class="token punctuation">]</span> ths <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        CountDownLatch latch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>ths<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>ths<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            ths<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>               <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">10000</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token operator">+</span>r<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token operator">+</span>r<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               latch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>ths<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            latch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">long</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>end<span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="java并发队列"><a href="#java并发队列" class="headerlink" title="java并发队列"></a>java并发队列</h4><ul><li><p>无锁非阻塞并发队列ConcurrentLinkedQueue和ConcurrentLinkedDeque</p></li><li><p>普通阻塞队列ArrayBlockingQueue和LinkedBlockingQueue和LinkedBlockingDeque</p></li><li><p>优先级阻塞队列PriorityQueue</p></li><li><p>延时阻塞队列DelayQueue</p></li><li><p>其他阻塞队列SychronousQueue和LinkedTransferQueue</p></li><li><p>无锁非阻塞是指这些队列不使用锁，所有的操作都可以立即执行，主要通过cas实现并发安全。</p></li><li><p>阻塞队列是指这些队列使用锁和条件。很多操作需要先获得锁或者满足条件。</p></li><li><p>concurrentLinkedQueue和concurrentlinkedDeque都是基于链表是实现的，都没有大小的限制，也就是无界的，基于循环cas实现。</p></li><li><p>阻塞队列的方法：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//入队，如果队列满，等待直到队列有空间</span><span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterrupteredException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//出对，如果队列空，等待直到队列不空，返回元素的头部</span><span class="token keyword">void</span> <span class="token function">take</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterrupteredException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//入队，如果队列满，最多等待一段时间，如果超时返回false</span><span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">,</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span>TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//出队，如果队列空，最多等待一段时间，如果超时返回null</span>E <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span>TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span></code></pre></li><li><p>ArrayBlockingQueue基于循环数组实现，有界，创建指定大小，<br>LinkedBlockingQueue基于单向链表实现，可以指定有界，默认无界，<br>和LinkedBlockingDeque和上面一个一样，但是是双向链表</p><ul><li>内部都是通过reentrantlock和条件是实现的。</li></ul></li><li><p>priorityQueue大小没有限制无界，堆实现，使用一个锁reetrantlock保护所有访问，使用了一个条件协调阻塞等待。</p></li><li><p>delayQueue特殊的优先级队列，无界的，只有元素的延时过期的时候才能从队列中拿出来元素。</p></li><li><p>LinkedTransferQueue可以等待消费者接受后再返回。synchronousQueue没有存储元素，也就是他的入队操作需要等待另一个线程的出队操作。</p></li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="基本概念和原理"><a href="#基本概念和原理" class="headerlink" title="基本概念和原理"></a>基本概念和原理</h4><ul><li><p>Executor表示最简单的执行任务，是一个接口，改接口只有一个excute方法,该方法执行一个runnable任务，没有返回值，接口没有限定任务如何执行，你可以创建一个新的线程执行，也可以直接执行，或者是复用线程池的某个线程。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>c_006<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Executor<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyExcutor</span> <span class="token keyword">implements</span> <span class="token class-name">Executor</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">MyExcutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        command<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>ExecutorService扩展了Executor，接口，定义了更多的服务，可以运行runable和callable方法，具体怎么运行不知道，基本方法有：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ExecutorService</span> impelements Executor<span class="token punctuation">{</span>    <span class="token operator">&lt;</span>T<span class="token operator">></span> Future<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">summit</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&lt;</span>T<span class="token operator">></span> Future<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">summit</span><span class="token punctuation">(</span>Runnable<span class="token operator">&lt;</span>T<span class="token operator">></span> task<span class="token punctuation">,</span>T result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>callable和runnable都是被其他线程调用的，但是callable有返回值，而runable没有。</p></li><li><p>Executors是操作executor的工具类。理解为工厂方法。</p></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>c_006<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ExecutorService<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Executors<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThreadPool1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ExecutorService service <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">6</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>        service<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//将线程池关闭，但是是否结束时根据任务是否执行完毕来判断的</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>service<span class="token punctuation">.</span><span class="token function">isTerminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>service<span class="token punctuation">.</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>service<span class="token punctuation">.</span><span class="token function">isTerminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>service<span class="token punctuation">.</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>future是callable的返回值可以用来获得线程的运行结果</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>c_006<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThreadPool2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>        ExecutorService service  <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Future<span class="token operator">&lt;</span>Integer<span class="token operator">></span> future <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li></li></ul><ul><li><p>leetcode 1 事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</p></li><li><p>leetcode 2 链表</p></li><li><p>leetcode 3 哈希 双指针 滑动窗口</p></li><li><p>leetcode 4 二分查找</p></li><li><p>leetcode 5 动态规划 P(i,j)&#x3D;(P(i+1,j−1) </p></li><li><p>leetcode 10 正则表达式的匹配 动态规划 回溯</p></li><li><p>leetcode 11 双指针</p></li><li><p>leetcode 15 双指针</p></li><li><p>leetcode 17 回溯</p></li><li><p>leetcode 19 链表 双指针</p></li><li><p>leetcode 20 栈</p></li><li><p>leetcode 21 链表</p></li><li><p>leetcode 22 递归 回溯算法</p></li><li><p>leetcode 23 堆 链表 分治算法</p></li><li><p>leetcode 31 数组 一遍扫描</p></li><li><p>leetcode 32 字符串 动态规划</p></li><li><p>leetcode 33 二分查找</p></li></ul><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul><li>20  42  71 84 85 94 103 144 145 150</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul><li>19 21 23 24 25 61 82 83 86 92</li></ul><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul><li>94 95 96 98 99 100 101 102 103 104</li></ul><h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><ul><li>208 211 212 336 421 472 648 676 677 692</li></ul><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul><li>23 215 218 239 264 295 313 347 355 373</li></ul><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><ul><li>133 207 210 310 332 399 684 685 743 765</li></ul><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><ul><li>128 130 200 399 547 684 685 721 765 778</li></ul><h2 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h2><ul><li>18 30 36 37 49 76 85 94 136 138</li></ul><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><ul><li>10 17 22 37 39 40 44 46 47 51 52</li></ul><h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h2><ul><li>98 99 100 101 104 105 106 108 109 110</li></ul><h2 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h2><ul><li>101 102 103 107 111 126 127 130 133 199</li></ul><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul><li>687 698 726 761 779 783 794 894 938 1137</li></ul><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul><li>56 57 75 147 148 164 179 220 242 274</li></ul><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><ul><li>146 155 173 208 211 225 232 284 295 297</li></ul><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><ul><li>19 26 27 28 30 42 61 75 76 80</li></ul><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><ul><li>4 29 33 34 35 50 69 74 81 153</li></ul><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><ul><li>3 76 239 424 480 567 978  992 995  1004</li></ul><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><ul><li>44 55 122 134 135 316 321 330 376 392</li></ul><h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><ul><li>4 23 53 169 215 218 240 241 282 312</li></ul><h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><ul><li>5 10 32 44 53 62 63 64 70 72 85</li></ul><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><ul><li>207 210 329</li></ul><h2 id="树状数组-线段树"><a href="#树状数组-线段树" class="headerlink" title="树状数组 线段树"></a>树状数组 线段树</h2><ul><li>218 307</li></ul><h2 id="几何"><a href="#几何" class="headerlink" title="几何"></a>几何</h2><ul><li>587 892 963</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java编程基础</title>
      <link href="/2020/04/29/java/java-bian-cheng-ji-chu/"/>
      <url>/2020/04/29/java/java-bian-cheng-ji-chu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试总结</title>
      <link href="/2020/04/02/mian-shi/mian-shi-zong-jie/"/>
      <url>/2020/04/02/mian-shi/mian-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="常见题目"><a href="#常见题目" class="headerlink" title="常见题目"></a>常见题目</h2><h3 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h3><p>深入理解java虚拟机</p><ul><li>介绍jvm的内存区域(运行时数据)     </li><li>判断对象已经死亡</li><li>简介强，软,弱,虚引用</li><li>简介垃圾收集算法以及各自特点</li><li>常见的垃圾收集器有哪些。</li><li>吞吐量有限和响应优先的垃圾收集器如何选择。</li><li>内存分配与内存策略(对象何时进入老年态)。</li><li>虚拟机性能监控和故障处理工具。</li><li>class类文件的结构。</li><li>简介jvm类内存加载机制。</li><li>简介jvm中的类加载器和双亲委派模型。</li><li>简介jvm静态分派和动态分派。</li><li>jvm启动之client和server</li><li>如何优化java gc</li><li>jvm有哪些进程启动</li><li>java8 的元空间。</li></ul><h3 id="java并发"><a href="#java并发" class="headerlink" title="java并发"></a>java并发</h3><ul><li>线程状态有哪些</li><li>并发级别有哪些</li><li>happen-before的原则是什么</li><li>创建线程的几种方式</li><li>线程基本操作</li><li>volatile和synchronized的区别</li><li>sychronized关键字有什么问题。</li><li>线程同步的方式</li><li>线程之间的协作</li><li>ConcurrentHashMap实现原理。</li><li>多线程锁的优化</li><li>CAS</li><li>JUC并发包的队列和原子类。</li><li>简述线程池。</li><li>线程池的增长策略(任务调度)</li><li>线程池的拒绝策略</li><li>快速失败和安全失败</li><li>AQS原理</li><li>异常体系。</li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>mysql必知必会，mysql技术内幕</p><ul><li>数据库ACID特性</li><li>四大隔离级别，以及不可重复读和幻影读的出现原因。</li><li>封锁的粒度锁的类型</li><li>b+树原理，与其他查找树比较</li><li>b+树索引和hash索引比较</li><li>mysql索引有哪些</li><li>mysql优化</li><li>innodb和myisam的比较</li><li>聚集索引和非聚集索引</li><li>水平切分与垂直切分</li><li>主从复制原理，作用，实现</li><li>数据库char和varchar的区别</li><li>数据库的热备份和冷备份</li><li>红黑树和调表</li><li>数据库视图和存储过程</li><li>数据库操作(加索引，加锁)</li><li>sql实战练习(牛客)</li></ul><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><p>redis设计与实现</p><ul><li>简述下redis(为什么使用redis)</li><li>为什么说redis且性能高</li><li>redis的5种数据类型，8中数据结构</li><li>redis的过期策略和缓存淘汰机制</li><li>redis中持久化机制</li><li>redis集群的主从复制</li><li>缓存雪崩和缓存穿透问题</li><li>缓存和数据库的数据统一问题</li></ul><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>tcp&#x2F;ip详解</p><ul><li>计算机网络分层</li><li>tcp和udp的区别</li><li>tcp三次握手和四次挥手</li><li>tcp协议-如何保证可靠传输</li><li>DNS域名解析</li><li>http报文结构和状态码</li><li>get和post的比较:作用，参数，安全性，幂等性，可缓存</li><li>cookies作用，安全性问题和session的比较</li><li>短连接和长连接，流水线</li><li>http的安全问题</li><li>http和ftp的异同点</li><li>输入网址发生过程</li><li>大数据中用到心跳机制的关键</li></ul><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li>进程、线程、协程的区别</li><li>进程间的通信方式</li><li>进程调度算法</li><li>死锁条件和处理方法</li><li>内存管理</li><li>io管理</li></ul><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><ul><li>文件系统的原理，特别是inode和block</li><li>软连接和硬连接</li><li>僵尸进程和孤儿进程的区别，从sigchld分析产生僵尸进程的原因</li><li>常用指令</li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li>模板方法模式</li><li>外观实际模式</li><li>适配器模式</li><li>单例模式</li><li>装饰设计模式</li><li>简介java设计模式之动态代理</li><li>观察值模式</li></ul><h3 id="java-web"><a href="#java-web" class="headerlink" title="java web"></a>java web</h3><ul><li>深入分析javaio的工作机制</li><li>深入分析javaweb的中文编码</li><li>javac编译原理</li><li>虚拟机内容</li><li>servlet工作原理解析</li><li>深入理解session和cookie</li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li>git和github</li><li>maven</li></ul><h3 id="mapreduce的过程和细节"><a href="#mapreduce的过程和细节" class="headerlink" title="mapreduce的过程和细节"></a>mapreduce的过程和细节</h3><ul><li>简介mapreduce整个流程</li><li>文件切片</li><li>环形缓冲区的底层实现</li><li>shuffle机制</li><li>mapreduce细节问题</li><li>全排序</li><li>辅助排序(二次排序)</li><li>join(hive sql底层基本一致)</li><li>分布式缓存</li></ul><h3 id="YARN"><a href="#YARN" class="headerlink" title="YARN"></a>YARN</h3><ul><li>简述mapreduce1工作机制</li><li>简述yarn(mapreduce2)工作机制</li><li>简述yarn中application master向resource manager申请资源的过程</li><li>比较mapreduce1和2</li><li>简述yarn中resource manager总体结构</li><li>简述yarn中的资源调度器</li><li>简述yarn中内存和cpu调度(资源管理)，和资源隔离机制</li><li>简述yarn中container的概念</li><li>yarn中各部分运行故障如何处理(作业运行失败可能的原因)</li><li>yarn中常见问题以及解决方案。</li><li>yarn中resource manager的高可用实现(主备切换的底层实现)</li><li>yarn中resource mananger的高可用中出现脑裂问题的解决。</li></ul><h3 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h3><ul><li>简述事务四大特性以及隔离性问题</li><li>简述下分布式系统和cap，base理论</li><li>分布式系统下的一致性协议(2pc&#x2F;3pc&#x2F;paxos)</li><li>简述zookerper中分布式协议zab协议</li><li>zookerper系统模型(核心watcher监听机制)</li><li>会话创建过程以及底层实现</li><li>leader选举过程以及底层实现</li><li>zooperker数据存储的介绍</li><li>zookerper服务器启动流程简介</li><li>构建zookerper高可用集群</li><li>zookerper典型应用场景总结</li><li>raft协议</li></ul><h3 id="hdfs"><a href="#hdfs" class="headerlink" title="hdfs"></a>hdfs</h3><ul><li>简述hdfs的各节点之间的通信问题</li><li>hdfs中rpc的通信接口以及主要功能</li><li>hdfs中流式接口及主要功能</li><li>简述hadoop远程调用过程底层核心实现过程。</li><li>hdfs中客户端与namenode中rpc通信实例</li><li>简述下namenode作用</li><li>hdfs中namenode文件系统目录树管理</li><li>hdfs中namenode对数据块和数据节点的管理</li><li>hdfs数据块副本状态的管理</li><li>namenode中对数据块的增加的管理</li><li>namenode中数据块副本的删除的管理</li><li>namenode中数据块副本的复制的管理</li><li>namenode中数据块副本监控线程</li><li>namenode对块汇报的处理</li><li>namenode管理datanode添加和撤销</li><li>namenode对datenode的启动过程管理</li><li>namenode对datenode的心跳处理</li><li>namenode种的租约管理</li><li>namenode中的集中式缓存管理</li><li>namenode中的安全模式</li><li>namenode中的高可用的实现</li><li>namenode中高可用的脑裂问题</li><li>namenode中的启动过程底层分析。</li><li>hdfs的1.x和2.x架构以及区别</li><li>datanode升级机制和过程</li><li>datanode磁盘目录结构</li><li>datanode数据层实现</li><li>datanode逻辑层的实现(处理hdfs逻辑，管理块池和nodename通信o)</li><li>datenode流式接口的实现(服务层)</li><li>datanode中dataxcerver的读数据</li><li>datanode宏读取数据的两种方式</li><li>datanode中dataxcerver的写数据</li><li>简述hadoop的安全认证问题</li><li>如何衡量hadoop中两个节点的距离</li><li>简述java序列化对hadoop自带序列化机制以及其区别</li><li>简述hadoop的压缩和压缩框架</li></ul><h3 id="spark，storm，flink函数句处理"><a href="#spark，storm，flink函数句处理" class="headerlink" title="spark，storm，flink函数句处理"></a>spark，storm，flink函数句处理</h3><ul><li>scala编程入门</li><li>代码示例</li><li>类，对象，继承</li><li>模式匹配</li><li>隐世转换</li></ul><p>spark</p><ul><li>spark的算子有哪些</li><li>spark的rdd理解</li><li>rdd分区函数的实现</li><li>spark的运行模式</li><li>spark运行的基本流程</li><li>spark的任务调度模块是实现</li><li>spark的存储管理架构</li><li>spark的rdd容错机制</li><li>对spark的shuffle过程介绍</li><li>spark相对于hadoop和mapreduce在shuffle有哪些优化</li><li>spark解决数据倾斜</li><li>sparksql的三种jion实现</li><li>简介spark streaming</li><li>spark streaming性能调优手段</li><li>spark streaming容错机制</li><li>spark streaming反压机制</li></ul><p>storm</p><ul><li>简述storm的流式数据处理</li><li>提高storm的并发度</li><li>storm中stream grouping的几种方式</li><li>storm中的容错机制</li><li>storm的反压机制</li></ul><p>flink</p><ul><li>简述flink</li><li>flink的架构</li><li>flink的windows机制和时间概念</li><li>flink的容错机制</li><li>flink的反压机制</li><li>flink如何是实现反压机制</li><li>flink如何在jvm内部实现自己的内存管理</li><li>storm,spark streaming,flink比较</li></ul><p>hbase</p><ul><li>hbase在数据库中的地位</li><li>简述hbase(数据模型，架构)</li><li>简述hbase的读写底层实现过程</li><li>hbase在写过程中region的切分过程</li><li>hbase在建表是的设计原则</li><li>hbase的增删查和实现</li><li>hbase的过滤器</li><li>hbase的协处理器</li><li>hbase的二次索引</li><li>每天百亿数据存入hbase，如何保证数据的存储正确和在规定的时间内全部写入完毕，不留数据</li><li>hbase的优化方法</li><li>hbase中的region server发生故障的处理方法</li></ul><p>kafka</p><ul><li>简述kafka</li><li>kafka如何保证消息有序性</li><li>kafka消息的存储机制</li><li>相比较传统消息队列，kafka的区别</li><li>消息丢失和消息重复</li><li>spark streaming和kafka连接</li></ul><p>数据仓库和hive</p><ul><li>什么是数据仓库，数仓的架构</li><li>数仓事务表和维度表</li><li>数仓多维数据模型</li><li>数据库和数据仓库有什么区别</li><li>构建企业级数据仓库五步骤</li><li>数据仓库部分术语</li></ul><p>hive</p><ul><li>hive的简介</li><li>hive的内部表和外部表区别和使用</li><li>hive和传统数据库之间的区别</li><li>hive和hbase的区别</li><li>hive的分区</li><li>hive的分桶</li><li>hive严格模式</li><li>hive中的排序关键字有哪些</li><li>hive的join底层是实现</li><li>hive导入数据的四种方式</li><li>hive中数据倾斜的原因</li><li>hive性能调优</li><li>hive的udf和udaf和udft</li></ul><p>java程序员面试宝典</p><ul><li>10亿数据中找出最大的1000个数</li><li>大数据面试问题分而治之。</li></ul><h2 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h2><ol><li><p>面向对象的特征有哪些&#x2F;接口和抽象类的区别&#x2F;java面向对象的三大特性</p><ul><li>抽象：抽象是将一类对象的共同特征总结出来构造类的过程，<code>java</code>中包括抽象类和接口，抽象类和接口的区别如下:<ul><li>接口的方法默认是<code>public</code>的，所有方法在接口中不能有实现，但是在<code>java8</code>接口方法可以有默认实现，抽象类可以有非抽象的方法。</li><li>接口中抽了<code>static</code>和<code>final</code>变量，不能有其他变量，抽象类没有这个规定。</li><li>一个类可以实现多个接口，但是一个类只能实现一个抽象方法，接口自己也可以通过<code>extends</code>关键字扩展多个接口。</li><li>接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。</li><li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li><li><code>java8</code>接口可以定义默认方法，也可以顶一个静态方法，当一个类实现了两个接口时，两个接口有一样的默认方法，该类必须要重写方法，否则会产生歧义，通过该类的对象会不知道调用哪个接口的默认方法。</li><li><code>java9</code>在引入了私有方法和私有静态方法。这两个方法都需要有实现。</li></ul></li><li>继承<ul><li>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。继承的注意事项：<ul><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ul></li><li>继承的底层原理:<ul><li>JAVA继承并不是复制，只是获取了父类的引用super。另外JAVA的继承是在JVM编译阶段就执行好了的，首先执行父类的构造方法，然后执行子类的构造方法，子类只是获取了父类对象在内存中的引用。</li></ul></li></ul></li><li>封装<ul><li>通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。  我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装  。</li></ul></li><li>多态<ul><li>方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）  ，是子类对父类的允许访问的方法的实现过程进行重新编写。方法重载可以理解成不同参数的方法其实是不同的方法，方法名在编译的时候并不相同。方法重写是。而重载的实现是虚函数表，所谓虚方法表，就是在类加载的时候，为每个类创建一个表，这个表包括该类的对象所有动态绑定的方法及其地址，包括父类的方法，但一个方法只有一条记录，子类重写了父类方法后只会保留子类的。重载发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</li></ul></li></ul></li><li><p>一个类的基本信息有哪些?</p><ol><li><p>类变量(静态变量)：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> b<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">static</span> String c<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> d<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>类初始化代码:</p><ol><li><p>自定义静态变量的赋值语句。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>    a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>静态代码初始块</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">static</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"static scrop"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li><li><p>类方法(静态方法)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"class static method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>实例变量</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>实例初始化代码</p><ol><li><p>定义实例变量时的赋值语句</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义时没有赋值，编译器会有个一个默认值</span>        <span class="token keyword">public</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//构造方法变量进行初始化，如果没有会有一个默认构造函数对变量赋初值。</span>    <span class="token punctuation">}</span>        <span class="token punctuation">{</span>        a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//实例初始化代码块</span><span class="token punctuation">}</span></code></pre></li><li><p>实例初始化代码</p></li><li><p>构造方法</p></li></ol></li><li><p>实例方法</p></li><li><p>父类信息引用:</p></li></ol></li><li><p>类中各部分代码执行的顺序。</p><ol><li><p>在类加载的第三阶段也就是准备阶段完成对类变量分配内存并为类变量赋初值的过程，这里要理解的是这个如<code>public static int = 123</code>的语句在准备阶段后的值是0，而把value赋值为123的·<code>putstatic</code>指令是程序被编译后， 存放于类构造器<code>&lt;clint()&gt;</code> 方法之中， 所以把value赋值为123的动作将在初始化阶段才会执行。  实例变量将会在对象实例化时随着对象一起分配在Java堆中  ,<code>clinit()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（ static{}块） 中的语句合并产生的， 编译器收集的顺序是由语句在源文件中出现的顺序所决定的， 静态语句块中只能访问到定义在静态语句块之前的变量， 定义在它之后的变量， 在前面的静态语句块可以赋值， 但是不能访问 。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">static</span><span class="token punctuation">{</span>        i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//可以对变量赋值</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printlin</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//编译器会提示非法向前引用，因为这块代码在前面看不到后面</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>父类的<code>clinit</code>方法会在子类之前调用，虚拟机保证。父类中定义的静态语句块要优先于子类的变量赋值操作  。</p></li><li><p>实例变量在对象被创建出来的时候才会被创建，每个对象除了保存类的实例变量之外，还保存着实际类信息的引用。，创建对象的过程：</p><ol><li>分配内存。</li><li>对所有实例变量赋默认值。</li><li>执行实例初始化代码。</li></ol></li></ol></li><li><p>访问修饰符 public,private,protected,以及不写（默认）时的区别？  </p><table><thead><tr><th>修饰符</th><th>当前类</th><th>同包</th><th>子类</th><th>其他包</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>default</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li>类的成员不写访问修饰时默认为 default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java 中，外部类的修饰符只能是 public 或默认，类的成员（包括内部类）的修饰符可以是以上四种 。</li></ul></li><li><p>String 是最基本的数据类型吗？  </p><ul><li>不是，基本数据类型只有8中，其他全部是引用类型</li></ul></li><li><p>float f&#x3D;3.4;是否正确？  、</p><ul><li>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f &#x3D;(float)3.4; 或者写成 float f &#x3D;3.4F;</li></ul></li><li><p>short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗？  </p><ul><li>第一个有错误，s1+1是int类型如果要赋值给short需要类型转换，而第二个+&#x3D;有隐含的强制类型转换。也即使说第二个在编译的时候会变成<code>s1 = (short)(s1+1);</code></li></ul></li><li><p>int 和 Integer 有什么区别？  </p><ul><li>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱&#x2F;拆箱机制，使得二者可以相互转换。如果整型字面量的值在-128 到 127 之间，那么不会 new 新的 Integer对象，而是直接引用常量池中的 Integer 对象</li></ul></li><li><p>java有没有引用传递?</p><ul><li>java只有值传递，但是我们在传递一个对象的时候其实是将这个对象的地址作为一个值传入到了函数当中，所以也能完成对对象属性的修改。也即使说我们将一个对象传递到一个方法中的时候，实际上传递的是该引用的一个副本，但是这个副本也是执行堆中的一块区域的，所以也可以改变值。</li></ul></li><li><p>String 和 StringBuilder、StringBuffer 的区别？  </p><ul><li>String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以 String 对象是不可变的。</li><li>而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</li><li>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</li><li>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。</li></ul></li><li><p>char 型变量中能不能存贮一个中文汉字，为什么  </p><ul><li>char 类型可以存储一个中文汉字，因为 Java 中使用的编码是 Unicode（不选择<br>任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一<br>个 char 类型占 2 个字节（16 比特），所以放一个中文是没问题的。</li></ul></li><li><p>静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？  </p><ul><li>Static Nested Class 是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化</li></ul></li><li><p>Java 中会存在内存泄漏吗，请简单描述。  </p><ul><li>理论上 Java 因为有垃圾回收机制（ GC）不会存在内存泄露问题（这也是 Java 被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被 GC 回收 ，因此也会导致内</li><li>泄露的发生 。</li></ul></li><li><p>Error 和 Exception 有什么区别</p><ul><li>Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；<br>也就是说，它表示如果程序运行正常，从不会发生的情况</li></ul></li><li><p><code>&lt;? extends T&gt;</code>和<code>&lt;? super T&gt;</code>的区别？</p><ol><li><? extends T> 表示类型的上界，表示参数化类型的可能是T 或是 T的子类;带来的好处就是可以用子类去给父类赋值了。</li><li><? super T> 表示类型下界（Java Core中叫超类型限定），表示参数化类型是此类型的超类型（父类型），这句话的意思也即是参数的类型可能是T或者T的祖先们。</li><li>参数写成：T&lt;? super B&gt;，对于这个泛型，?代表容器里的元素类型，由于只规定了元素必须是B的超类，导致元素没有明确统一的“根”（除了Object这个必然的根），所以这个泛型你其实无法使用它，对吧，除了把元素强制转成Object。所以，对把参数写成这样形态的函数，你函数体内，只能对这个泛型做<strong>插入操作，而无法读</strong></li><li>参数写成： T&lt;? extends B&gt;，由于指定了B为所有元素的“根”，你任何时候都可以安全的用B来使用容器里的元素，但是插入有问题，由于供奉B为祖先的子树有很多，不同子树并不兼容，由于实参可能来自于任何一颗子树，所以你的插入很可能破坏函数实参，所以，对这种写法的形参，<strong>禁止做插入操作，只做读取</strong>。</li><li>Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</li></ol></li><li><p>理解lambda表达式吗</p><ol><li>lambda表达式是为了是实现函数式编程的，如果一个接口只有一个需要子类重写的方法，那么我们就可以使用lambda表达式方便的实现一个类。</li><li>Lambda 表达式中要用到的，但又未在 Lambda 表达式中声明的变量，必须声明为 final 或者是 effectively final，否则就会出现编译错误。</li></ol></li></ol><h2 id="JAVA容器"><a href="#JAVA容器" class="headerlink" title="JAVA容器"></a>JAVA容器</h2><p><img src="C:\Users\gaobo\AppData\Roaming\Typora\typora-user-images\image-20200509134711734.png" alt="image-20200509134711734"></p><ol><li><p>Collection简介?</p></li><li><p>Collection接口也就是集合，集合可以存储多个元素，但是对多个元素有一定的要求：</p><ol><li><p>多个元素能按照某种规则排序。</p></li><li><p>接口中定义了一些子类或者接口需要重写的方法，还有一些有实现的默认方法。</p></li><li><p>该接口继承自Iterable接口，Iterable接口源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Iterator<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Objects<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Spliterator<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Spliterators<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span>Consumer<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     *实现这个接口的的类允许使用"for-each loop"语句来遍历。     */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterable</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     *返回一个元素类型为T的迭代器     */</span>    Iterator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     jdk1.8新增的遍历方式     */</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">forEach</span><span class="token punctuation">(</span>Consumer<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>T t <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            action<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 暂不研究     */</span>    <span class="token keyword">default</span> Spliterator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">spliterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Spliterators<span class="token punctuation">.</span><span class="token function">spliteratorUnknownSize</span><span class="token punctuation">(</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>Iterator是定义了三个方法和实现了一个默认的方法，源码如下:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> java<span class="token punctuation">.</span>util<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span>Consumer<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//返回集合中是否有更多的元素</span>    <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//返回集合中的下一个元素</span>    E <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token string">"remove"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">forEachRemaining</span><span class="token punctuation">(</span>Consumer<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> E<span class="token operator">></span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            action<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>Collection的源码如下:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> java<span class="token punctuation">.</span>util<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span>Predicate<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>stream<span class="token punctuation">.</span>Stream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>stream<span class="token punctuation">.</span>StreamSupport<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Collection</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Iterable</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//返回集合中元素的个数</span>    <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//判断集合是否是空的</span>    <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//判断集合手否处在某个元素</span>    <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//返回一个迭代器</span>    Iterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//返回一个包含所有元素的数组</span>    Object<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token operator">&lt;</span>T<span class="token operator">></span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Modification Operations</span>    <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">containsAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">removeAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">removeIf</span><span class="token punctuation">(</span>Predicate<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> E<span class="token operator">></span> filter<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>filter<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> removed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> Iterator<span class="token operator">&lt;</span>E<span class="token operator">></span> each <span class="token operator">=</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>each<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>filter<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>each<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                each<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                removed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> removed<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">boolean</span> <span class="token function">retainAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Comparison and hashing</span>    <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">default</span> Stream<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> StreamSupport<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token function">spliterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">default</span> Stream<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">parallelStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> StreamSupport<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token function">spliterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>AbstractCollection是一个实现了Collection接口的抽象类，除了iterator()和size()接口，它提供了一些其他接口的默认实现，其他集合类可以继承此类来复用。</p></li></ol></li><li><p>说下list，set和map的区别？</p><ol><li><strong>List(对付顺序的好帮手)：</strong> List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</li><li><strong>Set(注重独一无二的性质):</strong> 不允许重复的集合。不会有多个元素引用相同的对象。</li><li><strong>Map(用Key来搜索的专家):</strong> 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</li></ol></li><li><p>ArrayList和LinkedList的区别，以及LinkedList和ArrayDeque？</p><ol><li>**是否保证线程安全  **<code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li><li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li><strong>插入和删除是否受元素位置的影响：</strong> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e) </code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element) </code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></li><li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index) </code>方法)。</li><li><strong>内存空间占用：</strong> ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ol></li><li><p>ArrayList和Deque的区别?</p><ol><li><code>Vector</code>类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。<code>Arraylist</code>不是同步的，所以在不需要保证线程安全时建议使用Arraylist。</li></ol></li><li><p>说下ArrayList的扩容机制?</p><ol><li><strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。</strong> </li><li><strong>int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1,所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity为偶数就是1.5倍，否则是1.5倍左右）！</strong></li></ol></li><li><p>HashMap和HashTable的区别？</p><ol><li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li><li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li><li><strong>对Null key 和Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li><li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。</li><li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制</li></ol></li><li><p>HashSet如何检查重复</p></li></ol><pre><code>  1. 当你把对象加入`HashSet`时，HashSet会先计算对象的`hashcode`值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用`equals()`方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。  2. hashcode()和equals的相关规定?     1. 如果两个对象相等，则hashcode一定也是相同的     2. 两个对象相等,对两个equals方法返回true     3. 两个对象有相同的hashcode值，它们也不一定是相等的     4. 综上，equals方法被覆盖过，则hashCode方法也必须被覆盖     5. hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。  3. ==和equal的区别     1. ==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同     2. ==是指对内存地址进行比较 equals()是对字符串的内容进行比较     3. ==指引用是否相同 equals()指的是值是否相</code></pre><ol start="8"><li><p>hashMap的底层实现?</p><ol><li><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p></li><li><p>JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> h<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// key.hashCode()：返回散列值也就是hashcode</span>      <span class="token comment" spellcheck="true">// ^ ：按位异或</span>      <span class="token comment" spellcheck="true">// >>>:无符号右移，忽略符号位，空位都以0补齐</span>      <span class="token comment" spellcheck="true">//如果key是null的话hash值是零，否则用key的hashCode和它本身的右移16位进行XOR运算，这样做是为了避免hash算法不好导致key.hashCode()分布不够均匀</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>对比一下 JDK1.7的 HashMap 的 hash 方法源码.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// This function ensures that hashCodes that differ only by</span>    <span class="token comment" spellcheck="true">// constant multiples at each bit position have a bounded</span>    <span class="token comment" spellcheck="true">// number of collisions (approximately 8 at default load factor).</span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p></li><li><p>相比于之前的版本， JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p></li></ol></li><li><p>HashMap的长度为什么要是二的次幂?</p><ol><li>“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</li></ol></li><li><p>HashMap扩容机制？</p><ol><li>初始容量定义：默认为1 &lt;&lt; 4（16）。最大容量为1&lt;&lt; 30</li><li>扩容加载因子为(0.75)，第一个临界点在当HashMap中元素的数量大于table数组长度<em>加载因子（16**0.75&#x3D;12），<br>则按oldThr &lt;&lt; 1（原长度</em>2）扩容。</li></ol></li><li><p>底层容器总结:</p><p>​1.List</p><ul><li><strong>Arraylist：</strong> Object数组</li><li><strong>Vector：</strong> Object数组</li><li><strong>LinkedList：</strong> 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环)</li></ul><ol start="2"><li>Set</li></ol><ul><li><strong>HashSet（无序，唯一）:</strong> 基于 HashMap 实现的，底层采用 HashMap 来保存元素</li><li><strong>LinkedHashSet：</strong> LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的</li><li><strong>TreeSet（有序，唯一）：</strong> 红黑树(自平衡的排序二叉树)</li></ul><ol start="3"><li>Map</li></ol><ul><li><strong>HashMap：</strong> JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li><li><strong>LinkedHashMap：</strong> LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li><strong>Hashtable：</strong> 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li><strong>TreeMap：</strong> 红黑树（自平衡的排序二叉树）</li></ul></li><li><p>ConcurrentHashMap和HashTable区别?</p><ol><li><strong>底层数据结构：</strong> JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ol></li><li><p>怎么选择集合?</p><ol><li>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用Map接口下的集合，需要排序时选择TreeMap,不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap.当我们只需要存放元素值时，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList，然后再根据实现这些接口的集合的特点来选用。</li></ol></li></ol><h2 id="jvm-1"><a href="#jvm-1" class="headerlink" title="jvm"></a>jvm</h2><ol><li><p>jvm基本概念？</p><ul><li>jvm可以理解为运行java代码的假象的计算机，包括一套字节码指令集，一组寄存器，一个栈，一个垃圾回收，堆和一个存储方法域。jvm是运行在操作系统之上的，与硬件没有直接的联系。</li></ul></li><li><p>java文件的运行过程？</p><ul><li>java源文件通过编译器编程字节码文件，字节码文件通过jvm变成机械码，可以在操作系统上运行，扩平台是因为每个平台的编译器不同，但是jvm是相同的。</li></ul></li><li><p>jvm后台运行的线程有哪些？</p><ul><li>虚拟机线程，这个线程等待 JVM 到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当堆修改无法进行时，线程都需要 JVM 位于安全点。这些操作的类型有： stop-theworld 垃圾回收、线程栈 dump、线程暂停、线程偏向锁（biased locking）解除。</li><li>周期性任务线程：这线程负责定时器事件（也就是中断），用来调度周期性操作的执行。</li><li>GC 线程 这些线程支持 JVM 中不同的垃圾回收活动。</li><li>编译器线程 这些线程在运行时将字节码动态编译成本地平台相关的机器码。</li><li>信号分发线程 这个线程接收发送到 JVM 的信号并调用适当的 JVM 方法处理</li></ul></li><li><p>java内存区域(**)</p><ul><li>VM 内存区域主要分为线程私有区域(程序计数器、虚拟机栈、本地方法区)、线程共享区域(JAVA 堆、方法区)、直接内存。线程私有数据区域生命周期与线程相同, 依赖用户线程的启动&#x2F;结束 而 创建&#x2F;销毁。线程共享区域随虚拟机的启动&#x2F;关闭而创建&#x2F;销毁。直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用: 在 JDK 1.4 引入的 NIO 提供了基于 Channel 与 Buffer 的 IO 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I&#x2F;O 扩展), 这样就避免了在 Java堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。</li><li>程序计数器：<ul><li>一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有” 的内存。</li><li>正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址） 。</li><li>如果还是 Native 方法，则为空。这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域</li></ul></li><li>虚拟机栈：<ul><li>是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</li></ul></li><li>本地方法区：<ul><li>本地方法区和 Java Stack 作用类似, 区别是虚拟机栈为执行 Java 方法服务, 而本地方法栈则为Native 方法服务, 如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用, 那么该栈将会是一个C 栈，但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一</li></ul></li><li>堆：<ul><li>是被线程共享的一块内存区域， 创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。 由于现代 VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、 From Survivor 区和 To Survivor 区)和老年代。</li></ul></li><li>方法区：<ul><li>我们常说的永久代(Permanent Generation), 用于存储被 JVM 加载的类信息、 常量、 静态变量、 即时编译器编译后的代码等数据. HotSpot VM把GC分代收集扩展至方法区, 即使用Java堆的永久代来实现方法区, 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存,而不必为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对常量池的回收和类型的卸载, 因此收益一般很小)。</li><li>在 Java8 中， 永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于： 元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。 类的元数据放入nativememory, 字符串池和类的静态变量放入 java 堆中， 这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制</li><li>运行时常量池（Runtime Constant Pool）是方法区的一部分。 Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 Java 虚拟机对 Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行</li></ul></li></ul></li><li><p>new一个对象后发生的过程？</p><ul><li>首先检查类是否已被加载如果没有执行相应的类加载过程。</li><li>分配内存，两种方法指针碰撞，空闲列表。Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。Java堆中内存是绝对规整的， 所有用过的内存都放在一边， 空闲的内存放在另一边， 中间放着一个指针作为分界点的指示器， 那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。如果Java堆中的内存并不是规整的， 已使用的内存和空闲的内存相互交错， 那就没有办法简单地进行指针碰撞了， 虚拟机就必须维护一个列表， 记录上哪些内存块是可用的， 在分配的时候从列表中找到一块足够大的空间划分给对象实例， 并更新列表上的记录， 这种分配方式称为“ 空闲列表” 。</li><li>内存分配完成后， 虚拟机需要将分配到的内存空间都初始化为零值（ 不包括对象头）。</li><li>虚拟机要对对象进行必要的设置， 例如这个对象是哪个类的实例、 如何才能找到类的元数据信息、 对象的哈希码、 对象的GC分代年龄等信息。 这些信息存放在对象的对象头（ Object Header） 之中。 根据虚拟机当前的运行状态的不同， 如是否启用偏向锁等， 对象头会有不同的设置方式。</li></ul></li><li><p>对内存的并发操作不安全怎么解决？ </p><ul><li>一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性.</li><li>另一种是把内存分配的动作按照线程划分在不同的空间之中进行， 即每个线程在Java堆中预先分配一小块内存， 称为本地线程分配缓冲（ Thread Local Allocation Buffer,TLAB） 。</li></ul></li><li><p>对象的内存布局？</p><ul><li>在HotSpot虚拟机中， 对象在内存中存储的布局可以分为3块区域： 对象头（ Header） 、 实例数据（ InstanceData） 和对齐填充（ Padding） 。</li><li>对象头： 第一部分用于存储对象自身的运行时数据， 如哈希码（ HashCode） 、 GC分代年龄、 锁状态标志、 线程持有的锁、 偏向线程ID、 偏向时间戳等，在32位的HotSpot虚拟机中， 如果对象处于未被锁定的状态下， 那么Mark Word的32bit空间中的25bit用于存储对象哈希码， 4bit用于存储对象分代年龄， 2bit用于存储锁标志位， 1bit固定为0，对象头的另外一部分是类型指针， 即对象指向它的类元数据的指针， 虚拟机通过这个指针来确定这个对象是哪个类的实例。 </li><li>接下来的实例数据部分是对象真正存储的有效信息， 也是在程序代码中所定义的各种类型的字段内容。 无论是从父类继承下来的， 还是在子类中定义的， 都需要记录起来。</li><li>第三部分对齐填充并不是必然存在的， 也没有特别的含义， 它仅仅起着占位符的作用。 由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍， 换句话说， 就是对象的大小必须是8字节的整数倍。</li></ul></li><li><p>对象访问的方式？</p><ul><li>如果使用句柄访问的话， 那么Java堆中将会划分出一块内存来作为句柄池， reference中存储的就是对象的句柄地址， 而句柄中包含了对象实例数据与类型数据各自的具体地址信息。使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址， 在对象被移动（ 垃圾收集时移动对象是非常普遍的行为） 时只会改变句柄中的实例数据指针， 而reference本身不需要修改</li><li>如果使用直接指针访问， 那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息， 而reference中存储的直接就是对象地址，</li><li>String str1 &#x3D; “string”; String str2 &#x3D; new String(“string”);第一种是对象类型数据，存在方法区。第二种是对象实例数据，存在堆内存。</li><li>使用指针的好处是访问的速度更快，节省了一次指针定位的是时间开销。</li></ul></li><li><p>如何判断对象已经死亡?</p><ul><li>引用计数算法:引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关联的引用， 即他们的引用计数都不为 0， 则说明对象不太可能再被用到，那么这个对象就是可回收对象。可作为GC Roots的对象包括下面几种：虚拟机栈（ 栈帧中的本地变量表） 中引用的对象。方法区中类静态属性引用的对象。方法区中常量引用的对象。本地方法栈中JNI（ 即一般说的Native方法） 引用的对象。</li><li>可达性分析算法：如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。要注意的是，不可达对象不等价于可回收对象， 不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链， 那它将会被第一次标记并且进行一次筛选， 筛选的条件是此对象是否有必要执行finalize（ ） 方法。</li><li>永久代的垃圾收集主要回收两部分内容： 废弃常量和无用的类。 回收废弃常量与回收Java堆中的对象非常类似。 以常量池中字面量的回收为例， 假如一个字符串“ abc” 已经进入了常量池中， 但是当前系统没有任何一个String对象是叫做“ abc” 的， 换句话说， 就是没有任何String对象引用常量池中的“ abc” 常量， 也没有其他地方引用了这个字面量， 如果这时发生内存回收， 而且必要的话， 这个“ abc” 常量就会被系统清理出常量池。 常量池中的其他类（ 接口） 、 方法、 字段的符号引用也与此类似。判定一个常量是否是“ 废弃常量” 比较简单， 而要判定一个类是否是“ 无用的类” 的条件则相对苛刻许多。 类需要同时满足下面3个条件才能算是“ 无用的类” ：该类所有的实例都已经被回收， 也就是Java堆中不存在该类的任何实例。加载该类的ClassLoader已经被回收。该类对应的java.lang.Class对象没有在任何地方被引用， 无法在任何地方通过反射访问该类的方法。</li></ul></li><li><p>引用的类型有哪些?</p><ul><li>强引用：强引用就是指在程序代码之中普遍存在的， 类似“ Object obj&#x3D;new Object（ ） ” 这类的引用， 只要强引用还存在， 垃圾收集器永远不会回收掉被引用的对象。</li><li>软引用：软引用是用来描述一些还有用但并非必需的对象。 对于软引用关联着的对象， 在系统将要发生内存溢出异常之前， 将会把这些对象列进回收范围之中进行第二次回收。 如果这次回收还没有足够的内存， 才会抛出内存溢出异常。 </li><li>弱引用:弱引用也是用来描述非必需对象的， 但是它的强度比软引用更弱一些， 被弱引用关联的对象只能生存到下一次垃圾收集发生之前。 当垃圾收集器工作时， 无论当前内存是否足够， 都会回收掉只被弱引用关联的对象</li><li>虚引用：虚引用也称为幽灵引用或者幻影引用， 它是最弱的一种引用关系。 一个对象是否有虚引用的存在， 完全不会对其生存时间构成影响， 也无法通过虚引用来取得一个对象实例。 为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ul></li><li><p>基本垃圾回收算法?</p><ul><li>标记清除算法（Mark-Sweep）:最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。该算法最大的问题是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题</li><li>复制算法（copying）:为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话， Copying 算法的效率会大大降低。</li><li>标记整理算法(Mark-Compact): 标记阶段和 Mark-Sweep 算法相同， 标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象</li><li>分代收集算法：分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured&#x2F;Old Generation)和新生代(YoungGeneration)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法<ul><li>JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1： 1 来划分新生代。一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。</li><li>而老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。</li></ul></li></ul></li><li><p>常见垃圾收集器有哪些？</p><ul><li>Serial 垃圾收集器（单线程、 复制算法）：Serial（英文连续） 是最基本垃圾收集器，使用复制算法，曾经是JDK1.3.1 之前新生代唯一的垃圾收集器。 Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 Serial垃圾收集器依然是 java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器。</li><li>ParNew 垃圾收集器（Serial+多线程）：ParNew 垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和 Serial 收集器完全一样， ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。ParNew 收集器默认开启和 CPU 数目相同的线程数，可以通过-XX:ParallelGCThreads 参数来限制垃圾收集器的线程数。 【Parallel：平行的】ParNew 虽然是除了多线程外和Serial 收集器几乎完全一样，但是ParNew垃圾收集器是很多 java虚拟机运行在 Server 模式下新生代的默认垃圾收集器</li><li>Parallel Scavenge 收集器（多线程复制算法、高效）：Parallel Scavenge 收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器， 它重点关注的是程序达到一个可控制的吞吐量（Thoughput， CPU 用于运行用户代码的时间&#x2F;CPU 总消耗时间，即吞吐量&#x3D;运行用户代码时间&#x2F;(运行用户代码时间+垃圾收集时间)），高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。 自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个重要区别</li><li>Serial Old 收集器（单线程标记整理算法 ）： Serial Old 是 Serial 垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在 Client 默认的 java 虚拟机默认的年老代垃圾收集器。在 Server 模式下，主要有两个用途：<ol><li>在 JDK1.5 之前版本中与新生代的 Parallel Scavenge 收集器搭配使用。</li><li>作为年老代中使用 CMS 收集器的后备垃圾收集方案。</li></ol></li><li>Parallel Old 收集器（多线程标记整理算法）:Parallel Old 收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在 JDK1.6才开始提供。在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量， Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器， 如果系统对吞吐量要求比较高，可以优先考虑新生代 Parallel Scavenge和年老代 Parallel Old 收集器的搭配策略。</li><li>CMS 收集器（多线程标记清除算法）:Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间， 和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段：<ol><li>初始标记: 只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。</li><li>并发标记: 进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。</li><li>重新标记: 为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程</li><li>并发清除: 清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作， 所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。<br>由于CMS并发清理阶段用户线程还在运行着， 伴随程序运行自然就还会有新的垃圾不断产生， 这一部分垃圾出现在标记过程之后， CMS无法在当次收集中处理掉它们， 只好留待下一次GC时再清理掉。CMS是一款基于“ 标记—清除” 算法实现的收集器， 如果读者对前面这种算法介绍还有印象的话， 就可能想到这意味着收集结束时会有大量空间碎片产生。 空间碎片过多时， 将会给大对象分配带来很大麻烦， 往往会出现老年代还有很大空间剩余， 但是无法找到足够大的连续空间来分配当前对象， 不得不提前触发一次Full GC。</li></ol></li><li>Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器， G1 收集器两个最突出的改进是：<ol><li>基于标记-整理算法，不产生内存碎片。</li><li>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。<br>G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间， 优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率.</li></ol></li></ul></li><li><p>内存分配和内存策略(对象何时进入老年态)</p><ul><li>大多数情况下， 对象在新生代Eden区中分配。 当Eden区没有足够空间进行分配时， 虚拟机将发起一次Minor GC</li><li>大对象直接进入老年代,所谓的大对象是指， 需要大量连续内存空间的Java对象， 最典型的大对象就是那种很长的字符串以及数组</li><li>虚拟机给每个对象定义了一个对象年龄（ Age） 计数器。 如果对象在Eden出生并经过第一次Minor GC后仍然存活， 并且能被Survivor容纳的话， 将被移动到Survivor空间中， 并且对象年龄设为1。 对象在Survivor区中每“ 熬过” 一次Minor GC， 年龄就增加1岁， 当它的年龄增加到一定程度（ 默认为15岁） ，就将会被晋升到老年代中。 </li><li>为了能更好地适应不同程序的内存状况， 虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代， 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半， 年龄大于或等于该年龄的对象就可以直接进入老年代， 无须等到MaxTenuringThreshold中要求的年龄。</li><li>在发生Minor GC之前， 虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间， 如果这个条件成立， 那么Minor GC可以确保是安全的。 如果不成立， 则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。 如果允许， 那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于， 将尝试着进行一次Minor GC， 尽管这次Minor GC是有风险的； 如果小于， 或者HandlePromotionFailure设置不允许冒险， 那这时也要改为进行一次Full GC。</li></ul></li><li><p>java运行时内存?</p><ul><li>新生代:是用来存放新生的对象。一般占据堆的 1&#x2F;3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden 区、 ServivorFrom、 ServivorTo 三个区。<ul><li>eden区：Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发minorGC，对新生代区进行一次垃圾回收。</li><li>ServivorFrom：上一次 GC 的幸存者，作为这一次 GC 的被扫描者。</li><li>ServivorTo：保留了一次 MinorGC 过程中的幸存者。</li></ul><ol><li>eden、 servicorFrom 复制到 ServicorTo，年龄+1首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位置了就放到老年区）；</li><li>清空 eden、 servicorFrom然后，清空 Eden 和 ServicorFrom 中的对象；</li><li>ServicorTo 和 ServicorFrom 互换</li><li>最后， ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区。</li></ol></li><li>老年代:主要存放应用程序中生命周期长的内存对象。老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。 MajorGC 的耗时比较长，因为要扫描再回收。 MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。</li></ul></li><li><p>java类加载机制</p><ul><li>加载：加载是类加载过程中的一个阶段， 这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象， 作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。通过类的完全限定名获取定义该类的二进制字节流<br>将该字节流表示的静态存储结构转换成运行时的存储结构，在内存中生成一个代表该类的class对象，作为方法区中该类各种数据的入口。<ul><li>通过一个类的全限定名获取定义此类的二进制字节流。 </li><li>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构  </li><li>在内存中生成一个代表这个类的java.lang.Class对象， 作为方法区这个类的各种数据的访问入口</li></ul></li><li>验证：这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</li><li>准备：准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。</li></ul></li></ol><ul><li>解析：解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。（也即是将符号引用转为确定的地址空间的过程)<br>  *  符号引用与虚拟机实现的布局无关， 引用的目标并不一定要已经加载到内存中。 各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的引用，那引用的目标必定已经在内存中存在<ul><li>初始化：初始化阶段才真正开始执行类中定义的Java程序代码，初始化阶段是虚拟机执行类构造器<code>&lt;clinit&gt;()</code>方法的过程，在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</li></ul></li></ul><ol start="16"><li><p>类加载器的种类？</p><ul><li>启动类加载器(Bootstrap ClassLoader)<ol><li>负责加载 JAVA_HOME\lib 目录中的， 或通过-Xbootclasspath 参数指定路径中的， 且被虚拟机认可（按文件名识别， 如 rt.jar） 的类。</li></ol></li><li>扩展类加载器(Extension ClassLoader)<ol start="2"><li>负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库。</li></ol></li><li>应用程序类加载器(Application ClassLoader)：<ol start="3"><li>负责加载用户路径（classpath）上的类库。JVM 通过双亲委派模型进行类的加载， 当然我们也可以通过继承 java.lang.ClassLoader<br>  实现自定义的类加载器。</li></ol></li></ul></li><li><p>双亲委派模型是什么？</p><ul><li>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class）， 子类加载器才会尝试自己去加载。采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。</li></ul></li><li><p>class文件</p><ul><li>class文件是一组8字节为基础单位的二进制流，class文件是一中类似于C语言伪结构体的结构来存储数据的，这种伪结构体中只有两种数据元素，无符号数和表。<ul><li>魔数与class文件的版本。</li><li>常量池:常量池主要包括字面量和符号引用字面量如”hello”,符号引用包括了类和接口的的全限定名、字段的名称和描述符、方法的名称和描述符。Java代码在进行Javac编译的时候， 并不像C和C++那样有“ 连接” 这一步骤， 而是在虚拟机加载Class文件的时候进行动态连接。 也就是说， 在Class文件中不会保存各个方法、 字段的最终内存布局信息， 因此这些字段、 方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址， 也就无法直接被虚拟机使用。 当虚拟机运行时，需要从常量池获得对应的符号引用， 再在类创建时或运行时解析、 翻译到具体的内存地址之中。   </li><li>访问标志：在常量池结束之后， 紧接着的两个字节代表访问标志（ access_flags） ， 这个标志用于识别一些类或者接口层次的访问信息， 包括： 这个Class是类还是接口； 是否定义为public类型； 是否定义为abstract类型； 如果是类的话， 是否被声明为final等。   </li><li>类索引、父类索引、接口索引集合:确定类的继承关系。</li><li>字段表集合:用来描述接口或者类中声明的变量。但是不包括类中局部变量。</li><li>方法表集合:用来描述接口或者类中声明的方法。</li></ul></li></ul></li><li><p>类加载器：</p><ol><li>从Java虚拟机的角度来讲， 只存在两种不同的类加载器： 一种是启动类加载器（ Bootstrap ClassLoader） ，<br> 这个类加载器使用C++语言实现[1]， 是虚拟机自身的一部分； 另一种就是所有其他的类加载器， 这些类加载器都由<br> Java语言实现， 独立于虚拟机外部， 并且全都继承自抽象类java.lang.ClassLoader。  </li><li>类加载器种类：<ul><li>Bootstrap：一般用本地代码实现，负责加载 JVM 基础核心类库（rt.jar）；</li><li>Extension：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap；、</li><li>System：又叫应用类加载器，其父类是 Extension。它是应用最广泛的类加载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目录中记载类，是用户自定义加载器的默认父加载器。</li></ul></li></ol></li></ol><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul><li><p>线程状态有哪些</p><ul><li>新建状态：当程序使用 new 关键字创建了一个线程之后，该线程就处于新建状态，此时仅由 JVM 为其分配内存，并初始化其成员变量的值</li><li>就绪状态（RUNNABLE）：当线程对象调用了 start()方法之后，该线程处于就绪状态。 Java 虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。</li><li>运行状态（RUNNING）：如果处于就绪状态的线程获得了 CPU，开始执行 run()方法的线程执行体，则该线程处于运行状态。</li><li>阻塞状态（BLOCKED）：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得 cpu timeslice 转到运行(running)状态。阻塞的情况分三种：<ul><li>等待阻塞（o.wait-&gt;等待对列） ：运行(running)的线程执行 o.wait()方法， JVM 会把该线程放入等待队列(waitting queue)中。</li><li>同步阻塞(lock-&gt;锁池)：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池(lock pool)中</li><li>其他阻塞(sleep&#x2F;join)：运行(running)的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I&#x2F;O 请求时，JVM 会把该线程置为阻塞状态。当 sleep()状态超时、 join()等待线程终止或者超时、或者 I&#x2F;O处理完毕时，线程重新转入可运行(runnable)状态。</li></ul></li><li>线程死亡（DEAD）线程会以下面三种方式结束，结束后就是死亡状态。<br>  正常结束<ol><li>run()或 call()方法执行完成，线程正常结束。<br>  异常结束</li><li>线程抛出一个未捕获的 Exception 或 Error。<br>  调用 stop</li><li>直接调用该线程的 stop()方法来结束该线程—该方法通常容易导致死锁，不推荐使用</li></ol></li></ul></li><li><p>创建线程的几种方式</p><ul><li>继承 Thread 类：Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。 启动线程的唯一方法就是通过 Thread 类的 start()实例方法。 start()方法是一个 native 方法，它将启动一个新线程，并执行 run()方法。</li><li>实现 Runnable 接口。如果自己的类已经 extends 另一个类，就无法直接 extends Thread，此时，可以实现一个Runnable 接口。</li><li>ExecutorService、 Callable<Class>、 Future 有返回值线程：有返回值的任务必须实现 Callable 接口，类似的，无返回值的任务必须 Runnable 接口。执行Callable 任务后，可以获取一个 Future 的对象，在该对象上调用 get 就可以获取到 Callable 任务返回的 Object 了，再结合线程池接口 ExecutorService 就可以实现有返回结果的多线程了</li><li>基于线程池的方式：线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建，不需要的时候销毁，是非常浪费资源的。那么我们就可以使用缓存的策略，也就是使用线程池</li></ul></li><li><p>volatile底层原理</p><ul><li>可见性：即当一个线程修改了声明为volatile变量的值，新值对于其他要读该变量的线程来说是立即可见的。而普通变量是不能做到这一点的，普通变量的值在线程间传递需要通过主内存来完成。</li><li>有序性：volatile变量的所谓有序性也就是被声明为volatile的变量的临界区代码的执行是有顺序的，即禁止指令重排序。</li><li>受限原子性：这里volatile变量的原子性与synchronized的原子性是不同的，synchronized的原子性是指只要声明为synchronized的方法或代码块儿在执行上就是原子操作的。而volatile是不修饰方法或代码块儿的，它用来修饰变量，对于单个volatile变量的读&#x2F;写操作都具有原子性，但类似于volatile++这种复合操作不具有原子性。所以volatile的原子性是受限制的。并且在多线程环境中，volatile并不能保证原子性。</li><li>有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，通过查IA-32架构软件开发者手册可知，Lock前缀的指令在多核处理器下会引发了两件事情<ul><li>将当前处理器缓存行的数据写回到系统内存。</li><li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。<br>  通常处理器和内存之间都有几级缓存来提高处理速度，处理器先将内存中的数据读取到内部缓存后再进行操作，但是对于缓存写会内存的时机则无法得知，因此在一个处理器里修改的变量值，不一定能及时写会缓存，这种变量修改对其他处理器变得“不可见”了。但是，使用Volatile修饰的变量，在写操作的时候，会强制将这个变量所在缓存行的数据写回到内存中，但即使写回到内存，其他处理器也有可能使用内部的缓存数据，从而导致变量不一致，所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期，如果过期，就会将该缓存行设置成无效状态，下次要使用就会重新从内存中读取。</li></ul></li></ul></li><li><p>cpu如何实现原子操作？</p><ol><li>处理器自动保证基本内存操作的原子性</li><li>使用总线锁保证原子性</li><li>使用缓存锁保证原子性</li></ol></li><li><p>cas的底层原理？</p><ul><li>JVM中的CAS操作正是利用了上一节中提到的处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。</li><li>CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作。<ul><li><p>ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。 从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。 </p></li><li><p>循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p></li><li><p>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j&#x3D;a，合并一下ij&#x3D;2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</p></li></ul></li></ul></li><li><p>sychronized底层原理。</p><ul><li>java文件在编译成class文件的时候，如果代码块加了sychronized，那么编译器会添加java的指令monitorenter和monitoreexit.</li><li>synchronized用的锁是存在Java对象头里的。不同的锁对应的对象头的内容可能会不同。</li><li>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率，下文会详细分析。<ul><li>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。因为在虚拟机启动的时候一般会有多个线程并行进行，所以默认是前几秒会关闭偏向锁。</li><li>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁,轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</li><li>前面的两种锁都不需要设计到内核态到用户态的切换，都是在jvm虚拟机就可以完成，但是重量级锁需要向操作系统申请，如果自选等待的线程较多的时候使用这种方式比较合适，操作系统会将这些线程加入到阻塞队列中，而不需要这写线程占用cpu资源了。</li></ul></li><li>每一个JAVA对象都会与一个监视器monitor关联，我们可以把它理解成为一把锁，当一个线程想要执行一段被synchronized圈起来的同步方法或者代码块时，该线程得先获取到synchronized修饰的对象对应的monitor。在hotSpot虚拟机中，monitor是由ObjectMonitor实现的。其源码是用c++来实现的,java对象对应的monitor也是一个临界资源，其线程安全由虚拟机自身代码来保证，开发者无需考虑。</li></ul></li><li><p>线程同步的方式</p><ul><li>sychronized</li><li>volatile</li><li>使用Reentrantlock(),有lock方法和unlock方法。</li><li>使用局部变量：如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</li><li>使用阻塞队列。BlockingQueue()</li><li>使用原子变量实现线程同步。AtomicInteger()..</li></ul></li><li><p>java锁有哪些？<br>  1. 乐观锁：乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。java 中的乐观锁基本都是通过 CAS 操作实现的， CAS 是一种更新的原子操作， 比较当前值跟传入值是否一样，一样则更新，否则失败。<br>  2. 悲观锁：悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如 RetreenLock。<br>  3. 自旋锁：自旋锁原理非常简单， 如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。<br>  4. Synchronized 同步锁：synchronized 它可以把任意一个非 NULL 的对象当作锁。 他属于独占式的悲观锁，同时属于可重入锁。<br>  5. ReentrantLock：ReentantLock 继承接口 Lock 并实现了接口中定义的方法， 他是一种可重入锁， 除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。<br>  6. Semaphore 信号量：Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。 Semaphore 可以用来构建一些对象池，资源池之类的， 比如数据库连接池<br>  7. 可重入锁（递归锁）本文里面讲的是广义上的可重入锁，而不是单指 JAVA 下的 ReentrantLock。 可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁。<br>  8. ReadWriteLock 读写锁为了提高性能， Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。 读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。<br>  9.  重量级锁（Mutex Lock）Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized 效率低的原因。因此， 这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为“重量级锁” 。 JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”<br>  10. 分段锁：分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践</p></li><li><p>synchronized 和 ReentrantLock 的区别</p><ul><li>两者的共同点：<ol><li>都是用来协调多线程对共享对象、变量的访问</li><li>都是可重入锁，同一线程可以多次获得同一个锁</li><li>都保证了可见性和互斥性</li></ol></li><li>两者的不同点：<ol><li>ReentrantLock 显示的获得、释放锁， synchronized 隐式获得释放锁</li><li>ReentrantLock 可响应中断、可轮回， synchronized 是不可以响应中断的，为处理锁的<br>  不可用性提供了更高的灵活性</li><li>ReentrantLock 是 API 级别的， synchronized 是 JVM 级别的</li><li>ReentrantLock 可以实现公平锁</li><li>ReentrantLock 通过 Condition 可以绑定多个条件</li><li>底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略， lock 是同步非阻<br>  塞，采用的是乐观并发策略</li><li>Lock 是一个接口，而 synchronized 是 Java 中的关键字， synchronized 是内置的语言<br>  实现。</li><li>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；<br>  而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，<br>  因此使用 Lock 时需要在 finally 块中释放锁。</li><li>Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，<br>  等待的线程会一直等待下去，不能够响应中断。</li><li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li><li>Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等。</li></ol></li></ul></li><li><p>ConcurrentHashMap实现原理。</p><ul><li>减小锁粒度<br>  减小锁粒度是指缩小锁定对象的范围，从而减小锁冲突的可能性，从而提高系统的并发能力。减小锁粒度是一种削弱多线程锁竞争的有效手段， 这种技术典型的应用是 ConcurrentHashMap(高性能的 HashMap)类的实现。对于 HashMap 而言，最重要的两个方法是 get 与 set 方法，如果我们对整个 HashMap 加锁，可以得到线程安全的对象，但是加锁粒度太大。 Segment 的大小也被称为 ConcurrentHashMap 的并发度。</li><li>ConcurrentHashMap 分段锁<br>  ConcurrentHashMap，它内部细分了若干个小的 HashMap，称之为段(Segment)。 默认情况下一个 ConcurrentHashMap 被进一步细分为 16 个段，既就是锁的并发度。如果需要在 ConcurrentHashMap 中添加一个新的表项，并不是将整个 HashMap 加锁，而是首先根据 hashcode 得到该表项应该存放在哪个段中，然后对该段加锁，并完成 put 操作。在多线程环境中，如果多个线程同时进行 put操作，只要被加入的表项不存放在同一个段中，则线程间可以做到真正的并行，ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。 Segment 是一种可重入锁 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色， HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组， Segment 的结构和 HashMap类似，是一种数组和链表结构， 一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素， 每个 Segment 守护一个 HashEntry 数组里的元素,当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。</li></ul></li><li><p>什么是AQS？</p><ul><li>AbstractQueuedSynchronizer 类如其名，抽象的队列式的同步器， AQS 定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock&#x2F;Semaphore&#x2F;CountDownLatch。</li><li>AQS 只是一个框架，具体资源的获取&#x2F;释放方式交由自定义同步器去实现， AQS 这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过 state 的 get&#x2F;set&#x2F;CAS)之所以没有定义成abstract ，是 因 为独 占模 式 下 只 用实现 tryAcquire-tryRelease ，而 共享 模 式 下 只用 实 现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等）， AQS 已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法</li><li>同步器的实现是 ABS 核心，以 ReentrantLock 为例， state 初始化为 0，表示未锁定状态。 A 线程lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前， A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</li></ul></li><li><p>JUC并发包的队列和原子类。</p><ul><li>&#x3D;&#x3D;ArrayBlockingQueue&#x3D;&#x3D;:由数据结构组成的有界阻塞队列。</li><li>&#x3D;&#x3D;LinkedBlockingQueue&#x3D;&#x3D;:由链表结构组成的有界（但大小默认值为<code>Integer.MAX_VALUE</code>)阻塞队列。</li><li>PriorityBlockingQueue:支持优先级排序的无界阻塞队列。</li><li>DelayQueue:使用优先级队列实现的延迟无界阻塞队列。</li><li>&#x3D;&#x3D;SychronousQueue&#x3D;&#x3D;:不存储元素的阻塞队列，也即单个元素的队列。</li><li>LinkedTransferQueue:由链表结构组成的无界阻塞队列。</li><li>LinkedBlocking<strong>Deque</strong>:由历览表结构组成的双向阻塞队列。</li></ul></li><li><p>简述线程池。</p><ul><li>线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动给这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行.</li></ul><ul><li>Executors.newFixedThreadPool(int)</li></ul><p>   <strong>执行长期的任务，性能好很多</strong></p><p>   创建一个定长线程池，可控制线程最大并发数，炒出的线程回在队列中等待。</p><p>   newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是想到等的，他使用的是LinkedBlockingQueue</p><ul><li><p>Executors.newSingleThreadExecutor()</p><p><strong>一个任务一个任务执行的场景</strong></p><p>创建一个单线程话的线程池，他只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行</p><p>newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，使用LinkedBlockingQueue</p></li><li><p>Executors.newCachedThreadPool() </p><p><strong>执行很多短期异步的小程序或负载较轻的服务器</strong></p><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲县城，若无可回收，则新建线程。</p><p>newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE,使用的SynchronousQueue,也就是说来了任务就创建线程运行，当县城空闲超过60s，就销毁线程</p></li></ul></li><li><p>线程池创建的参数?</p><ol><li>**&#x3D;&#x3D;corePoolSize&#x3D;&#x3D;**：线程池中常驻核心线程数</li></ol><ul><li>在创建了线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务</li><li>当线程池的线程数达到corePoolSize后，就会把到达的任务放到缓存队列当中</li></ul><ol start="2"><li>**&#x3D;&#x3D;maximumPoolSize&#x3D;&#x3D;**：线程池能够容纳同时执行的最大线程数，必须大于等于1</li><li>**&#x3D;&#x3D;keepAliveTime&#x3D;&#x3D;**：多余的空闲线程的存活时间</li></ol><ul><li>当前线程池数量超过corePoolSize时，档口空闲时间达到keepAliveTime值时，多余空闲线程会被销毁到只剩下corePoolSize个线程为止</li></ul><ol start="4"><li>**&#x3D;&#x3D;unit&#x3D;&#x3D;**：keepAliveTime的单位</li><li>**&#x3D;&#x3D;workQueue&#x3D;&#x3D;**：任务队列，被提交但尚未被执行的任务</li><li>**&#x3D;&#x3D;threadFactory&#x3D;&#x3D;**：表示生成线程池中工作线程的线程工厂，用于创建线程一般用默认的即可</li><li>**&#x3D;&#x3D;handler&#x3D;&#x3D;**：拒绝策略，表示当队列满了并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的runable的策略</li></ol></li><li><p>线程池的增长策略(任务调度)</p><ol><li><p>在创建了线程池之后，等待提交过来的 人物请求。</p></li><li><p>当调用execute()方法添加一个请求任务时，线程池会做出如下判断</p><p> 2.1 如果正在运行的线程数量小于corePoolSize，那么马上船舰线程运行这个任务；</p><p> 2.2 如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；</p><p> 2.3如果此时队列满了且运行的线程数小于maximumPoolSize，那么还是要创建非核心线程立刻运行此任务</p><p> 2.4如果队列满了且正在运行的线程数量大于或等于maxmumPoolSize，那么启动饱和拒绝策略来执行</p></li><li><p>当一个线程完成任务时，他会从队列中却下一个任务来执行</p></li><li><p>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程池会判断：</p></li></ol><p>  如果当前运行的线程数大于corePoolSize，那么这个线程会被停掉；所以线程池的所有任务完成后他最大会收缩到corePoolSize的大小</p></li><li><p>线程池的拒绝策略</p><ul><li><ul><li>AbortPolicy(默认)</li></ul></li></ul><p>   直接抛出RejectedExecutionException异常阻止系统正常运行</p><ul><li><p>CallerRunsPolicy</p><p>”调用者运行“一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量</p></li><li><p>DiscardOldestPolicy</p><p>抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</p></li><li><p>DiscardPolicy</p><p>直接丢弃任务，不予任何处理也不抛异常。如果允许任务丢失，这是最好的一种方案</p></li></ul></li></ul><p>​</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2020/03/06/suan-fa/dong-tai-gui-hua/"/>
      <url>/2020/03/06/suan-fa/dong-tai-gui-hua/</url>
      
        <content type="html"><![CDATA[<h3 id="动态规划解决步骤"><a href="#动态规划解决步骤" class="headerlink" title="动态规划解决步骤"></a>动态规划解决步骤</h3><pre><code>1. 首先明确dp数组所存放数据的意义。2. 根据dp数组的含义，运用数学归纳法的思想，假设dp[0...n-1]已知怎么求出dp[n]的值。3. 最后想一下base case 是什么，然后从初始化数组。保证算法的正确运行。</code></pre><h3 id="二分查找的框架"><a href="#二分查找的框架" class="headerlink" title="二分查找的框架"></a>二分查找的框架</h3><pre><code>```cppint binarySearch(int[] num,int target)&#123;    int left = 0,right = ...;    while(...)    &#123;        int mid = left+(right-left)/2;        if(nums[mid] == target)&#123;            ...        &#125;else if(nums[mid] &lt; target)&#123;            left = ...        &#125;else if(nums[mid] &gt; target)&#123;            right = ...        &#125;    &#125;    return ...;&#125;```- 基本二叉查找算法```cppint binarySearch(int[] num,int target)&#123;    int left = 0,right = num.length() -1;    while(left&lt;=right)    &#123;        int mid = left + (right -left) /2 ;        if(nums[mid]==target)&#123;            return mid;        &#125;else if(nums[mid]&lt;target)&#123;            left = mid + 1;        &#125;esle if(nums[mid] &gt; target)&#123;            right = mid -1;        &#125;    &#125;    return -1;&#125;```- 寻找左侧边界的二叉树```cppint binarySearch(int[] nums, int target)&#123;    int left = 0,right = nums.length() - 1;    while(left &lt;= right)&#123;        mid = left + (right - left) / 2;        if(nums[mid] == target)&#123;            right = mid - 1;        &#125;else if(nums[mid] &lt; target)&#123;            left = mid + 1;        &#125;else if(nums[mid] &gt; target)&#123;            right = mid -1;        &#125;    &#125;    if(left == nums.length() || nums[left] != target)return -1;    return nums[left];&#125;``` - 寻找右侧边界的二叉树```cppint binarySearch(int[] nums, int target)&#123;    int left = 0,right = nums.length() - 1;    while(left &lt;= right)&#123;        mid = left + (right - left) / 2;        if(nums[mid] == target)&#123;            left = mid + 1;        &#125;else if(nums[mid] &lt; target)&#123;            left = mid + 1;        &#125;else if(nums[mid] &gt; target)&#123;            right = mid -1;        &#125;    &#125;    if(right &lt; 0  || nums[right] != target)return -1;    return nums[right];&#125;``` int main()&#123;&#125;# </code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>array</title>
      <link href="/2020/02/20/suan-fa/array/"/>
      <url>/2020/02/20/suan-fa/array/</url>
      
        <content type="html"><![CDATA[<p>leetcode 1352</p><ul><li>关键是使用数组记录前面所有数的乘积，注意0的特殊情况，等于0的时候要讲数组清零，然后设为1。</li></ul><p>leetcode 1351</p><ul><li>寻找正数和负数的边界即可求解。</li></ul><p>leetcode 1093</p><ul><li>主要是中位数比较难求解，可以使用map来存放位置信息，然后分奇偶来进行情况讨论。</li></ul><p>leetcode 912(unsolved) </p><ul><li>使用快速排序</li><li>使用计数排序</li><li>使用堆排序</li><li>使用归并排序</li><li>使用平衡二叉树(bst)排序。</li></ul><p>leetcode 1299</p><ul><li>从后往前记录后面最大元素的值。</li></ul><p>leetcode 1267</p><ul><li>循环数组，统计总共机器的数目，然后去除和其他机器不互通的机器。</li></ul><p>leetcode 75 </p><ul><li>可以使用计数排序来做。</li><li>可以使用两个指针的方法，一个指向头，一个指向尾。</li></ul><p>leetcode 80 </p><ul><li>使用k来记录当前数组中多处的元素个数，然后根据每次循环将元素向前移动k个位置。</li></ul><p>leetcode 1184</p><ul><li>先计算总的距离，然后计算两者之间的距离，即可。</li><li>计算数组总和： accumulate(begin(),end(),0);</li></ul><p>leetcode 1</p><ul><li>使用hash表实现，第一遍将元素插入到哈希表中，第二遍遍历元素的时候直接查找是否符合条件。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组,leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题目总结</title>
      <link href="/2020/02/20/suan-fa/mian-shi-ti-mu-zong-jie/"/>
      <url>/2020/02/20/suan-fa/mian-shi-ti-mu-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h2><ol><li><p>static关键字的用法有哪些?</p><ul><li>修饰局部变量，修改了变量的生命周期，在函数第一次被调用的时候被初始化，之后会一直保存这个值，有点类似全局变量了。</li><li>修饰全局变量，修改了变量的存储区域，new出来的变量会存在堆中，局部变量存在栈中，而静态变量和全局变量存在全局存储区域中。静态全局变量在main函数之前就会分配空间，如果有初始值使用初始值初始化，否则使用系统默认值初始化。</li><li>修饰全局函数，该函数只能在该文件中被访问，可以用来区分多个命名空间中的同名函数。</li><li>修饰成员变量，所有对象共享该变量。且不需要生成对象就可以访问该变量。</li><li>修饰成员函数，不用生成对象就可以访问该函数，但是在静态成员函数内，只能访问静态变量。</li></ul><p> static关键字的作用?</p><ul><li>对作用域进行隐藏，编译多个文件的时候，没有加static的变量全局可见，加了static的对象只能当前文件可见。</li><li>保持变量的持久化，存储在静态区域的变量在程序该开始运行的时候就会完成初始化，也是唯一初始化。</li><li>默认初始化为0.</li><li>所有静态成员函数和静态成员变量都是属于类的，所有对象只有一个拷贝，所以不能将静态成员函数设置为虚函数，虚函数是用来是实现多态的，静态成员函数没有对象的概念，也就无法实现多态。</li></ul></li><li><p>继承和组合的的概念，什么时候用继承，什么时候用组合?</p><ul><li>继承是通过扩展已有类来获得新的类的方法。</li><li>组合是有已有类的对象构建新的类的方法。</li><li>继承强调’是’的关系，并且一个类要对另一个类公开所有的接口。</li><li>组合强调’有’的关系。</li><li>注意，如果没有特殊需求使用组合的方式，如果使用继承就需要将类的所有东西都继承。</li></ul></li><li><p>c++菱形布局会发生什么，画出对应的内存布局?</p><ul><li>c++菱形继承是指，有两个类b，c派生自同一个类a,同时d类继承b，c两个类。</li><li>出现问题，如果基类中有一个方法，则在d类中保存了两个该方法，如果调用就会出现指向不明确的问题。</li><li>解决方法，一个是使用域限定解决，指定所要调用的是哪个类中的函数。另一个解决方法就是使用虚继承。</li><li>内存布局。虚继承中多了一个vbptr，vbptr指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚表（virtual table），虚表第一部分存储的是对象相对于存放vptr指针的偏移量；第二项是vbptr到共有基类元素之间的偏移量。 <img src="/2020/02/20/suan-fa/mian-shi-ti-mu-zong-jie/%E8%99%9A%E7%BB%A7%E6%89%BF%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83.jpg" class="" title="虚继承内存布局"></li></ul></li><li><p>说说对智能指针的了解?</p><ul><li><p>RAII机制(背景知识)：定义一个类来完成资源的释放和分配，在构造函数中完成资源的分配和初始化操作，在析构函数中完成资源的清理工作。从而保证资源的正确初始化和释放。智能指针是一种RAII机制的应用，所以智能指针本质上可以看做是一个类。将基本类型指正封装为类对象指针，并在析构函数中编写delete语句删除指针对象所指向的空间。</p></li><li><p>c++智能指针简单介绍</p><ul><li>STL提供了四种智能指针<code>auto_ptr</code>,<code>unique_ptr</code>,<code>shared_ptr</code>,<code>weak_ptr</code>。</li><li>auto_ptr是c++98提供的解决方案，c++11已经弃用。</li><li><strong>使用注意点</strong><ul><li><p>所有智能指针都有一个explicit构造函数，以指针作为参数，所以不能自动将指针转化为智能指针，必须显示调用。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">auto_ptr</span><span class="token punctuation">{</span>    <span class="token keyword">explicit</span> <span class="token function">auto_ptr</span><span class="token punctuation">(</span>T <span class="token operator">*</span>p<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> pd<span class="token punctuation">;</span><span class="token keyword">double</span> <span class="token operator">*</span>p_reg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">double</span><span class="token punctuation">;</span>pd <span class="token operator">=</span> p_reg<span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">//not allowed(implicit conversion)        </span>pd <span class="token operator">=</span> shared_ptr<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">(</span>p_reg<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//allowed(explicite conversion)        </span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> pshared <span class="token operator">=</span> p_reg<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//not allowed(implicit conversion)        </span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> <span class="token function">pshared</span><span class="token punctuation">(</span>p_reg<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//allowed(explicite conversion)        </span></code></pre></li><li><p>对所有智能智能都应该避免在创建对象的时候不是在堆上创建对象。当ptr过期的时候程序会将delete作用在非堆的内存，会出现错误。</p><pre class=" language-cpp"><code class="language-cpp">string <span class="token function">str</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul></li></ul></li><li><p>为什么摒弃auto_ptr?</p><pre class=" language-cpp"><code class="language-cpp">auto_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">ps</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>auto_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> vocation<span class="token punctuation">;</span>vocation <span class="token operator">=</span> ps<span class="token punctuation">;</span></code></pre><ul><li>如果两个指针是常规指针，则两个指针将指向同一个string对象。所以当程序将删除同一个对象两次。解决方法如下：<ul><li>定义赋值运算符，将之执行深赋值，这样两个指针将指向不同的对象。缺点是会浪费空间，所以只能指针都没有采用这种策略。</li><li>创建所有权的概念，对特定的对象，只有一个智能指针可以拥有。这样只拥有对象的智能指针的构造函数会删除该对象，这是auto_ptr和uniqie_ptr的策略，但是unique_ptr的策略更加严格。</li><li>创建智能更高的指针，跟踪引用特定对象的智能指针数，这称之为引用计数。这也是shared_ptr采用的策略。</li></ul></li><li>为什么放弃auto_ptr，避免潜在的内存崩溃的问题，如果将一个auto_ptr赋值给另一个auto_ptr,若在使用原来的auto_ptr就会发生运行期间错误(访问了空的指针)，但是使用unique_ptr不会出现这个问题，因为无法编译通过。</li></ul></li><li><p>unique_str为什么优于auto_ptr?</p><ul><li><p>unique_ptr不运行将一个智能指针赋值给另一个智能指针，防止出现上面的编译问题。</p></li><li><p>当编译器将一个unique_ptr赋值给另一个时，若原来的unique_ptr是一个临时的右值，编译器允许这样做，但是如果unique_ptr存在过一段时间，编译器将禁止这样做。</p><pre class=" language-cpp"><code class="language-cpp">unique_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">pu1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>unique_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> pu2<span class="token punctuation">;</span>pu2 <span class="token operator">=</span> pu1<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">//not allowed</span>unique_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> pu3<span class="token punctuation">;</span>pu3 <span class="token operator">=</span> unique_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"you"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// allowed</span></code></pre></li></ul></li><li><p>如何选用智能指针?</p><ul><li>如果程序使用多个指向同一个对象的指针，应该选择shared_ptr。</li><li>如果程序不需要多个指向同一个对象的指针，可以使用unique_str。</li></ul></li></ul></li></ol><ul><li>虚函数的实现机制?<ul><li><p>什么是虚函数：<br>  虚函数是在类中有virtual关键字声明的成员函数，并且每一个含有虚函数的类都至少有一个与之对应的虚函数表，其中存放着该类所有虚函数对应的函数指针。</p><p>  &#96;&#96;&#96;cpp<br>  class A</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++,算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件io</title>
      <link href="/2020/02/20/linux/wen-jian-io/"/>
      <url>/2020/02/20/linux/wen-jian-io/</url>
      
        <content type="html"><![CDATA[<h2 id="文件io"><a href="#文件io" class="headerlink" title="文件io"></a>文件io</h2><ul><li>c标准库的函数携带一个个缓冲区，为了提高磁盘的io速度，c标准库函数底层调用的是linux的系统函数，系统函数的选项更全。</li><li>linux内核有缓冲区，也就是wirte函数会将数据存到内核缓冲区中，然后sys_write才会进行写操作。守护进程的缓输出进程负责刷新数据。</li></ul><h3 id="pcb概念"><a href="#pcb概念" class="headerlink" title="pcb概念"></a>pcb概念</h3><ul><li>pcb进程控制块，操作系统为每一个进程分配了一个pcb块。</li><li>每个应用程序都有4g的空间，0-3g是用户的区域，3-4g是内核的空间。多个应用程序可以共享内核空间。</li><li>通过file* 的句柄找到pcb块中的文件描述符，然后通过文件描述符找到磁盘中的文件。</li></ul><h3 id="open-x2F-close"><a href="#open-x2F-close" class="headerlink" title="open&#x2F;close"></a>open&#x2F;close</h3><ul><li>int open(char *filename,int flag);<ul><li>filename 是文件名</li><li>flag 对文件的描述，只读、只写、读写</li><li>返回值是文件描述符。</li></ul></li><li>int open(char *filename,int flag, mode_t mode);<ul><li>mode权限位，和umask结合而成的。0664…</li><li>只有在创建文件的时候需要改函数，否则用上面一个函数。</li></ul></li><li>int create(const char* filename,mode_t mode);</li><li>int close(int fd);<ul><li>如果成功返回0，失败返回-1.</li></ul></li><li>一个程序默认打开最大文件格式是1024个。</li></ul><h3 id="write-x2F-read"><a href="#write-x2F-read" class="headerlink" title="write&#x2F;read"></a>write&#x2F;read</h3><ul><li><p>ssize_t write(int fd,const void *buf,size_t count);</p><ul><li>count写多少字节。</li><li>buf开始写的地址。</li><li>如果成功返回写了多少字节，失败返回-1。</li></ul></li><li><p>ssize_t read(int fd,const void *buf,size_t count);</p><ul><li>成功返回读到字节数，失败返回-1，读到文件末尾返回0。</li></ul></li></ul><h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><ul><li>阻塞，如cat命令。读磁盘文件一般不会阻塞，但是从终端或者网络中读取数据可能会阻塞。阻塞进程会进入到睡眠状态。</li><li>阻塞和非阻塞是和文件绑定的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown教程</title>
      <link href="/2020/01/09/qian-duan/markdown-jiao-cheng/"/>
      <url>/2020/01/09/qian-duan/markdown-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><ul><li>使用#来表示标题</li></ul><pre class=" language-md"><code class="language-md"># H1## H2### H3#### H4##### H5###### H6</code></pre><ul><li>使用&#x3D;&#x3D;和–来表示一级和二级标题</li></ul><pre class=" language-md"><code class="language-md">H1==H2--</code></pre><h2 id="段落格式"><a href="#段落格式" class="headerlink" title="段落格式"></a>段落格式</h2><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><ul><li>可以用两个以上空格和一个回车表示换行。</li><li>也可以用一个空行来表示重新开始一个段落。</li></ul><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><pre class=" language-md"><code class="language-md">*斜体文字*_斜体文字_**加粗文字**__加粗文字__***斜体加粗***___斜体加粗___</code></pre><p><em>斜体文字</em><br><em>斜体文字</em><br><strong>加粗文字</strong><br><strong>加粗文字</strong><br><em><strong>斜体加粗</strong></em><br><em><strong>斜体加粗</strong></em></p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><ul><li>三个以上的*，-，_都可以表示分割线。</li></ul><pre class=" language-md"><code class="language-md">******************* * * * * * * * * -------------------____________________</code></pre><hr><hr><hr><hr><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><pre class=" language-md"><code class="language-md">~~delete line~~</code></pre><p><del>delete line</del></p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><ul><li>下划线可以通过<code>html</code>的<code>&lt;u&gt;</code>标签来实现:</li></ul><pre class=" language-md"><code class="language-md"><u>带下划线文本</u></code></pre><p><u>带下划线文本</u></p><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><ul><li>脚注是对文本的补充说明。</li></ul><pre class=" language-md"><code class="language-md">[^标注文本][^标注文本]: 标注文本</code></pre><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ul><li>可以使用*,-,+来做为无序列表的标记。</li><li>可以使用数字作为有序列表的标记。</li><li>列表的嵌套需要加一个tab键(4个空格)。</li></ul><pre class=" language-md"><code class="language-md">1. xxxxx    * xxxxxx    - xxxxxx    + xxxxxx2. xxxxxxx    1. xxxxxx    2. xxxxxx</code></pre><ol><li>xxxxx<ul><li>xxxxxx</li></ul><ul><li>xxxxxx</li></ul><ul><li>xxxxxx</li></ul></li><li>xxxxxxx<ol><li>xxxxxx</li><li>xxxxxx</li></ol></li></ol><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><ul><li>区块使用&gt;符号加一个空格符号表表示。</li><li>区块可以嵌套使用。</li><li>如果在列表中使用区块，前面加上4个空格。</li></ul><pre class=" language-md"><code class="language-md">> xxxxxxx> > xxxxxx> > > xxxxxxx- xxxx    > xxxxxx</code></pre><blockquote><p>xxxxxxx</p><blockquote><p>xxxxxx</p><blockquote><p>xxxxxxx</p></blockquote></blockquote></blockquote><ul><li>xxxx<blockquote><p>xxxxxx</p></blockquote></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul><li>如果是段落上的片段代码可以用<code>code</code>来包含。</li><li>代码区域使用4个空格来表示</li><li>也可以使用&#96;&#96;&#96;包裹一段代码，可以指定，也可以不指定。</li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul><li>可以使用<a href=""></a>的形式表示链接</li></ul><pre class=" language-md"><code class="language-md">[这是一个链接](http://gaobo1112.github.io)</code></pre><p><a href="http://gaobo1112.github.io/">这是一个链接</a></p><ul><li>或者也可以直接使用链接。</li></ul><pre class=" language-md"><code class="language-md"><http://gaobo1112.github.io></code></pre><p><a href="http://gaobo1112.github.io/">http://gaobo1112.github.io</a></p><ul><li>链接也可以用变量代替，然后在文章末尾添加变量即可。</li></ul><pre class=" language-md"><code class="language-md">[google][1][baidu][2][1]: www.google.com[2]: www.baidu.com</code></pre><p><a href="www.google.com">google</a><br><a href="www.baidu.com">baidu</a></p><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><ul><li>语法格式如下:</li></ul><pre class=" language-md"><code class="language-md">![alt 属性文本](图片地址)![alt 属性文本](图片地址 "可选标题")</code></pre><ul><li>也可以使用变量</li><li>但是没发设置图片属性，如果设置，使用<code>html</code>。</li></ul><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><pre class=" language-md"><code class="language-md">|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |</code></pre><ul><li>对齐方式:</li></ul><pre><code>-: 右对齐:- 左对齐:-: 居中对齐</code></pre><h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><ul><li>使用markdown可以支持html元素，可以插入数学公式，还可以画流程图等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ primer 学习笔记</title>
      <link href="/2020/01/09/c/c-primer/"/>
      <url>/2020/01/09/c/c-primer/</url>
      
        <content type="html"><![CDATA[<h1 id="第2章-变量和类型"><a href="#第2章-变量和类型" class="headerlink" title="第2章 变量和类型"></a>第2章 变量和类型</h1><h2 id="基本内置变量"><a href="#基本内置变量" class="headerlink" title="基本内置变量"></a>基本内置变量</h2><h3 id="算数类型"><a href="#算数类型" class="headerlink" title="算数类型"></a>算数类型</h3><p>表2.1 c++算术类型  </p><table><thead><tr><th>类型</th><th>含义</th><th>最小尺寸</th></tr></thead><tbody><tr><td>bool</td><td>布尔类型</td><td>未定义</td></tr><tr><td>char</td><td>字符</td><td>8位</td></tr><tr><td>wchar_t</td><td>宽字符</td><td>16</td></tr><tr><td>char16_t</td><td>Unicode字符</td><td>16位</td></tr><tr><td>char32_t</td><td>Unicode字符</td><td>32位</td></tr><tr><td>short</td><td>短整型</td><td>16位</td></tr><tr><td>int</td><td>整型</td><td>32位</td></tr><tr><td>long</td><td>长整型</td><td>32位</td></tr><tr><td>long long</td><td>长整型</td><td>64位</td></tr><tr><td>float</td><td>单精度浮点数</td><td>6位有效数字</td></tr><tr><td>double</td><td>双精度浮点数</td><td>10位有效数字</td></tr><tr><td>long double</td><td>扩展精度浮点数</td><td>10位有效数字</td></tr></tbody></table><p><strong>带符号类型和无符号类型</strong></p><p>除去比而行和扩展的字符类型之外，其他整型可以划分为带符号类型和无符号类型两种，类型int，short，long和long long 都是带符号的，通过加unsigned就可以的到无符号的类型。类型unsigned int可以缩写成unsigned。<br><br>和其他整型不同的是,字符被分为了三种：char，signed char 和unsigned char。尽管有三种但是只有两种表现形式，char的实际表现形式有编译器决定。<br><br>一般来说无符号类型所有的比特都用来存值。如8比特的unsigned char 可以表示0-255的值，而8比特的signed char表示范围是-128-127.<br></p><pre><code>**建议如何选择类型**1.当明确数值不可能位负数的时候选择无符号的类型2.使用int进行整数的运算，short常常过小，如果超过了int的类型选用long long，long和int的范围一样。3.在算数表达是中不要使用char和bool。因为char在一些机器上是有符号的而在一些事无符号的。如果需要使用一个不大的整数请明确signed char和unsigned char4.执行浮点数请用double，因为float的精度通常不够，且两者的计算效率差不多。</code></pre><p><strong>练习2.1</strong></p><pre><code>    四者都可以用来表示整型，但是表示的范围不一样，short表示范围最少，long long表示范围最大，int 和long表示范围基本一致。    无符号数所有的位都用来表示数值，而有符号数的首位可以用来表示符号。    float是单精度的浮点数，而double是双精度的浮点数。double表示的精度更好，且两者运算效率基本无差别。</code></pre><p><strong>联系2.2</strong></p><pre><code>    三者都可以用double来表示。</code></pre><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>当赋值无符号类型一个超出范围的值的时候，结果是初始值对无符号类型表示数总数取模的余数。如8bit的unsigned char 可以表示0-255的数值，如果我们赋值了一个区域之外的值，结果就是该值对256取模所得的余数<br></p><p><strong>含有无符号类型的表达式</strong><br><br>当一个算数表达是中有无符号数有有int时。这个int值会转为无符号的数。<br></p><pre><code>unsigned u = 10;int i = -42;std::cout&lt;&lt;i+i&lt;&lt;std::endl;//输出-84std::cout&lt;&lt;i+u&lt;&lt;std::endl;//如果int是32位，输出4294967264  = 2**32-32 </code></pre><p>当从无符号数中减去一个值的时候，不管这个数是不是无符号数，我们都必须确保结果不是负数。</p><pre><code>unsigned u1 = 42,u2 = 10;std::cout&lt;&lt;u2-u1&lt;&lt;std::endl;//输出取模后的结果</code></pre><p><strong>提示：切勿混用带符号类型和无符号类型</strong></p><p><strong>练习2.3</strong></p><pre><code>    32,2**32-32,32,-32,0,2**32</code></pre><p><strong>练习2.4</strong></p><pre><code>最后一个结果是0，将int转为unsigned也是变成10，所以减了之后结果是0，也无符号整数int不可能最大值是2**32-1.</code></pre><h3 id="字面值变量"><a href="#字面值变量" class="headerlink" title="字面值变量"></a>字面值变量</h3><p>一个形如42的值就是<strong>字面值变量</strong>。<br><br><strong>整型和浮点型字面值</strong><br><br>整型字面值具体的数据类型有它的值和它的符号决定，默认情况下，十进制字面值是带符号的，八进制和十六进制则都可能。尽管整型字面值可以存储在带符号的类型中，但时十进制字面值不会是负数，-42表示对42进行取负值操作。</p><pre><code>20//十进制024//八进制0x14//十六进制3.14159E0//浮点数，指数部分用E或e表示</code></pre><p><strong>字符和字符串字面值</strong><br><br>单引号是字符字面值，双引号字符串字面值，其实是由常量字符组成的数组，只是在结尾加了一个’\0’字符。</p><p><strong>转义序列</strong><br><br>有两类字符不能直接使用，一种是不可打印字符，如退格和其他控制字符，另一类是在c++中有特殊含义的字符。常见转义序列包括：\n(换行符)，\r(回车符),\t(退格符)。也可以用泛华的转义序列\x后紧跟的是1个或多个16位的数字。\后跟着1个2个或3个八进制的数字。如果\后跟着的八进制的数超过3个，只有钱3个数字是转义。\x后的所有数字都表示一个字符，但是不能超过char的8个字节。</p><p><strong>字符和字符串字面值</strong></p><table><thead><tr><th>前缀</th><th>含义</th><th>类型</th></tr></thead><tbody><tr><td>u</td><td>unicode16字符</td><td>char16_t</td></tr><tr><td>U</td><td>Unicode32字符</td><td>char32_t</td></tr><tr><td>L</td><td>宽字符</td><td>wchar_t</td></tr><tr><td>u8</td><td>utf-8(仅用于字符串子面常量)</td><td>char</td></tr></tbody></table><p><strong>整型字面值</strong></p><table><thead><tr><th>后缀</th><th>最小匹配类型</th></tr></thead><tbody><tr><td>u or U</td><td>unsigned</td></tr><tr><td>l or L</td><td>long</td></tr><tr><td>ll or LL</td><td>long long</td></tr></tbody></table><p><strong>浮点型字面值</strong></p><table><thead><tr><th>后缀</th><th>类型</th></tr></thead><tbody><tr><td>f或F</td><td>float</td></tr><tr><td>l或L</td><td>long double</td></tr><tr><td>对于一个整型字面值来说，我们可以分别指定他是否带符号，即占用多少空间。如ul就表示unsigned long，或取unsigned long long，是情况而定。</td><td></td></tr></tbody></table><p><strong>布尔字面值和指针字面值</strong><br><br>true和false是博尔类型的字面值<br>nullpt是指针字面值</p><p><strong>练习2.5</strong></p><pre><code>(a)&#39;a&#39;是char类型，L&#39;a&#39;是wchar_t类型，&quot;a&quot;是字符串类型，L&quot;a&quot;是宽字符串类型。(b)10整型，10u 无符号整型，10L signed long ，10 ul unsigned long，012八进制整型，0xc16进制整型。(c)3.14 double,3.14f float,3.14L long double(d)10 int ,10u unsigned int ,10. double,10e-2 double</code></pre><p><strong>练习2.6</strong></p><pre><code>    有区别，int month = 09定义是不合法的，因为超过的8进制的范围。day表示值是相同的。</code></pre><p><strong>练习2.7</strong></p><pre><code>65是A ，97是a所以145是e(a)who goes whit Fergus?换行(b)3.14 是long double类型的数据(c)1024.0是float类型的数据(d)3.14L 3.14是long double类型的数据</code></pre><p><strong>练习2.8</strong></p><pre><code>int main()&#123;    cout&lt;&lt;&quot;2M&quot;&lt;&lt;endl;    cout&lt;&lt;2&lt;&lt;\t&lt;&lt;&#39;M&#39;&lt;&lt;endl;&#125;</code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><p>变量和对象一般是可以互换使用的，对象是指一块能存储数据病具有某中类型的内存空间。</p><p><strong>初始值</strong><br><br>当对象在创建的时候有了一个特定的值，我们就说这个对象呗初始化了。<br>初始化不是赋值，初始化时在创建变量的时候给变量一个初始的值，而赋值是将原来变量的值抹去付给一个新的值。<br><br>在c++11中用花括号来初始化变量的到了全面的应用。这种初始化形式是<strong>列表初始化</strong>，当用于内置类型变量时，如果我们使用列表初始化也初始化值存在丢失信息的风险的时候，编译器会报错。</p><p><strong>默认初始化</strong><br><br>如果变量在定义时没有指定初值，则变量会被默认初始化。定义宇函数体内的内置类型的对象如果没有初始化，则其值就是未定义。类的对象如果没有显示初始化，其值由类确定。</p><p><strong>练习2.9</strong></p><pre><code>(a)错误，应该先定义才能输出 int input_value;cin&gt;&gt;input_value;(b)错误，列表初始化在数据信息有丢失的时候回报错。int i = &#123;3&#125;;(c)错误，不能这样连环赋值。double salary = 9999.99，wage = 9999.99;(d)正确</code></pre><p><strong>练习2.10</strong></p><pre><code>global_str是空字符串，global_int是0，local_int和local_str都是未定义。</code></pre><p>&#x3D;&#x3D;最后一个local_str不是未定义，是空字符，因为没有定义的字符会交个类去定义，string类中有默认构造函数，将该对象赋值为空字符。&#x3D;&#x3D;</p><h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><p>声明使得名字为程序所知，一个文件如果想使用别处定义的名字必须包含对那个名字的声明，而定义则负责与名字关联的实体。如果想声明一个变量而不是定义它，就在变量名添加关键字extern，而且不要显示的初始化变量。任何包含了显示初始化的声明都会变成定义。在函数内部如果初始化一个有extern标记的变量，会报错。变量只能被定义一次，但是可以被声明多次。</p><p><strong>练习2.11</strong></p><pre><code>(a)定义(b)定义(c)声明</code></pre><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>有数字、字母和下划线组成，必须以字母或者下划线开头，大小写不敏感，用户自定义的标识符不能连续出现多个下划线，也不能以下划线后加大写字母的形式出先，定义在函数体外的标识符不能以下划线开头。</p><p><strong>练习2.12</strong></p><pre><code>(a)不合法，double是关键字(b)不合法，不能以下划线开头(c)合法(d)不合法，不能以数字开头(e)合法</code></pre><p><strong>名字的作用域</strong><br>一般作用域都是{}中间的部分。如果函数有可能用到某全局变量，则不宜在定义同一个同名的局部变量。</p><p><strong>练习2.13</strong></p><pre><code>100</code></pre><p><strong>练习2.14</strong></p><pre><code>100&quot; &quot;45</code></pre><h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><p>复合类型是指基于其他类型定义的类型，引用和指针都是符合类型。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型。引用并非对象，而是对一个已经存在的对象的别名。因为引用本身不是一个对象，所以不能定义引用的引用。引用只能绑定到对象上，而不能与字面值或某个表达式的结果绑定到一起。</p><p><strong>练习2.15</strong></p><pre><code>(a)合法(b)不合法，引用不能绑定字面值(c)合法(d)引用必须初始化。</code></pre><p><strong>练习2.16</strong></p><pre><code>(a)合法，将d的值赋值为3.14159(b)合法，将d的值赋值为0(c)合法(d)合法</code></pre><p><strong>练习2.17</strong></p><pre><code>10&quot;&quot;10</code></pre><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针和引用类似，以实现的对其他对象的间接访问功能，和引用的区别在于，指针本身就是一个对象，所以可以被赋值，指针无需再定义的时候就赋初值。</p><p><strong>获取对象地址</strong><br><br>使用&amp;操作符，因为在声明语句中指针类型实际上被用于指定它所指向对象的类型。所以两者必须匹配。</p><p><strong>利用指针访问对象</strong><br><br>如果指针指向了一个对象，则可以使用*操作符来访问该对象。</p><p><strong>空指针</strong><br><br>得到空指针的直接方法就是用字面值nullptr来初始化指针。NULL是预处理变量，在编译之前由预处理器负责处理。使用为初始化指针是引发运行错误的一大原因，所以建议初始化所有的指针。</p><p><strong>赋值和指针</strong><br><br>给指针赋值就是令他存放一个新的地址，从而指向一个新的对象。赋值操作永远改变的是等号左侧的对象。</p><p><strong>其他指针操作</strong><br><br>指针可以用来进行比较，如果两个指针相同可能是：他们都是空、指向同一个对象、指向同一个对象的下一个地址。</p><p><strong>void</strong><em><br><br>以void</em>的视角来看内存空间也只是内存空间，无法访问内存空间中的对象。</p><pre><code>练习2.18int a ,b;int * pa = &amp;a;pa = &amp;b;        //修改指针的值*pa = b;        //修改指针所指的值</code></pre><pre><code>练习2.19指针指向内存中的某个对象，而引用绑定到内存中的某个对象，都是实现了对其他对象的间接访问，区别在于：1.指针本身就是一个对象，可以实现对指针的赋值和拷贝，而引用只是另外一个对象的别名，不能重新绑定另一个对象2.指针不用在定义的时候给初值，而引用必须给。</code></pre><pre><code>练习2.20将42*42的值赋给i</code></pre><pre><code>练习2.21(a)合法，但是会有隐世转换(b)不合法(c)合法</code></pre><p>&#x3D;&#x3D;第一个是非法的，不能够将int类型的数据给double类型的指针，这里也不会进行类型转换&#x3D;&#x3D;</p><pre><code>练习2.22if(p)       //如果p是一个非空指针，就执行if后面的语句if(*p)      //如果p所指对的int类型数据不为0，就执行后面的语句。</code></pre><pre><code>练习2.23c++程序应该尽量的初始化所有的指针，并竟可能的等定义了对象后再定义指向他的指针，如果不清楚指针所指何处，就将他设为nullptr，这样程序就可以知道他有没有指向一个具体的对象了。</code></pre><pre><code>练习2.24void*可以指向任意类型的对象，而long*只能指向long类型的对象。</code></pre><h3 id="2-3-3-理解复合类型的声明"><a href="#2-3-3-理解复合类型的声明" class="headerlink" title="2.3.3 理解复合类型的声明"></a>2.3.3 理解复合类型的声明</h3><ul><li>一条数据可以定义出不同类型的对象，如：int i &#x3D; 1024，*p &#x3D; &amp;i,&amp;r &#x3D; i;</li><li>一个错误的观点：类型修饰符(*或&amp;)会作用在本次定义的全部局部变量中。但是非如此，如：int * p1,p2;只有p1是指针，p2是int类型。</li><li>引用本身不是一个对象，所以不存在指向引用的指针，但是存在对指针的引用。</li><li>面对一个比较复杂的指针或者引用的声明语句的时候，从右向左阅读有助于理解他的真实含义。如：<code>int *&amp;r = p;</code>,从右向左先看到&amp;所以r是一个引用，然后看到*说明引用的是指针。</li></ul><pre><code>练习2.25(a)ip是int类型的指针，i是int类型，r是int类型的引用(b)i是int类型，ip是int类型的空指针。(c)ip是int类型的指针，ip2是int类型。</code></pre><h2 id="2-4-const限定符"><a href="#2-4-const限定符" class="headerlink" title="2.4 const限定符"></a>2.4 const限定符</h2><ul><li>因为const对象一旦创建就不能改变，所以const对象必须初始化。</li><li>如果想在多个文件之间共享const对象，必须在变量定义的前面添加extern关键字。</li></ul><pre><code>练习2.26(a)不合法，const变量在声明的时候必须从初始化。(b)合法(c)合法(d)++cnt合法，++sz不合法。const变量不能修改。</code></pre><h3 id="2-4-1-const的引用"><a href="#2-4-1-const的引用" class="headerlink" title="2.4.1 const的引用"></a>2.4.1 const的引用</h3><ul><li>const引用不能改变引用的值，也不能将非常量引用指向一个常量对象。</li><li>常量引用仅对引用可参与的操作进行了限定，引用对象本身是可以通过其他方式进行改变的。</li></ul><h3 id="2-4-2-指针和const"><a href="#2-4-2-指针和const" class="headerlink" title="2.4.2 指针和const"></a>2.4.2 指针和const</h3><ul><li>想要存放常量对象的地址，必须使用指向常量的指针。</li><li>指针的类型与其对象的类型必须一致，一个例外是允许一个指向常量的指针指向一个非常量的变量。</li><li>所谓的指向常量的指针或者引用，不过是指针或者引用自己以为指向了一个不能改变的变量，事实上是虽然不能通过该指值改变变量，但是可以通过别的指针改变变量的值。</li><li>指针是一个常量意味着指针不能指向其他的对象。且指针一个常量的话必须在定义的时候初始化。</li></ul><pre><code>练习2.27(a)不合法，r应该是一个常量引用。(b)合法(c)合法(d)合法。(e)合法(f)不合法，const类型的引用必须在定义的时候初始化(g)合法。</code></pre><pre><code>练习2.28(a) i Int类型，cp是常量指针，指向int类型，但是不合法，没有初始化。(b)pl int类型指针，p2 int类型的常量指针，不合法，p2没哟初始化。(c)ic const的int类型，r是const类型的引用，不合法，ic没有初始化(d)p3是const类型的指针，指向const的int类型，不合法，没有初始化。(e)p是一个指针，指向const的int类型，合法。</code></pre><pre><code>练习2.29(a)不合法，不能将const类型赋值给非cosnt类型。(b)不合法，不能将非常量指针指向常量指针。(c)不合法，同上(d)合法(e)合法(f)合法。</code></pre><p>&#x3D;&#x3D;(a)是合法的，常量的值可以赋值给非常量变量。但是该常量不能够改变你了，赋值是可以的，d,e,f错误相同，常量不能作为左值，也就是不能被赋值。同事不同指针不能指向常量，以为指针可以改变常量。注意该该练习的前提是已经定义了变量，所以不能对常量进行赋值，如果在定义的时候是可以将一个常量指针指向一个非常量的。&#x3D;&#x3D;</p><h3 id="2-4-3-顶层const"><a href="#2-4-3-顶层const" class="headerlink" title="2.4.3 顶层const"></a>2.4.3 顶层const</h3><ul><li>顶层cosnt可以表示任意的对象是常量，底层const则和指针和引用等复合类型有关。</li><li>底层const进行拷贝操作的时候，两个对象必须有相同的底层const资格。</li></ul><pre><code>练习2.30底层cosnt ： p2，p3，r2顶层const：p3，v2</code></pre><pre><code>(a)r1是引用，不能指向其他变量，不合法(b)不合法，p2包含底层const，p1没有(c)合法(d)不合法，p3包含底层const(e)不合法，p2可以改变，而p3是一个const对象。</code></pre><p>&#x3D;&#x3D;a和e都是合法的，因为这里是赋值操作，存在拷贝赋值的关系，所以v2是什么与r1并没有关系，只要r1可以，p2可以改变就可以。这里r1并没有指向其他变量，只是他指向的变量的值被赋值为另一值而已。&#x3D;&#x3D;</p><h3 id="2-4-4-constexpr和常量表达式"><a href="#2-4-4-constexpr和常量表达式" class="headerlink" title="2.4.4 constexpr和常量表达式"></a>2.4.4 constexpr和常量表达式</h3><ul><li>常量表达式是值不会改变且在编译过程就得到计算结果的表达式。显然字面值输入常量表达式，用字面值初始化的const对象也是常量表达式。</li><li>c++11规定，允许将变量声明为constexpr类型以便编译器验证变量的值是否是一个常量表达式。声明为一个constexpr的变量必须是一个常量，且必须用常量表达式初始化。</li></ul><pre><code>constexpr int mf = 20;          //20是常量表达式constexpr int limit = mf+ 1;    //mf+1是常量表达式cosntexpr int sz = size();      //只要当size是一个constexpr函数的时候才是一个正确的声明语句。</code></pre><ul><li>constexpr指针的初始值必须是nullptr，或者是存储于某个固定地址中的对象。函数内的对象一般无固定地址，所以一般constexpr一般用来指向函数外的变量。且限定符仅仅限定指针，对指针所指对象无限定。</li></ul><pre><code>练习2.32不合法，int null= 0，*p = nullptr;</code></pre><h2 id="类型处理"><a href="#类型处理" class="headerlink" title="类型处理"></a>类型处理</h2><h3 id="2-5-1-类型别名"><a href="#2-5-1-类型别名" class="headerlink" title="2.5.1 类型别名"></a>2.5.1 类型别名</h3><ul><li>类型别名是一个名字，他是某种类型的同义词，使用类型别名可以是复杂类型名称变得明了。</li><li>如果某个类型别名代指符合类型或常量，那声明语句可能有不一样的结果</li></ul><pre><code>typedef char * pstring ;const pstring cstr = 0;             //cstr 是指向char的常量指针，之一这里的const修饰pstring所以是常量指针const pstring * ps;                 //ps是一个指针，该指针指向char的常量指针。</code></pre><h3 id="2-5-2-auto类型说明符"><a href="#2-5-2-auto类型说明符" class="headerlink" title="2.5.2 auto类型说明符"></a>2.5.2 auto类型说明符</h3><ul><li>auto让编译器通过初始值来推算变量的类型，所以const定义的变量必须有初值。</li><li>编译推断出的auto类型有时候和初始值不一致，会适当改变结果。编译器以引用对象的类型作为auto的类型。</li><li>auto会忽略掉顶层const。同时底层const会保留。如果希望推断出的auto是一个顶层const，要明确指出<code>const auto f = c;</code></li><li>要在一条语局中定义多个变量，符号&amp;和*只属于某个声明符，而非基本类型的一部分，因此初始值必须保持一致。</li></ul><pre><code>练习2.33(a)合法(b)合法(c)合法(d)不合法，d是指针(e)不合法，e是指针(f)不合法，g是常量，不能被赋值。</code></pre><pre><code>练习2.35j是int，k是const int的引用，int * p；const int j2；int &amp;k2 = i;</code></pre><p>&#x3D;&#x3D;对常量对象取地址是一种底层const行为，所以p是 const int * p&#x3D;&#x3D;</p><h3 id="2-5-3-decltype类型指示符"><a href="#2-5-3-decltype类型指示符" class="headerlink" title="2.5.3 decltype类型指示符"></a>2.5.3 decltype类型指示符</h3><ul><li>从表达式的类型推算出要定义的变量的类型，但是不行用该表达式的值初始化变量。</li></ul><pre><code>decltype(f()) sum = x;      //sum的类型是f函数的返回值类型，但是该语句并不调用f函数。</code></pre><ul><li>decltype处理顶层const和引用的方式和auto不同，保留这两个类型。</li><li>如果表达式的内容是解引用操作，则decltype得到的是引用类型。decltype(*p)的结果是int &amp; 而不是int。</li><li>如果r是引用类型，decltype(r)的结果是引用类型，想让结果得到r所指的类型，可以吧r作为表达式的一部分如decltype(r+0).</li><li>decltype的结果类型和表达式形式密切相关。decltype的表达式如果加上了括号的变量，得到的是引用。</li></ul><pre><code>练习2.36d是int &amp;，其他都是int。a = 4，b = 4,c = 4,d = 4;</code></pre><pre><code>练习2.37int a = 4;int c = 3;int b = 4; int &amp;d = 4;</code></pre><p>&#x3D;&#x3D;decltype不实际计算表达式所以a，d都是3&#x3D;&#x3D;</p><pre><code>练习2.381.decltype不实际计算表达式的值2.decltype会保留引用和顶层const3.decltype的结果类型与表达式形式密切相关。</code></pre><h2 id="2-6-自定义数据结构"><a href="#2-6-自定义数据结构" class="headerlink" title="2.6 自定义数据结构"></a>2.6 自定义数据结构</h2><h3 id="2-6-1定义sales-data类型"><a href="#2-6-1定义sales-data类型" class="headerlink" title="2.6.1定义sales_data类型"></a>2.6.1定义sales_data类型</h3><ul><li>类最后的分号表示声明符的结束，一般来说最好不要将对象的定义和类的定义放在一起。</li><li>可以为数据成员提供一个类内初始值，创建对象的手类内初始值用于初始化数据成员，没有初始值得成员被默认初始化。</li></ul><pre><code>练习2.39 无法通过编译</code></pre><pre><code>struct Sales_dat&#123;    std::string bookNo;             //书籍编号    unsigned units_sold = 0;        //销售量    double sellingprice = 0.0;      //零售价    double saleprice = 0.0;         //实售价    double discount = 0.0          //折扣&#125;;</code></pre><h3 id="2-6-2-使用Salaes-data类"><a href="#2-6-2-使用Salaes-data类" class="headerlink" title="2.6.2 使用Salaes_data类"></a>2.6.2 使用Salaes_data类</h3><h3 id="2-6-3-编写自己的头文件"><a href="#2-6-3-编写自己的头文件" class="headerlink" title="2.6.3 编写自己的头文件"></a>2.6.3 编写自己的头文件</h3><ul><li>头文件通常包含一些职能被定义一次的实体，如类、const和constexpr变量。</li><li>头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。</li><li>头文件包含符很简单，是通过预处理器实现的。和#pragma once一样。</li></ul><h1 id="第3章-字符串、向量、和数组"><a href="#第3章-字符串、向量、和数组" class="headerlink" title="第3章 字符串、向量、和数组"></a>第3章 字符串、向量、和数组</h1><h2 id="3-1命名空间的using声明"><a href="#3-1命名空间的using声明" class="headerlink" title="3.1命名空间的using声明"></a>3.1命名空间的using声明</h2><ul><li>using namespace::name;每个名字都需要独立的using声明。</li><li>头文件不应该使用using声明，因为头文件的内容会拷贝到引用他的文件中。</li></ul><h2 id="3-2-标准库类型string"><a href="#3-2-标准库类型string" class="headerlink" title="3.2 标准库类型string"></a>3.2 标准库类型string</h2><h3 id="3-2-1-定义和初始化string对象"><a href="#3-2-1-定义和初始化string对象" class="headerlink" title="3.2.1 定义和初始化string对象"></a>3.2.1 定义和初始化string对象</h3><ul><li>使用&#x3D;初始化一个变量，实际执行的是拷贝初始化，编译器直接把等号右侧的初始值拷贝到新创建的对象中，如果不适用等号，则执行的是直接初始化。</li></ul><pre><code>string 的初始化方式string s1;              //默认初始化，s1是空字符串string s2(s1);          //直接初始化string s2 = s1;         //拷贝初始化string s3(&quot;value&quot;);     //直接初始化string s3 = &quot;value&quot;;sring s4 (n,&#39;c&#39;);       //直接初始化</code></pre><h3 id="3-2-2string对象上的操作"><a href="#3-2-2string对象上的操作" class="headerlink" title="3.2.2string对象上的操作"></a>3.2.2string对象上的操作</h3><ul><li>iostream对string进行读取操作的时候，string对象会自动忽略开头的空白，并从真正的字符开始读取，知道遇到下一处空白为止。</li><li>string对象的此类操作也是返回运算符左侧的运算对象作为结果。所以，多个输入或者输出可以连写。</li><li>getline函数的参数是一个输入流和一个string对象，函数从给定的出入流中读取内容，直到遇到换行符为止。</li><li>empty返回string对象是否为空</li><li>size函数返回string对象的长度。size函数返回的是一个string::size_type类型的值，这个类型与机器无关，是一个无符号类型的值。所以如果一条表达式已经有了size()函数，就不要使用int了，可以避免int和unsigned混用带来的问题。</li><li>string比较的时候对大小写敏感，且比较顺序是根据字典字母的顺序比较的，只有在两个string前面字符都相同的时候才会按照长度比较。</li><li>string允许将一个对象的值赋给另外一个对象。</li><li>当把string对象和字符字面值混用的时候，必须保证每一个+两侧至少有一个是string。</li><li>c++中的字符串字面值和string是不同的类型。</li></ul><pre><code>练习3.2#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123;    string line;    while(getline(cin,line))        cout&lt;&lt;line&lt;&lt;endl;    return 0;&#125;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123;    string word;    while(cin&gt;&gt;word)        cout&lt;&lt;line&lt;&lt;endl;    return 0;&#125;</code></pre><pre><code>练习3.3输入运算符会忽略开头的空白字符，并从真正的字符开始读取，直到遇到下一个空白字符为止getline函数会读取一行的数据，也就是读取数据知道遇到换行符为止。</code></pre><pre><code>练习3.4int main()&#123;    string s1,s2;    cin&gt;&gt;s1&gt;&gt;s2;    if(s1==s2)    &#123;        cout&lt;&lt;ture&lt;&lt;endl;    &#125;else&#123;        cout&lt;&lt;(s1&lt;s2)?s2:s1;    &#125;        if(s1.size()&gt;s2.size())    &#123;        cout&lt;&lt;s1&lt;&lt;endl;    &#125;    &#125;</code></pre><pre><code>练习3.5int main()&#123;    string word,line,line2;    while(cin&gt;&gt;word)        line+=word;        line2.size()==0?line+word: line2 + &quot; &quot; + word;    cout&lt;&lt;line&lt;&lt;endl;&#125;</code></pre><h3 id="处理string对象中的字符"><a href="#处理string对象中的字符" class="headerlink" title="处理string对象中的字符"></a>处理string对象中的字符</h3><ul><li>如果想改变string对象中字符的值，必须把循环变量定义为引用类型。</li><li>访问string对象中的单个字符有两种方式，一种是用下标，一种是使用迭代器。</li><li>[]接收的参数是string::size_type类型的值，返回的是该位置上字符的引用。</li><li>对于&amp;&amp;运算符，c++规定只有当左侧运算对象为真才会检查右侧运算对象的情况。</li></ul><pre><code>表3.3 ：cctype头文件中的函数isalnum(c);         //当c是字母或数字为真isalpha(c);         //当c是字母为真iscntrl(c);         //当c是控制字符为真isdigit(c);         //当c是数字为真islower(c);         //c是小写为真ispunct(c);         //c是标点符号为真isspace(c);         //c为空白为真isupper(c);         //c为大写为真isxdigit(c);        // c为16进制为真tolower(c);toupper(c);//转为大小写</code></pre><pre><code>练习3.6int main()&#123;    string temp(&quot;asdfdsf&quot;);    for(auto a:temp)    &#123;        a = &#39;X&#39;;    &#125;&#125;</code></pre><p>&#x3D;&#x3D;如果改变string的值，必须将循环的变量设为引用类型for(auto &amp;a:temp){}&#x3D;&#x3D;</p><pre><code>练习3.7设置为char不会对程序造成影响。</code></pre><pre><code>练习3.8int main()&#123;    string temp(&quot;afdasf&quot;);    int len = temp.size();    while(len--&gt;0)        temp[len] = &#39;x&#39;;&#125;int main()&#123;    string temp = &quot;fasafdasd&quot;;    for(int i = 0;i&lt;len.size();i++)        temp[len] = &#39;x&#39;;&#125;我们希望处理字符串的每一个字符，无须在意字符的处理顺序，所以与传统的while和for相比，使用范围for更好。</code></pre><pre><code>练习3.9不合法，s是空字符串，所以不能使用[]操作符。</code></pre><pre><code>练习3.10int main()&#123;    string s,result;    cin&gt;&gt;s;    for(auto temp :s)    &#123;        if(!ispunct(temp))            result+=temp;    &#125;    cout&lt;&lt;result;&#125;</code></pre><pre><code>练习3.11for语句合法，但是不能对s字符串进行修改。</code></pre><h2 id="3-3-标准库类型vector"><a href="#3-3-标准库类型vector" class="headerlink" title="3.3 标准库类型vector"></a>3.3 标准库类型vector</h2><h3 id="3-3-1-定义和初始化vector对象"><a href="#3-3-1-定义和初始化vector对象" class="headerlink" title="3.3.1 定义和初始化vector对象"></a>3.3.1 定义和初始化vector对象</h3><pre><code>初始化vector的方法vector&lt;T&gt; v1;                   //默认初始化，不含有任何的元素vector&lt;T&gt; v2(v1);vector&lt;T&gt; v2 = v1;vector&lt;T&gt; v3(n,val);vector&lt;T&gt; v5&#123;a,b,c...&#125;;vector&lt;T&gt; v5 = &#123;a,b,c..&#125;;</code></pre><ul><li>如果提供的是初始元素值的列表，只能把初始值放在花括号中进行列表初始化。</li><li>可以提供vector对象容纳的元素的数量而不用略去初始值如：vector<int> ivec(10);</li><li>vector中如果使用的是()可以说提供的值是用来构造vector对象的。如果是用花括号{},可以表述为使用初始化列表来初始化vector对象。但是如果{}提供的之不能列表初始化可以考虑构造初始化，如<code>vecotr&lt;string&gt; v&#123;10&#125;;</code>表示v有10个默认初始化的元素。</li></ul><pre><code>练习3.12正确，不正确，正确</code></pre><pre><code>练习3.13(a) 0(b) 10,0(c) 10,42(d) 1,10(e) 2,&#123;10.42&#125;(f) 10,&quot;&quot;(g)10,&quot;hi&quot;</code></pre><h3 id="3-3-2向vector对象中添加元素"><a href="#3-3-2向vector对象中添加元素" class="headerlink" title="3.3.2向vector对象中添加元素"></a>3.3.2向vector对象中添加元素</h3><ul><li>使用push_back添加元素，若循环体内包含指向vector对象那个添加元素的语句，不能使用范围for循环。</li></ul><pre><code>练习3.14int main()&#123;    vector&lt;int&gt; vi ;    cout&lt;&lt;&quot;请输入一组整数&quot;&lt;&lt;endl;    int i;    while(cin&gt;&gt;i)        vi.push_back(i);&#125;</code></pre><h3 id="3-3-3-其他vector操作"><a href="#3-3-3-其他vector操作" class="headerlink" title="3.3.3 其他vector操作"></a>3.3.3 其他vector操作</h3><pre><code>vector支持的操作v.empty();v.size();                   //返回size_type类型v.push_back(t);v[n];v1 = v2;v1 = &#123;a,b,c&#125;;v1 == v2;v1!= v2 ,&lt;,&lt;=,&gt;,&gt;=          //  以字典顺序进行比较</code></pre><ul><li>要使用size_type，需要首先指定他是哪种类型定义的。vector对象的类型总是包含元素的类型。如：vector::size_type是错误的需要指明类型。</li><li>只有vector中的类可以比较的时候vector才可以比较，比较规则和string一样，先看元素大小是否相同，如果全部相同再比较vector的大小。</li><li>vector对象的下标运算符符可以访问已存在的元素，而不能用于添加元素。</li></ul><pre><code>练习3.17int main()&#123;    vector&lt;string&gt; vString ;    string s;    while(cin&gt;&gt;s)&#123;        vString.push_back(s);    &#125;    for(auto &amp;temp : vString)    &#123;        for(auto &amp; c:temp)        &#123;            c = toupper(c);        &#125;        cout&lt;&lt;temp&lt;&lt;endl;    &#125;&#125;</code></pre><pre><code>练习3.18不合法vector&lt;int&gt; ivec;ivec.push_back(42);</code></pre><pre><code>练习3.19vector&lt;int&gt; a(10,42);vector&lt;int&gt; a&#123;42,42,42,42,42,42,42,42,42,42&#125;vector&lt;int&gt; a;for(int i = 0;i&lt;10;i++)a.push_back(42);</code></pre><pre><code>练习3.20int main()&#123;    int i;    vector&lt;int&gt; vi;    while(cin&gt;&gt;i)        vi.push_back(i);    for(int i = 0;i&lt;vector.size()-1;i++)    &#123;        cout&lt;&lt;vi[i]+vi[i+1]&lt;&lt;endl;    &#125;        int len = vector.size();    for(int i = 0;i&lt;=len-i-1;i++)    &#123;        cout&lt;&lt;vi[i]+vi[len-i-1]&lt;&lt;endl;    &#125;&#125;</code></pre><h2 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h2><h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><ul><li>begin成员负责返回指向第一个元素的迭代器，end成员负责返回容器尾元素的下一位置。</li><li>如果容器为空，begin和end返回的是同一个迭代器，都是尾后迭代器。</li></ul><pre><code>标准容器迭代器的运算符*iter 返回得带器iter所指元素的引用iter-&gt;mem  解引用iter并获取该元素的名为mem的成员。++iter  令iter指示容器下一个元素。--iteriter1 == iter2 判断迭代器是否相同，指向同一个元素或者是同一容器的尾后迭代器。</code></pre><ul><li>应该养成使用！&#x3D;的习惯，因为所有的标准库容器的迭代器都定义了&#x3D;&#x3D;和!&#x3D;</li><li>就像不知道string的size_type的类型一样，我们也不知道迭代器的类型，一般使用iterator和const_iterator</li><li>cbegin和cend返回的一定是const类型的迭代器。</li><li>但凡是使用了迭代器的循环体，都不要想迭代器所属的容器添加元素。</li></ul><pre class=" language-cpp"><code class="language-cpp">练习<span class="token number">3.22</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>text<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token operator">!</span>it<span class="token operator">-</span><span class="token operator">></span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>it<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>it<span class="token operator">==</span>text<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>temp<span class="token operator">:</span><span class="token operator">*</span>it<span class="token punctuation">)</span>            <span class="token function">toupper</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>it<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-cpp"><code class="language-cpp">练习<span class="token number">3.23</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">vi</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> vi<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>vi<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>it<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token operator">*</span>it <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>it<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="3-4-2迭代器运算"><a href="#3-4-2迭代器运算" class="headerlink" title="3.4.2迭代器运算"></a>3.4.2迭代器运算</h3><ul><li><code>auto mid = vi.begin()+vi.size()/2</code>如果vi有20个元素，mi等于vi.begin()+10</li><li>迭代器的&lt;可以用来比较所指的想的位置前后。</li><li>difference_type表示两个迭代器之间的距离，可正可负。</li></ul><pre><code>练习3.25vector&lt;unsigned&gt; scores(11,0);unsigned grad;while(cin&gt;&gt;grade)&#123;    if(grade&lt;=100)        *(scores.begin()+grade/10)++;&#125;</code></pre><pre><code>练习3.26beg+end可能超过整数的边界。</code></pre><p>&#x3D;&#x3D;迭代器没有定义加法的操作，&#x3D;&#x3D;</p><h2 id="3-5-数组"><a href="#3-5-数组" class="headerlink" title="3.5 数组"></a>3.5 数组</h2><ul><li>如果不清楚元素的确切个数，使用vector较好</li></ul><h3 id="3-5-1-定义和初始化内置数组"><a href="#3-5-1-定义和初始化内置数组" class="headerlink" title="3.5.1 定义和初始化内置数组"></a>3.5.1 定义和初始化内置数组</h3><ul><li>如果维度比提供的默认值数量大，则用提供的初始值初始化靠前的元素。剩余的初始化为默认值。</li><li>字符数组可以用字符字面值初始化，使用这种方式的时候，结尾会自动添加一个空字符。而使用列表初始化不会添加空字符。</li><li>不能将数组的内容拷贝给其他的数组作为其初始值，也不能用数组为其他数组赋值。</li><li>理解数组声明的含义，最好的办法是从数组的名字开始按照从内向外的顺序阅读。</li></ul><pre><code>练习3.27(a) buf_size只是一个普通的变量不是常量，不能作为数组的维度。(b)合法(c)非法，txt_size()不是一个constexpr不能作为数组的维度。(d)非法，数组的维度过小，应该是12。</code></pre><pre><code>练习3.28除了ia2其他的都被默认初始化了</code></pre><p>&#x3D;&#x3D;对于string类型的数组来说，因为string类本身接受无参数的初始化方式，所以不论数组定义在函数内还是函数外都被默认初始化为空串。&#x3D;&#x3D;</p><pre><code>练习3.29数组的大小固定，不能随便向数组中添加额外的元素。如果我们需要一个更大的数组，只能重新申请空间。</code></pre><h3 id="3-5-2访问数组元素"><a href="#3-5-2访问数组元素" class="headerlink" title="3.5.2访问数组元素"></a>3.5.2访问数组元素</h3><ul><li>数组的元素也可以使用范围for语句和下标运算符来访问。</li><li>使用数组下标的时候，通常将其定义为size_t类型，size_t是一种与机器相关的无符号类型。在cstddef头文件中定义了该类型，该文件是c标准库stddef.h头文件的c++语言版本。</li></ul><pre><code>练习3.30ix不能为10，所以程序改为for(size_t = 0;ix&lt;arrray_size;++ix)比较好。</code></pre><pre><code>练习3.31int main()&#123;    int a[10] ;    for(int i = 0;i&lt;10;i++)    &#123;        a[i] = i;    &#125;&#125;</code></pre><pre><code>练习3.32int main()&#123;    const int sz = 10;    vector&lt;int&gt; vInt ,vInt2;    for (int i = 0;i&lt;sz;i++)    &#123;        vInt.push_back(i);        vInt2.push_back(vInt[i]);    &#125;    for(auto vla:vInt2)    &#123;        cout&lt;&lt;val&lt;&lt;&quot;&quot;;    &#125;    cout&lt;&lt;endl;    return 0;    &#125;</code></pre><pre><code>练习3.33如果不初始化scores，该数组会含有未定义的数值，因为scores是定义在函数内部的整数数组。所以不会执行默认初始化。</code></pre><h3 id="3-5-3-指针和数组"><a href="#3-5-3-指针和数组" class="headerlink" title="3.5.3 指针和数组"></a>3.5.3 指针和数组</h3><ul><li>对数组的元素取地址可以得到指向该元素的指针。</li><li>在很多用到数组名字的地方，编译器会自动将替换为一个指向数组首元素的指针。</li><li>如果ia是一个10个整数组成的数组，当使用ia作为初始值的时候编译器会进行转化，而使用decltype关键字时不会发生上述的转化。</li></ul><pre><code>int ia[] = &#123;1,2,3,4,5,6,7,8,9&#125;;auto ia2(ia);                   //ia2是一个整型的指针，指向ia的第一个元素。decltype(ia) ia3 = &#123;0,1,2,3,4,5,6,7,8&#125;;         //ia3是一个含有10个整数的数组。</code></pre><ul><li>使用指针遍历数组的元素，需要得到尾元素的下一个位置，可以使用<code>int * e = &amp;arr[10];</code>的到，虽然索引是一个不存在的元素，但是可以的到所需要的地址</li><li>另一种方法是c++11提供的，使用begin和end，但是数组不是类型，所以这两个不是成员函数。使用方法是将数组作为他们的参数。这两个函数定义在iterator头文件中。</li></ul><pre><code>int ia[10];int *beg = begin(ia);int *end = end(ia);</code></pre><ul><li>两个指针相减的结果是ptrdiff_t的标准类型，和size_t定义的位置一样。</li><li>如果两个指针分别指向不相关的对象，不能对他们进行比较。</li><li>内置的下标运算符所用的索引值不是无符号类型，这一点和vector和string不同。</li></ul><pre><code>练习3.34另p1指向p2所指的元素。只有在p1和p2的类型不同的时候改程序才是非法的。</code></pre><pre><code>练习3.35int main()&#123;    int a[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;    for(auto p = begin(a);p!=end(a);++p)    &#123;        *p = 0;    &#125;&#125;</code></pre><h3 id="3-5-4-c风格的字符串"><a href="#3-5-4-c风格的字符串" class="headerlink" title="3.5.4 c风格的字符串"></a>3.5.4 c风格的字符串</h3><ul><li>c风格的字符串不是一种类型，是为了表达和使用字符串而形成的一种约定俗称的写法。</li><li>c语言的标准库string函数，可以用来操作c风格字符串，定义在cstring头文件中，是string.h的c++版本</li></ul><pre><code>c风格的字符串函数strlen(p);              //返回p的长度，不包含空字符串strcmp(p1,p2);          //比较p1和p2的相等性，若相同返回0，如果p1&gt;p2返回正。strcat(p1,p2);          //将p2附加到p1上，返回p1strcpy(p1,p2);          //将p2拷贝给p1，返回p1</code></pre><pre><code>char a[] = &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;;cout&lt;&lt;strlen(a)&lt;&lt;endl;              //错误，a没有以空字符结束</code></pre><pre><code>const char cal[] = &quot;a string example&quot;;const char cal2[] = &quot;a different string&quot;if(cal&lt;cal2)                    //未定义的：试图比较两个无关的的地址。</code></pre><ul><li>如果比较c风格字符串，使用strcmp函数，此时比较的就不是指针了而是字符串。</li><li>连接或拷贝c风格字符串使用strcat函数和strcpy函数，不过想要使用这两个函数，需要提供一个用于存放字符串结果的数组，该数组必须足够大，可以存放字符串和结尾的空字符，否则会发生错误。</li></ul><pre><code>练习3.37还程序的含义是输出cp地址之后的结果，知道遇到了空字符。但是因为ca定义的时候没有定义空字符，所以可能会带来一定的问题，所以修改为const char ca [] = &#123;&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;\0&#39;&#125;;const char ca[] = &quot;hello&quot;;</code></pre><pre><code>练习3.38指针存放的是对象的地址，将对象的地址相加是没有意义的。但是对象的指针相减是有意义的，在一个数组表示的意义是元素在数组中的距离。</code></pre><pre><code>练习3.39bool isEqual(const String &amp;s1,const String &amp;s2)&#123;    return s1==s2;&#125;bool isEqual(const char* &amp;s1,const char* &amp; s2)&#123;    return strcmp(s1,s2);&#125;</code></pre><pre><code>练习3.40int main()&#123;    char a[] = &quot;hello&quot;;    char b[] = &quot;world&quot;;    char c[20] = strcat(a,b);    &#125;</code></pre><p>&#x3D;&#x3D;strcat返回的结果是a的值，所以这样做后就改变了a，更好的做法是想用strcpy(c,a)再用strcat(c,b)&#x3D;&#x3D;</p><h3 id="3-5-5-与旧代码的接口"><a href="#3-5-5-与旧代码的接口" class="headerlink" title="3.5.5 与旧代码的接口"></a>3.5.5 与旧代码的接口</h3><ul><li>允许使用空字符串结尾的字符数组来初始化string对象或为string对象赋值</li><li>若想将string赋值给c字符串数组，使用c_str函数，该函数返回一个c风格的字符串。其实返回的是const char* ，如果后续的操作改变了string，那么之前返回的数组失去作用。</li><li>如果指向完c_str()返回后程序向一直使用返回的数组，最好是将该数组重新拷贝一份。</li><li>可以使用数组来初始化vector对象，只要指定拷贝区域的首元素地址和尾后地址即可。<pre><code>int int_arr[] = (0,1,2,3,4,5);vector&lt;int&gt; ivec(begin(int_arr),end(int_arr));</code></pre></li></ul><pre><code>练习3.41int main()&#123;    int a[] = (1,2,3,4,5);    vector&lt;int&gt; ivec(begin(a),end(a));&#125;</code></pre><pre><code>练习3.42void vec_int(const vector&lt;int&gt; vec,int* &amp;a)&#123;    auto it = vec.cbegin();    for(auto &amp;val:a)    &#123;        val = *it;        it++;    &#125;&#125;</code></pre><h2 id="3-6-多维数组"><a href="#3-6-多维数组" class="headerlink" title="3.6 多维数组"></a>3.6 多维数组</h2><ul><li>严格来说c++没有多维数组，通常所说的多维数组就是数组的数组。</li><li>按照从内到外的阅读顺序有助于理解，<code>int ia[3][4]</code>ia是一个含有三个元素的数组，而每个元素有是含有4个元素的数组。</li><li>对于二维数组，把第一维度称为行，第二维度称为列。</li><li>多维数组的初始化，每一行用花括号括起来，如果想初始化每一行第一个元素，其他的值会默认初始化。<pre><code>int ix[3][4] = &#123;&#123;0&#125;,&#123;4&#125;,&#123;8&#125;&#125;;           //显示初始化每一行的首元素int ix[3][4] = &#123;0,1,2&#125;;                 //显示的初始化第一行，其他元素执行默认初始化。</code></pre></li><li>如果想要改变数组的元素，选用引用类型作为循环控制变量，但在为了防止数组被自动转为指针，也需要将外层循环的控制变量声明为引用类型。<pre><code>for(const auto &amp;row:ia)             //这里必须用引用，否则row会被当成指针，而无法通过编译。    for(auto col:row)        cout&lt;&lt;col&lt;&lt;endl;</code></pre></li><li>使用范围for语句处理多维数组，除了最内层的循环外，其他的循环控制变量都应该是引用类型。</li><li>当程序使用多维数组的名字的时候，也会自动将其转化成指向数组首元素的指针。</li><li>使用auto和decltype可以避免在数组前添加一个指针类型了<pre><code>for(auto p = ia;p!=ia+3;++p)            //  p指向含有4个整数的数组 int(*p)[4] = ia;    for(auto q = *p;q!=*p+4;++q)        cout&lt;&lt;*q&lt;&lt;endl;</code></pre></li><li>读写和理解指向多维数组的指针很麻烦，使用类型别名可以使工作更加简单。<pre><code>typedef int int_array[4];for(int_array *p = ia;p!=ia+3;++p)&#123;    for(int *q = *p)&#125;</code></pre><ul><li>程序将类型4个整数数组命名为int_array,用类型名定义更加明了简介</li></ul></li></ul><pre><code>练习3.43int ia[3][4];for(int (&amp;p)[4]:ia)    for(int &amp;q:p)        cout&lt;&lt;q&lt;&lt;endl;        for(int i = 0;i！=3;i++)&#123;    for(int j = 0;j!=4;j++)    &#123;        cout&lt;&lt;ia[i][j];    &#125;&#125;for(int (*p)[4] = ia;p!=ia+3;p++)&#123;    for(int *q = *p;q!=*p+4;q++)    &#123;        cout&lt;&lt;*q&lt;&lt;endl;    &#125;&#125;</code></pre><pre><code>练习3.44typedef int int_array[4];for(int_array &amp;p:ia)    for(int &amp;q:p)        cout&lt;&lt;q;</code></pre><pre><code>练习3.45for(auto &amp;p:ia)    for(auto &amp;q:p)        cout&lt;&lt;qfor(auto i = 0;i!=3;i++)    for(auto j = 0;j!=4;j++)        cout&lt;&lt;ia[i][j];for(auto p = ia;p!=ia+3;p++)    for(auto q = *p;q!=*p+4;q++)     cout&lt;&lt;*q&lt;&lt;endl;</code></pre><h1 id="第4章-表达式"><a href="#第4章-表达式" class="headerlink" title="第4章 表达式"></a>第4章 表达式</h1><h2 id="4-1-1-基本概念"><a href="#4-1-1-基本概念" class="headerlink" title="4.1.1 基本概念"></a>4.1.1 基本概念</h2><ul><li>c++定义了一元运算符和二元运算符，函数调用也是一种特殊的运算符，他的运算对象数量没有限制。</li><li>一个c++表达式要不是左值，要不是右值，一个左值表达式的求值结果是一个对象或者一个函数。</li><li>当一个对象被用作右值的时候用的是对象的值(内容)，当对象被用作左值的时候，用的是对象的身份(在内存中的位置)</li><li>需要右值的地方可以用左值代替，但是不能把右值当成左值使用。</li><li>使用关键字decltype的时候，左值和右值也有所不同，如果表达式的求值结果是左值，会得到一个引用类型。<pre><code>int * p;decltype(*p);           //因为*p是左值所以结果还是int &amp;decltype(&amp;p);           //因为取地址符生成右值，所以结果是int **也就是一个指向整型指针的指针。</code></pre></li></ul><h3 id="4-1-2-优先级和结合律"><a href="#4-1-2-优先级和结合律" class="headerlink" title="4.1.2 优先级和结合律"></a>4.1.2 优先级和结合律</h3><pre><code>练习4.125</code></pre><pre><code>练习4.2(a) (*vec).begin()(b) (*vec).begin() + 1;</code></pre><p>&#x3D;&#x3D;优先级最好的是成员选择符合函数调用符，其次才是解引用操作，所以是*(vec.begin())&#x3D;&#x3D;</p><h3 id="4-1-3-求值顺序"><a href="#4-1-3-求值顺序" class="headerlink" title="4.1.3 求值顺序"></a>4.1.3 求值顺序</h3><ul><li><code>int i = f1()*f2();</code>虽然知道f1和f2一定会在执行乘法之前被调用，但是无法知道到底是f1先还是f2先。</li><li>有4种运算符规定了运算对象的求值顺序(&amp;&amp; || ?: ,).</li><li>那不准执行顺序最好使用括号强制让表达式的组合关系符合程序逻辑的要求。</li><li>如果改变了某个对象的值，在表达式的其他地方不要再使用这个运算对象。</li></ul><h2 id="4-2-算术运算符"><a href="#4-2-算术运算符" class="headerlink" title="4.2 算术运算符"></a>4.2 算术运算符</h2><pre><code>+           一元正号   -           一元负号-----------------------*           乘法/           除法%           求余-----------------------+           加法-           减法</code></pre><ul><li>当一元正好运算符作用域一个指针或者算术值得时候，返回运算对象值得一个副本。</li><li>布尔值不参与一元运算符-的运算。</li><li>%运算必须都是整数。</li><li>取余操作的正负看m%n中的m，而除法操作是看m，n的符号是否相同 。</li></ul><pre><code>练习4.491</code></pre><pre><code>练习4.5 (a)-86(b)-18(c) 0(d) -2</code></pre><pre><code>练习4.6(m%2)==0</code></pre><pre><code>练习4.7溢出是一种常见的算术运算错误，因为在计算机中存储某个类型的内存空间有限，所以该类型的表示范围有限，当计算的结果超过这个范围之后，就会产生未定义的数值，这种错误称为溢出。</code></pre><h2 id="4-3-逻辑和关系运算符"><a href="#4-3-逻辑和关系运算符" class="headerlink" title="4.3 逻辑和关系运算符"></a>4.3 逻辑和关系运算符</h2><pre><code>!           非-----------------------------&lt;           小于&lt;=          小于等于&gt;           大于&gt;=          大于等于----------------------------==          相等 !=          不相等-----------------------------&amp;&amp;          逻辑与||          逻辑或只有！是从右想左赋值其他都是从左向右赋值</code></pre><ul><li>逻辑与和逻辑或都有短路策略，也就是会先求左侧的表达式，若有结果了就不会求右侧的表达式。</li><li>进行比较运算是除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象<pre><code>if(val==true)//等价于 if(val==1)</code></pre></li></ul><pre><code>练习4.8逻辑与和逻辑或都是先求左侧运算对象在求右侧对象的值。相等性运算符的两个对象都需要求值，但是没有规定求值顺序。</code></pre><pre><code>练习4.9先判断cp是不是空指针，然后判断cp所指的字符串是否为空。</code></pre><pre><code>练习4.10int a;while(cin&gt;&gt;a==42)&#123;&#125;</code></pre><pre><code>练习4.11if(a&gt;b&amp;&amp;b&gt;c&amp;&amp;c&gt;d)</code></pre><pre><code>练习4.12i!=(j&lt;k)，意思是先比较j和k的大小，得到一个布尔值，然后判断i的值是否与之相等。</code></pre><h2 id="4-4-赋值运算符"><a href="#4-4-赋值运算符" class="headerlink" title="4.4 赋值运算符"></a>4.4 赋值运算符</h2><ul><li>赋值运算符的左侧对象必须是一个可以修改的左值。</li><li>赋值运算符满足右结合律，对于多重赋值语句中的每一个对象，他的类型或者与右边对象的类型相同、或者可以有右边的类型转换得到。</li><li>赋值语句通常会出现在条件中，因为赋值运算符的优先级相对较低，所以通常需要给赋值部分加上括号。</li></ul><pre><code>练习4.13(a)i = 3 ,d = 3.0(b)d = 3.5 ,i =3</code></pre><pre><code>练习4.14错误不能把42作为左值。判断i=42的赋值操作是否执行成功</code></pre><pre><code>练习4.15daval = ival = 0;pi = nullptr;</code></pre><pre><code>练习4.16if((p=getPtr()!=0)if(i==1024)</code></pre><h2 id="4-5-递增和递减运算符"><a href="#4-5-递增和递减运算符" class="headerlink" title="4.5  递增和递减运算符"></a>4.5  递增和递减运算符</h2><ul><li>除非必须，否则不要是用递增递减的后置版本，因为后置版本需要将原始数据存储下来以便返回这个为修改的内容</li><li>*pbeg++的含义是输出当前值并将pbeg向前移动一个元素。*pbeg++等价于*(pbeg++)pbeg++先把pbeg的值加1，然后返回pbeg的初始值得副本作为其求值的结果。</li><li>如果一条子表达式改变了某个对象的值，另一条子表达式又用到该指的话，运算对象的顺序就比较关键了。可能会产生未定义的行为。</li></ul><pre><code>练习4.17前置操作符是先进行加一然后才赋值，而后置运算符将对象加一但是求值的结果是未改变之前的那个副本。</code></pre><pre><code>练习4.18会产生错误，无法输出程序第一个元素的值，还有会尝试输出最后一个元素后面位置的值，但是并不存在。</code></pre><pre><code>练习4.19(a)先判断ptr是否是空指针，如果不是空指针，将指针+1，并判断之前指针所指的对象是否为0(b)先将ival+1，然后判断ival是否为0，若不为0，判断ival+1是否为0(c)不正确，会带来未定义的行为。</code></pre><h2 id="4-6-成员访问符号"><a href="#4-6-成员访问符号" class="headerlink" title="4.6 成员访问符号"></a>4.6 成员访问符号</h2><ul><li>点运算符获取类对象的一个成员，箭头运算符和点有关。ptr-&gt;mem等价于(*ptr).men;</li><li>因为解引用的运算符优先级低于点运算符，所以执行解引用运算符的子表达式两端必须加上括号。</li></ul><pre><code>练习4.20(a) 合法，将iter的值取出，将指针后移(b) 不合法，无法对string++(c) 不合法iter没有empty的方法(d) 合法(e) 不合法(f) 合法，判断iter下一个元素是否为空</code></pre><h2 id="4-7-条件运算符"><a href="#4-7-条件运算符" class="headerlink" title="4.7 条件运算符"></a>4.7 条件运算符</h2><ul><li>条件运算符满足右结合律，当条件运算符的两个表达式都是左值或者可以转换为同一左值类型的时候。</li><li>条件运算符的优先级很低，所以一般加括号。</li></ul><pre><code>练习4.21vector&lt;int&gt; vInt;for(auto &amp;temp:vInt)    temp = temp%2!=0 ? temp*2:temp;</code></pre><pre><code>练习4.23string p1 = s+(s[s.size()-1]==&#39;s&#39;?&quot;&quot;:&quot;s&quot;);</code></pre><h2 id="4-8-位运算符"><a href="#4-8-位运算符" class="headerlink" title="4.8 位运算符"></a>4.8 位运算符</h2><pre><code>位运算符(左结合律)~               位取反 &lt;&lt;              左移    &gt;&gt;              右移&amp;               位与^               位异或|               位或</code></pre><ul><li>位运算符如何处理么有明确规定，所以建议仅将位运算符用于处理无符号类型。</li><li>左移操作符在右侧插入值为0的二进制数，右移操作符行为依赖于左移对象的类型，如果是无符号数插入0，如果是有符号数，左侧插入符号位的副本或位0的二进制数，如何选择是环境而定。</li><li>在为运算符中，char类型的运算对象会被先提升为iint类型。</li><li>对于&amp;，都是1才是1，对于|都是0才为0，对于^相等为0，不同为1.</li><li>移位运算符满足做结合律。</li><li>c++规定整数按照他的补码新式存储。</li></ul><pre><code>练习4.2500000000 000000000 000100011 10000000</code></pre><p>&#x3D;&#x3D;11111111 11111111 11100011 10000000&#x3D;&#x3D;</p><pre><code>练习4.27(a) 3 (b) 7(c) 1(d) 1</code></pre><h2 id="4-9-sizeof运算符"><a href="#4-9-sizeof运算符" class="headerlink" title="4.9 sizeof运算符"></a>4.9 sizeof运算符</h2><ul><li>sizeof返回一条表达式或者一个类型名字所占的字节数。满足右结合律，得到的值是size_t类型。<pre><code>sizeof(type)sizeof expr;            //返回表达式结果类型的大小，不实际计算运算对象的值Sales_data data,*p;sizeof(Sales_data_);            //sales_data类型的对象所占空间大小sizeof data;                   //data的类型大小，也即是sizeof(Sales_data)sizeof p;                       //指针所占空间大小sizeof *p;                      //p所指空间的大小，指针不需要有效，因为有结合，相当于sizeof(*p)</code></pre></li><li>对char或类型为char的表达式执行sizeof，为1</li><li>对引用类型执行得到引用对象所占大小</li><li>对指针得到指针大小</li><li>对解引用指针得到指针所指向对象的大小，指针不需要有效。</li><li>对数组，得到整个数组的大小</li><li>对string和vector得到类型固定部分大小。</li></ul><pre><code>练习4.29101</code></pre><pre><code>练习4.30(a) sizeof(x+y)(b) sizeof(p-&gt;mem[i])(c) sizeof a &lt; b(d) sizeof f()</code></pre><h2 id="4-10-逗号运算符"><a href="#4-10-逗号运算符" class="headerlink" title="4.10 逗号运算符"></a>4.10 逗号运算符</h2><ul><li>按照从左向右的顺序，逗号运算符的结果是右侧表达式的值。</li></ul><pre><code>练习4.33如果somevalue==0，那么x+1，y+1，且该表达式的值为y+1</code></pre><p>&#x3D;&#x3D;条件运算符等级高于逗号运算符，所以相当于(someValue ? ++x,++y:–x),–y&#x3D;&#x3D;</p><h2 id="4-11-类型转换"><a href="#4-11-类型转换" class="headerlink" title="4.11 类型转换"></a>4.11 类型转换</h2><ul><li><code>int ival = 3.42+3;</code>该表达式先将3转为3.0然后计算为6.42，最后再将double转为int。</li><li>大多数表达式，比int类型小的整型值首先转化为较大的int类型</li><li>条件中，非布尔值转为布尔值。</li><li>初始化中，初始值转为变量的类型，赋值中，右侧对象转为左侧运算对象的类型</li><li>如果算术运算或关系运算有多种类型，需要转为同一中类型。</li><li>函数调用发生类型转化。</li></ul><h3 id="4-11-1-算术转化"><a href="#4-11-1-算术转化" class="headerlink" title="4.11.1 算术转化"></a>4.11.1 算术转化</h3><ul><li>整型提升将小整数类型转化为大的整数类型。</li><li>如果一个是无符号类型，一个是带符号类型，其中无符号类型不小于带符号类型，则转为无符号类型。</li><li>如果无符号类型小于带符号类型，依据机器，如果无符号类型能存储到带符号类型中，转为带符号类型，如果不能转为带符号类型。带符号类型转为无符号类型是取模后的余数。<code>unsigned int c = -1;</code> c&#x3D;255 (-1mod256)</li></ul><pre><code>练习4.34(a) 浮点数转为int类型，int转为bool类型(b) ival转为fval然后相加的结果转为dval(c) cval转为ival然后结果转为dval(d) </code></pre><pre><code>练习4.35(a)&#39;a&#39;提升为int，然后相加的结果转为char(b)ival转为double，ui转为double类型。最后结果转为float类型。(c) ui转为float类型。最后结果转为double类型(d)ival转为float类型，然后结果转为double类型，最后转为char类型</code></pre><h3 id="4-11-2-其他隐式类型转换"><a href="#4-11-2-其他隐式类型转换" class="headerlink" title="4.11.2 其他隐式类型转换"></a>4.11.2 其他隐式类型转换</h3><ul><li>数组转换为指针，大多数用到数组的表达式中，数组自动转换为指向数组首元素的指针。</li><li>指针的转化：nullptr可以转化为任意类型的指针。指向任意非常量的指针都能转为void*，指向任意对象的指针都能转外const void *.</li><li>存在一种从算术类型或指针类型想布尔类型自动转化的机制。</li><li>允许将指向非常量类型的指针转换为指向对应的常量类型的指针。</li><li>类类型定义的转换：类类型能定义有编译器自动执行的转换，不过编译器只能执行一次类类型的转换。<pre><code>string s,t = &quot;a value&quot;;             //字符串字面值转为string类型while(cin&gt;&gt;s)                       //cin转换为布尔值，有istream定义的转换规则。</code></pre></li></ul><h3 id="4-11-3-显示转换"><a href="#4-11-3-显示转换" class="headerlink" title="4.11.3 显示转换"></a>4.11.3 显示转换</h3><ul><li>一个命名的强制类型转化具有以下形式。<code>cast-name&lt;type&gt;(express)</code></li><li>static_cast,任何具有明确意义的类型转换，只要不包含底层cosnt，都可以使用static_cast</li><li>当需要将一个较大的算术 类型赋值给较小的类型的时候，staticconst比较用用，他告诉程序的读者和编译器，我们并不在乎潜在的精度损失。</li><li>我们把指针存放在void*中，并且使用static_cast将其强制转换为原来的类型。</li><li>const_static只能改变运算对象的底层const，const_cast只能用来改变常量属性</li><li>reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。本质上依赖机器。</li><li>dynamic_cast支持运行时类型识别。</li></ul><pre><code>练习4.36i *= static_cast&lt;int&gt;( d);</code></pre><pre><code>练习4.37(a) pv = static_cast&lt;void *&gt;ps;(b) i = static_cast&lt;int&gt;(*pc)(c) pv = static_cast&lt;void*&gt;(&amp;d);(d) pc =static_cast&lt;char*&gt;(pv);</code></pre><pre><code>练习4.38将j/i的值转为double然后赋值给slope</code></pre><h1 id="第5章-语句"><a href="#第5章-语句" class="headerlink" title="第5章 语句"></a>第5章 语句</h1><h2 id="5-1简单语句"><a href="#5-1简单语句" class="headerlink" title="5.1简单语句"></a>5.1简单语句</h2><ul><li>空语句只有一个分号。空语句应该加上注释，从而使得读者段代码的人知道该语句是有意省略的。</li></ul><pre><code>练习5.1空语句就是只有一个分号的语句，在while循环可能会用到空语句。</code></pre><pre><code>练习5.2快是由&#123;&#125;组成的以快区域。</code></pre><h2 id="5-2-语句作用域"><a href="#5-2-语句作用域" class="headerlink" title="5.2 语句作用域"></a>5.2 语句作用域</h2><ul><li>定义在控制结构中的变量只在相应的语句内部可见。</li></ul><pre><code>练习5.3(a) 必须为iter变量赋初值    String::iterator iter = s.begin();    while(iter!=s.end())&#123;/*..*/&#125;(b) 在if语句中，status已经离开了while的范围，所以要把status的赋值操作移出来。    bool status = find(word);    while(status)&#123;&#125;    if(!status)&#123;&#125;</code></pre><h2 id="5-3-条件语句"><a href="#5-3-条件语句" class="headerlink" title="5.3 条件语句"></a>5.3 条件语句</h2><h3 id="5-3-1-if语句"><a href="#5-3-1-if语句" class="headerlink" title="5.3.1 if语句"></a>5.3.1 if语句</h3><ul><li>c++规定else与离它最近的尚未匹配的if匹配。</li></ul><h3 id="5-3-2-switch语句"><a href="#5-3-2-switch语句" class="headerlink" title="5.3.2 switch语句"></a>5.3.2 switch语句</h3><ul><li>case关键字和他对应的值一起被称为case标签，case标签必须是整型常量表达式。</li><li>一个case标签只能放一个值。</li><li>任何两种case标签的值不能相同，default也是一种特殊的case标签。</li><li>如果某个case标签匹配成功，将从该标签开始往后的顺序执行所有的case分支。除非程序中断了这一过程，也就是使用了break。</li><li>如果需要为case分支定义初始化一个变量，放在外面比较合适，而不是放在case分支里面。</li></ul><pre><code>练习5.9int mian()&#123;    char ch;    unsigned int vowelcnt = 0;    while(cin&gt;&gt;ch)    &#123;        if(ch==&#39;a&#39;|| ch==&#39;e&#39;||ch==i||ch==&#39;o&#39;||ch==&#39;u&#39;)            ++vowelcnt;    &#125;&#125;</code></pre><pre><code>练习5.10int main()&#123;    char ch;    unsinged int aCnt,eCnt,iCnt,oCnt,uCnt = 0;    while(cin&gt;&gt;ch)    &#123;        switch(ch)&#123;            case &#39;a&#39;:            case &#39;A&#39;:                ++aCnt;                break;            case &#39;e&#39;:            case &#39;E&#39;:                ++eCnt;                break;            case &#39;i&#39;:            case &#39;I&#39;:                ++iCnt;                break;            case &#39;o&#39;:            case &#39;O&#39;:                ++oCnt;                break;            case &#39;u&#39;:            case &#39;U&#39;:                ++uCnt;                break;        &#125;    &#125;&#125;</code></pre><pre><code>练习 5.13(a)缺少break(b)ix需要定义在case语句外面。(c)不能使用case1,3,5,7,9的模式。(d)不能使用变量作为case标签。改为const unsigned ival = 512,jval = 1024,kval = 4096;</code></pre><h2 id="5-4-迭代语句"><a href="#5-4-迭代语句" class="headerlink" title="5.4 迭代语句"></a>5.4 迭代语句</h2><h3 id="5-4-1-while语句"><a href="#5-4-1-while语句" class="headerlink" title="5.4.1 while语句"></a>5.4.1 while语句</h3><ul><li>定义在while中的条件部分或者while循环内的变量每次迭代都经历从创建到销毁的过程。</li></ul><pre><code>练习5.14#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int mian()&#123;    string currString,preString = &quot;&quot;,maxString;    int currCnt = 1,maxCnt = 0;    while(cin&gt;&gt;curString)    &#123;        if(currString == preString)        &#123;            ++currCnt;            if(currCnt &gt; maxCnt)            &#123;                maxCnt = currCnt;                maxString = currString;            &#125;        &#125;        else        &#123;            currCnt = 1;        &#125;        preString = currString;    &#125;    if(maxCnt&gt;1)        cout&lt;&lt;&quot;出现最多的字符串是&quot;&lt;&lt;maxString;    else        cout&lt;&lt;&quot;没个字符串只出现了一次。&quot;    return 0;&#125;</code></pre><h3 id="5-4-2-传统for语句"><a href="#5-4-2-传统for语句" class="headerlink" title="5.4.2 传统for语句"></a>5.4.2 传统for语句</h3><ul><li>for语句中的定义的对象只在for语句的循环体内可见。</li><li>和其他声明一样，for语句的初始化也可以定义多个对象，但是只能有一条声明语句。</li></ul><pre><code>练习 5.15(a)定义了ix但是想要在for循环之外使用，错误。(b)少了一个分号</code></pre><pre><code>练习5.17# include &lt;iostream&gt;#include &lt;vector&gt;bool VIsEqual(const vector&lt;int&gt; &amp;vInt,const vecotr&lt;int&gt; &amp;Int2)&#123;    bool isEqual = true;    auto min = vInt.size()&lt;vInt2.size()?vInt.size():vInt2.size();    for(int i = 0;i&lt;min;i++)    &#123;        if(vInt[i]!=vInt2[i])            isEqual = false;    &#125;   return isEqual;&#125;int main()&#123;    vector&lt;int&gt; vInt,vInt2;&#125;</code></pre><h3 id="5-4-3-范围for语句"><a href="#5-4-3-范围for语句" class="headerlink" title="5.4.3 范围for语句"></a>5.4.3 范围for语句</h3><pre><code>vector&lt;int&gt; v = &#123;0,1,2,3,4,5,6,7,8,9&#125;;for(auto &amp;r : v)&#123;    r *= 2;&#125;//等价于for(auto beg = v.begin(),end = v.end();beg!=end;++beg)&#123;    auto &amp;r = *beg;    r*=2;&#125;</code></pre><ul><li>不能通过范围for循环添加容器的元素，因为在for语句中运存了end()的值。</li></ul><h3 id="5-4-4-do-while-语句"><a href="#5-4-4-do-while-语句" class="headerlink" title="5.4.4 do while 语句"></a>5.4.4 do while 语句</h3><pre><code>do     statementwhile(condition);</code></pre><ul><li>do while语句在括号包围起来的条件后面添加一个分号表示语句结束。</li><li>出现在do-while条件部分的变量必须定义在循环体之外。否则在非条件定义的变量在条件中不可见。</li></ul><pre><code>练习5.18(a) do&#123;        ...    &#125;while(cin);(b)     int ival;    do&#123;        &#125;while(int ival = get_response());(c)    int ival;    do&#123;        ival = get_value();    &#125;while(ival);    </code></pre><h2 id="5-5-跳转语句"><a href="#5-5-跳转语句" class="headerlink" title="5.5 跳转语句"></a>5.5 跳转语句</h2><h3 id="5-5-1-break语句"><a href="#5-5-1-break语句" class="headerlink" title="5.5.1 break语句"></a>5.5.1 break语句</h3><ul><li>break语句负责终止离他最近的while、do-while、for和switch语句。</li></ul><pre><code>int main()&#123;    bool isEqual = false;    string curString,preString = &quot;&quot;;    while(cin&gt;&gt;curString)    &#123;        if(curString == preString)            isEqual = true;            break;    &#125;    if(isEqual)        cout&lt;&lt;curString;    else        cout&lt;&lt;&quot;没有重复单词&quot;;&#125;</code></pre><h3 id="5-5-2continue-语句"><a href="#5-5-2continue-语句" class="headerlink" title="5.5.2continue 语句"></a>5.5.2continue 语句</h3><ul><li>continue 语句中断当前的迭代，但是任然继续循环</li></ul><h3 id="5-5-3-goto语句"><a href="#5-5-3-goto语句" class="headerlink" title="5.5.3 goto语句"></a>5.5.3 goto语句</h3><ul><li>goto语句从goto语句无条件的跳转到同一函数的另一条语句。</li><li>goto语句跳转到带标签的语句。尽量不要使用goto语句。</li></ul><h2 id="5-6-try-语句块和异常处理"><a href="#5-6-try-语句块和异常处理" class="headerlink" title="5.6 try 语句块和异常处理"></a>5.6 try 语句块和异常处理</h2><h3 id="5-6-1-throw-表达式"><a href="#5-6-1-throw-表达式" class="headerlink" title="5.6.1 throw 表达式"></a>5.6.1 throw 表达式</h3><ul><li>程序的异常检测部分使用throw表达式引发一个异常。抛出异常将终止当前函数，并吧控制权转移给能处理该异常的代码。</li></ul><h3 id="5-6-2-try语句块"><a href="#5-6-2-try语句块" class="headerlink" title="5.6.2 try语句块"></a>5.6.2 try语句块</h3><pre><code>while(cin&gt;&gt;item1&gt;&gt;item2)&#123;    try&#123;        //执行添加连个sales_item对象的代码        //如果添加失败，代码超出runtime_error一床        throw runtime_error(&quot;data must refer to same isbn&quot;);    &#125;catch(runtime_error err)&#123;        cout&lt;&lt;err.what()&lt;&lt;&quot;try again?enter y or n&quot;&lt;&lt;endl;        char c;        cin&gt;&gt;c;        if(!cin||c==&#39;n&#39;)            break;    &#125;&#125;</code></pre><ul><li>寻找处理代码的过程与函数调用相反，放异常被抛出是，首先搜错抛出该异常的函数，如果没有找到匹配的catch语句，终止该函数，在调用它的函数中寻找。最后到terminate的标准库函数，该函数的行为和系统相关。</li></ul><h3 id="5-6-3-标准异常"><a href="#5-6-3-标准异常" class="headerlink" title="5.6.3 标准异常"></a>5.6.3 标准异常</h3><ul><li>c++标准库定义了一组类，用于报告标准库函数遇到的问题。</li><li>exception头文件定义了通用的异常类exception，只报告异常的发生，不提供额外信息。</li><li>stdexcept头文件定义了集中常用的异常类。</li><li>new头文件定义了bad_alloc异常类型</li><li>type_info头文件定义了bad_cast头文件类型。</li><li>异常类型定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个c风格字符串。该字符串的目的提供关于异常的一些文本信息。</li></ul><pre><code>练习 5.25int mian()&#123;    int ival1,ival2;    while(cin&gt;&gt;ival1&gt;&gt;ival2)    &#123;        try        &#123;            if(ival2 == 0)                throw runtime_error(&quot;除数不能为0&quot;);            cout&lt;&lt;ival1/ival2;        &#125;        catch(runtime_error err)        &#123;            cout&lt;&lt;err.what();            cout&lt;&lt;&quot;是否继续 y or n&quot;&lt;&lt;endl;            char ch;            cin&gt;&gt;ch;            if(ch!=&#39;y&#39;&amp;&amp;ch!=&#39;Y&#39;)                break;        &#125;    &#125;    return 0;&#125;</code></pre><h1 id="第6章-函数"><a href="#第6章-函数" class="headerlink" title="第6章 函数"></a>第6章 函数</h1><h2 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h2><ul><li>函数的调用完成两项工作：一个是用实参初始化函数对应的形参，一个是将控制权交给被调用的函数。</li></ul><pre><code>练习6.1形参出现在函数的定义地方，而实参出现咋函数的调用地方。</code></pre><pre><code>练习6.2(a) 函数的 返回值是string类型(b) 函数没有返回值。(c) 函数的参数不能重复。(d) 函数体必须放在括号中。</code></pre><pre><code>练习6.3int fact(int val)&#123;    int ret = 1;    if(val&lt;0)return -1;    while(val&gt;0) ret*= ret*val;    return ret;&#125;</code></pre><pre><code>练习6.4#include&lt;iostream&gt;int main()&#123;    int num ;    cin&gt;&gt;num    cout&lt;&lt;fact(num)&lt;&lt;endl;&#125;</code></pre><h3 id="6-1-1局部对象"><a href="#6-1-1局部对象" class="headerlink" title="6.1.1局部对象"></a>6.1.1局部对象</h3><ul><li>局部静态对象在程序执行路径第一次经过对象的定义语句时初始化，知道程序终止才会被销毁。</li></ul><pre><code>练习6.6形参是一种自动对象，在函数开始为形参申请内存，用实参来初始化形参。普通变量是在定义该变量的语句处创建自动对象。局部变量在第一次遇到的时候创建，然后在程序结束时销毁。</code></pre><pre><code>练习6.7int func()&#123;    static int temp = -1;    ++temp;    return (temp==0)?0:1;&#125;</code></pre><h3 id="6-1-2-函数声明"><a href="#6-1-2-函数声明" class="headerlink" title="6.1.2 函数声明"></a>6.1.2 函数声明</h3><ul><li>函数的名字必须在使前声明，函数只能定义一次，可以声明多次。</li></ul><h2 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a>6.2 参数传递</h2><ul><li>当形参是引用类型，我们说它对应的实参被引用传递或函数被传引用调用。引用形参是他对应实参的别名。</li><li>当实参的值被拷贝给形参的时候，形参和实参是两个相互独立的对象，我们说实参被按值传递。或者函数被传值调用。</li></ul><h3 id="6-2-1-传值参数"><a href="#6-2-1-传值参数" class="headerlink" title="6.2.1 传值参数"></a>6.2.1 传值参数</h3><ul><li>指针的行为和其他非引用类型一样，但是当两个指针都指向一个对象，也就实现了可以对对象的修改。建议使用引用类型而不是指针。</li></ul><pre><code>void swap(int *pval,int *pval2)&#123;    int temp = *pval;    *pval = *pval2;    *pval2 = temp;&#125;</code></pre><h3 id="6-2-2-传引用参数"><a href="#6-2-2-传引用参数" class="headerlink" title="6.2.2 传引用参数"></a>6.2.2 传引用参数</h3><ul><li>使用引用形参可以返回额外的信息，也就是添加多一点的形参，该参数用引用形式表示，就可以返回多个参数了。</li></ul><pre><code>练习6.12引用更加容易实现，不用写解引用的操作。也不需要额外声明指针变量，避免了拷贝指针的值。</code></pre><pre><code>一个是按值传递一个是按引用传递。</code></pre><h3 id="6-2-3-const形参和实参"><a href="#6-2-3-const形参和实参" class="headerlink" title="6.2.3 const形参和实参"></a>6.2.3 const形参和实参</h3><ul><li>实参初始化形参会忽略掉顶层const</li><li>把函数不会改变的形参定义为普通引用时一种比较常见的错误。</li><li>字面值常量可以作为常量引用的形参的值</li></ul><pre><code>练习6.16bool is_empty(const string &amp;s)&#123;return s.empty();&#125;</code></pre><pre><code>练习6.17bool isContain(const string &amp;s)&#123;    for(auto temp:s)        if(isupper(temp))            return true;    return false;&#125;void ChangeToLower(string &amp;s)&#123;    for(auto &amp;temp:s)        temp = tolower(temp);&#125;</code></pre><pre><code>练习6.18(a) bool compare(const matrix &amp;matrix1,const matrix &amp;matrix2);(b) vector&lt;int&gt;::iterator change_val( int a,vector&lt;int&gt;::iterator &amp;vInt);</code></pre><pre><code>练习6.19(a) 不合法(b) 合法(c) 合法(d) 合法</code></pre><h3 id="6-2-4-数组形参"><a href="#6-2-4-数组形参" class="headerlink" title="6.2.4 数组形参"></a>6.2.4 数组形参</h3><ul><li>无法以值得形式使用数组参数。我们为函数传递一个数组的时候，实际上传递的是指向首元素的指针。</li><li>和其他使用数组的代码一样，以数组为形参的函数也必须保证使用数组不会越界。</li><li>管理指针形参常用的三个方法：<ul><li>使用标记指定数组长度，类似于string的方法。</li><li>使用标准库的规范。传递指向数组首元素和尾后元素的指针。</li><li>显示传递一个表示数组大小的形参。</li></ul></li><li>数组引用形参在声明的时候不能缺少括号，缺少了括号就变成了引用的数组了。<pre><code>f(int &amp;arr[10]);//错误f(int (&amp;arr)[10])&#39;&#39;</code></pre></li><li>传递多维数组真是传递的就是指向数组首元素的指针，数组首元素是数组，所以是指向数组的指针。</li></ul><pre><code>练习6.21int MaxValue(const int ival,const int *pval)&#123;    return (ival&lt;*pval?*pval:ival);&#125;</code></pre><pre><code>练习6.22void swapPoint(const int *p1,const int *p2)&#123;    const int *temp = p1;    p1 = p2;    p2 = temp;&#125;</code></pre><pre><code>练习6.24虽然我们希望传入的数组维度是10，但是实际上可以传入任意维度的数组，如果传入的维度小于10的数组，就会输出未定义的一些值。</code></pre><h3 id="6-2-5-mian：处理命令行选项"><a href="#6-2-5-mian：处理命令行选项" class="headerlink" title="6.2.5 mian：处理命令行选项"></a>6.2.5 mian：处理命令行选项</h3><ul><li><code>int mian(int argc,char *argv[])</code>第一个参数是数组中字符串的数量，第二个参数是一个数组，元素是指向c风格字符串的指针。</li><li>当实参传给main函数之后，argv的第一个元素指向程序名字或者一个空字符串，接下来的元素一次传递命令行提供的实参，最后一个指针之后的元素值保证为0.</li></ul><pre><code># include &lt;iostream&gt;int main(int argc,char *argv[])&#123;    string ret;    for(auto temp:argv)        ret += temp;    cout&lt;&lt;ret&lt;&lt;endl;&#125;</code></pre><h3 id="6-2-6-含有可变形参的函数"><a href="#6-2-6-含有可变形参的函数" class="headerlink" title="6.2.6 含有可变形参的函数"></a>6.2.6 含有可变形参的函数</h3><ul><li>如果所有的实参类型相同，可以传递一个名为initilizer_list的标准库类型，如果实参的类型不同，可以编写一个特殊的函数，也就是所谓的可变参数模板。</li></ul><pre><code>initializer_list提供的操作initializer_list&lt;T&gt; lst;            //默认初始化，T类型元素的空列表。initializer_list&lt;T&gt; lst&#123;a,b,c...&#125;;//lst的元素和初始值一样多，lst的元素是对应初始值的副本，列表中的元素是const。lst2(lst);          //  不会拷贝元素，原始列表和副本共享元素。lst2 = lst;lst.size()list.begin()list.end()</code></pre><ul><li>initializer_list中的值永远是常量值。</li><li>如果想向initializer_list形参中传递一个值的序列，必须把序列放到一对花括号中。<pre><code>if(expected!=actual)    error_msg(&#123;&quot;functionX,expected,actual&quot;&#125;);else    error_msg(&#123;&quot;functionX&quot;,&quot;okey&quot;&#125;);</code></pre></li><li>省略符形参是已改仅仅用于c和c++通用类型，大多是类类型对象在传递给省略符形参的是否无法正确拷贝。</li><li>省略符形参只能出现在参数列表的最后一个位置。</li></ul><pre><code>练习6.27int sum(iniitizlizer_list&lt;int&gt; list)&#123;    int ret = 0;    for(atuo i:list)        ret+=i;    return ret;&#125;</code></pre><pre><code>练习6.28elem类型是const string &amp;，使用引用时为了避免拷贝长字符串。</code></pre><pre><code>练习6.29当容器中的类型是类类型或者容器类型才有必要，这样会避免不必要的拷贝赋值操作 </code></pre><h2 id="6-3-返回类型和return语句"><a href="#6-3-返回类型和return语句" class="headerlink" title="6.3 返回类型和return语句"></a>6.3 返回类型和return语句</h2><h3 id="6-3-1-无返回类型函数"><a href="#6-3-1-无返回类型函数" class="headerlink" title="6.3.1 无返回类型函数"></a>6.3.1 无返回类型函数</h3><ul><li>没有返回值类型return语句只用在没有返回值类型的void函数中。</li></ul><h3 id="6-3-2-有返回值的函数"><a href="#6-3-2-有返回值的函数" class="headerlink" title="6.3.2 有返回值的函数"></a>6.3.2 有返回值的函数</h3><ul><li>在含有return语句的循环后面应该有一条return语句，如果没有的话程序是错误的，很多编译器无法发现此类错误。</li><li>如果函数返回引用，该引用仅是他所引对象的一个别名。不会返回拷贝的对象。</li><li>不要返回局部对象的引用和指针。因为函数完成后，局部的对象会被释放，指针会指向一个不存在的对象。</li><li>函数的返回类型决定函数调用是否是左值，调用一个返回引用的函数的到左值，其他类型返回右值。</li><li>c++11规定函数可以返回花括号包围的值的列表，类似于其他 返回结果，此处的列表也用来对函数返回的临时量进行初始化。</li></ul><pre><code>练习 6.31如果引用所引的是函数之前就存在的对象，则返回的引用时引用的，如果引用所引的是函数的局部变量，返回的引用无效。如果不希望返回的对象被修改，返回对常量的引用。</code></pre><pre><code>void func(vector&lt;int&gt; vInt,unsinged index)&#123;    unsingned sz = vInt.size();    if(!vInt.empty()&amp;&amp;index&lt;sz)    &#123;        cout&lt;&lt;vInt[index]&lt;&lt;endl;        func(vInt,index+1);    &#125;&#125;</code></pre><pre><code>练习6.31如果结果是负数会一直递归下去，会出现问题。</code></pre><h3 id="6-3-3-返回数组指针"><a href="#6-3-3-返回数组指针" class="headerlink" title="6.3.3 返回数组指针"></a>6.3.3 返回数组指针</h3><ul><li>返回数组指针的函数，int(*func(int i))[10];该函数的返回类型数指向数组的指针，该函数接受的参数是int类型。</li><li>尾置返回类型，任何函数都可以使用，但是这种类型一般对比较复杂的函数有效，auto func(int i)-&gt;int(*)[10];</li><li>可以使用decltype关键字申明返回类型，前提是知道函数指向哪个数组。<pre><code>int odd[] = &#123;1,2,3,4,5&#125;;int even[] = &#123;1,2,3,4,5&#125;;decltype(odd) *arrPtr(int i)&#123;    return (i%2)?&amp;odd:&amp;even;&#125;</code></pre></li></ul><pre><code>练习6.36string (&amp;func())[10];typedef string vString[10];vString &amp;func();auto func() -&gt; string(&amp;)[10];string vstring[10];decltype(vstring) &amp;func();</code></pre><h2 id="6-4-函数重载"><a href="#6-4-函数重载" class="headerlink" title="6.4 函数重载"></a>6.4 函数重载</h2><ul><li>不允许两个函数除了返回值类型其他所有的要素相同。</li><li>顶层const不影响传入函数的对象，一个拥有顶层cosnt的形参无法和另一个没有顶层const的形参区分开来。</li><li>底层const编译器可以通过实参是否是常量来推断调用哪个函数。</li><li>const_cast可以对常量和非常量进行转化，所以可以在一个接受非常量的函数中调用一个接受常量的重载函数来实现该函数，方法就是对形参进行const_cast。</li></ul><pre><code>练习 6.39(a) 非法，顶层const不区分重载(b) 非法，不能只用返回值来区分重载(c) 合法。</code></pre><h3 id="6-4-1-重载和作用域"><a href="#6-4-1-重载和作用域" class="headerlink" title="6.4.1 重载和作用域"></a>6.4.1 重载和作用域</h3><ul><li>c++中名字查找是发生在类型检查之前的。如果在函数局部作用域中声明了一个函数，就会对外部作用域的函数进行隐藏，从而无法找到外部作用域的函数。</li></ul><h2 id="6-5-特殊用途语言特性"><a href="#6-5-特殊用途语言特性" class="headerlink" title="6.5 特殊用途语言特性"></a>6.5 特殊用途语言特性</h2><h3 id="6-5-1-默认实参"><a href="#6-5-1-默认实参" class="headerlink" title="6.5.1 默认实参"></a>6.5.1 默认实参</h3><ul><li>如果一个参数被赋予了默认值，那么他后面的所有参数都必须有默认值。而且在调用的时候，如果想覆盖最后一个参数的默认值，前面的参数必须提供实参。</li><li>在给定作用域中的一个形参只能被赋予一次默认实参。</li><li>用作默认实参的名字在函数声明的所在作用域内被解析，而这些名字的求值过程发生在函数调用的时候。</li></ul><pre><code>练习6.40第二个声明是错误的，因为一旦某个参数呗赋予了默认值，他后面的参数都要赋予默认值。</code></pre><pre><code>练习6.41只有第二个是正确的。</code></pre><h3 id="6-5-2-内联函数和constexpr函数"><a href="#6-5-2-内联函数和constexpr函数" class="headerlink" title="6.5.2 内联函数和constexpr函数"></a>6.5.2 内联函数和constexpr函数</h3><ul><li>内联函数只是想编译器发出一个请求，编译器可以选择忽略这个请求。</li><li>constexpr函数是能用于常量表达式的函数，函数的返回值和参数类型都是字面值类型。函数体只有一个return语句<pre><code>constexpr int new_sz()&#123;return 42;&#125;;constexpr int foo = new_sz();</code></pre></li></ul><h3 id="6-5-3-调试帮助"><a href="#6-5-3-调试帮助" class="headerlink" title="6.5.3 调试帮助"></a>6.5.3 调试帮助</h3><ul><li>assert(expr)如果expr为0，assert输出信息并终止程序的执行，否则什么都不做。</li><li>assert的行为依赖于NDEBUG的预处理变量的状态。如果定义了该变量，assert什么都不做。</li><li>NDEBUG也可以用来编写调试代码，如果NDEBUG未定义，就会执行#ifndef 和#endif之间的代码。</li></ul><h2 id="6-6-函数匹配"><a href="#6-6-函数匹配" class="headerlink" title="6.6 函数匹配"></a>6.6 函数匹配</h2><ul><li>基本原则是，实参类型和形参类型越接近，他们匹配的越好。</li><li>调用重载函数的时候应该尽量必变强制类型转换。</li></ul><pre><code>练习6.50(a)调用具有二义性(b)调用f(int a)(c) 调用f(int a,int b)(d)调用f(double a,double b =);</code></pre><h2 id="6-7-函数指针"><a href="#6-7-函数指针" class="headerlink" title="6.7 函数指针"></a>6.7 函数指针</h2><ul><li>函数指针指向的是函数而不是对象，函数指针指向某种类型，而函数的类型有他的返回值和形参类型决定。与函数名无关。</li><li>当我们把函数名作为一个值使用的时候，该函数自动转换为指针。</li><li>虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。我们可以把函数直接当实参使用，会自动转为指针。<pre><code>//func 和func2是函数类型typedef bool func(const string &amp;,cosnt string&amp;);typedef decltype(lengthCompare) func2; //funcp和funcp2是指向函数的指针typedef bool(*funp)(int i,int j);typedef decltype(lenthCompare) *funcp2;</code></pre></li><li>和数组类似虽然不能返回一个函数，但是可以返回指向函数类型的指针。可以使用类型别名，也可以使用声明式或者使用尾置返回类型。如果明确知道返回的函数是那个，可以使用decltype简化书写函数指针返回类型的过程。</li></ul><pre><code>练习6.54int fun(int a,int b);typedef int (*funcp)(int a,int b);vector&lt;funcp&gt; vFuncp;</code></pre><pre><code>int func1(int a,int b)&#123;    return a+b;&#125;int func2(int a,int b)&#123;    return a-b;&#125;int func3(int a,int b)&#123;    return a*b;&#125;int func4(int a,int b)&#123;    return a/b;&#125;vFuncp.push_back(func1);vFuncp.push_back(func2);vFuncp.push_back(func3);vFuncp.push_back(func4);vFuncp[i](1,2);</code></pre><h1 id="第7章-类"><a href="#第7章-类" class="headerlink" title="第7章 类"></a>第7章 类</h1><h2 id="7-1定义抽象数据类型"><a href="#7-1定义抽象数据类型" class="headerlink" title="7.1定义抽象数据类型"></a>7.1定义抽象数据类型</h2><h3 id="7-1-1-设计Sales-data类"><a href="#7-1-1-设计Sales-data类" class="headerlink" title="7.1.1 设计Sales_data类"></a>7.1.1 设计Sales_data类</h3><ul><li>常量成员函数其实就是给this指针所指的对象声明为const，所以该常量成员函数不能改变调用它的对象的内容。</li><li>编译器首先编译成员函数的声明，然后编译成员函数体，所以成员函数可以随意使用类中的其他成员而无需在意这些成员出现的次序。</li></ul><pre><code>练习7.2class Sales_data&#123;private:    string bookNo;    unsigned units_sold = 0;    double sellingprice = 0.0;    double saleprice = 0.0;    double discont = 0.0;public:    string isbn const &#123;return bookNo;&#125;    Sales_data&amp; combine(const Sales_data &amp; rhs)    &#123;        units_sold += rhs.units_sold;        slaeprice = (rhs.saleprice*rhs.units_sold + saleprice*units_sold)/(rhs.units_sold+units_sold);        if(sellingprice != 0)            discont = saleprice / sellingprice;            return *this;    &#125;&#125;</code></pre><pre><code>练习7.4 class Person&#123;private:    string name;    string address;&#125;;</code></pre><pre><code>练习7.5class Person&#123;private:    string name;    string address;public:    string getName() const&#123;return name&#125;;    string getAddress() const&#123;return address&#125;;&#125;;</code></pre><h3 id="7-1-3-定义类相关的非成员函数"><a href="#7-1-3-定义类相关的非成员函数" class="headerlink" title="7.1.3 定义类相关的非成员函数"></a>7.1.3 定义类相关的非成员函数</h3><ul><li>如果函数在概念上属于列但是不定义在类中，则一般将其放到.h文件中，这样就只需要引用一个文件。</li></ul><pre><code>练习7.9class Person&#123;private:    string name;    string address;public:    string getName() const&#123;return name&#125;;    string getAddress() const&#123;return address&#125;;    Person() = default;    Person(const string &amp; iname,const string &amp;iaddress):name(iname),address(iaddress) &#123;&#125;;    Person(istream &amp;is)&#123;return is&gt;&gt;*this;&#125;;friend istream&amp; read(istream &amp;is,Person &amp;person);friend ostream &amp;print(ostream &amp;os,const Person &amp; person);&#125;;istream&amp; read(istream &amp;is,Person &amp;person)&#123;    is&gt;&gt;person.name&gt;&gt;person.address;    return is;&#125;ostream &amp;print(ostream &amp;os,const Person &amp; person)&#123;    os&lt;&lt;person.name&lt;&lt;&quot; &quot;&lt;&lt;person.address;    return os;&#125;</code></pre><h3 id="7-1-4-构造函数"><a href="#7-1-4-构造函数" class="headerlink" title="7.1.4 构造函数"></a>7.1.4 构造函数</h3><ul><li>只要当类没有声明默认构造函数的时候，编译器才会自动的生成默认构造函数。</li><li>在c++11中如果我们需要默认的行为，可以通过在参数列表后面加上&#x3D;default俩要求编译器生成构造函数。</li><li>一般情况下，构造函数使用类内初始值是一种好的习惯。构造函数不应该轻易覆盖类内的初始值，除非不一样。</li></ul><h2 id="7-2-访问控制和封装"><a href="#7-2-访问控制和封装" class="headerlink" title="7.2 访问控制和封装"></a>7.2 访问控制和封装</h2><h3 id="7-2-1-友元"><a href="#7-2-1-友元" class="headerlink" title="7.2.1 友元"></a>7.2.1 友元</h3><ul><li>友元可以允许其他类或者函数访问他的共有成员。</li><li>类的封装的两个优点<ul><li>确保用户代码不会无意间破坏封装对象的状态。</li><li>被封装的类的具体实现细节可以随便改变，而不用调整用户级别的代码。</li></ul></li><li>友元的声明只是指定了访问的权限，如果我们希望类的用户能够调用某个友元函数，需要在该类中再次声明该函数。</li></ul><h2 id="7-3-类的其他特性"><a href="#7-3-类的其他特性" class="headerlink" title="7.3 类的其他特性"></a>7.3 类的其他特性</h2><h3 id="7-3-1-类成员再谈"><a href="#7-3-1-类成员再谈" class="headerlink" title="7.3.1 类成员再谈"></a>7.3.1 类成员再谈</h3><ul><li>如果希望修改类的某个数据成员即使是在const成员函数中，可以将该成员声明为mutable关键字做到这一点。</li></ul><pre><code>class Screan&#123;private:    unsigned height = 0,width = 0;    unsigned cursor = 0;    string contents;public:    Screan() = default;    Screan(unsigned ht,unsigned wd):height(ht),width(wd),contents(ht*wd,&#39; &#39;)&#123;&#125;;    Screan(unsigned ht,unsigned wd,char c):height(ht),width(wd),contents(ht*wd,c)&#123;&#125;;public：    Screan&amp; move(unsigned ht,unsigned wd)&#123;cursor = th * width + wd;return *this&#125;;    Screan&amp; set(char a)    &#123;        contents[cursor] = a;        return * this;    &#125;    Screan&amp; display(ostreawm&amp; os)    &#123;        os&lt;&lt;contents;        return *this;    &#125;public:    frinend Window_mgr::clear(unsigned index));&#125;;class Window_mgr&#123;private:    vector&lt;Screen&gt; screens&#123;Screen(24,80,&#39; &#39;)&#125;;public:     void clear();&#125;;void Window_mgr::clear(unsigned index)&#123;    Screen &amp;s = screens[index];    s.contents = string(s.height*s.width,&#39; &#39;);&#125;</code></pre><h3 id="7-3-2-返回-this的成员函数"><a href="#7-3-2-返回-this的成员函数" class="headerlink" title="7.3.2 返回*this的成员函数"></a>7.3.2 返回*this的成员函数</h3><h3 id="7-3-3-类类型"><a href="#7-3-3-类类型" class="headerlink" title="7.3.3 类类型"></a>7.3.3 类类型</h3><ul><li>我们可以定义指向不完整类型的指针，但是不能定义指向不完整类型的对象。如果要定义对象，必须知道对象的定义。</li></ul><pre><code>class X;class Y&#123;  X x;  &#125;;class X&#123;    Y * y;&#125;;</code></pre><h3 id="7-3-4-友元再探"><a href="#7-3-4-友元再探" class="headerlink" title="7.3.4 友元再探"></a>7.3.4 友元再探</h3><ul><li>类也可以吧其他类定义为友元，也还可以把其他类的成员函数定义为友元。</li><li>友元关系不具有传递性，每个类负责控制自己的友元类和友元函数。</li><li>如果一个类想把一组重载函数声明为他的友元，需要对这组函数中的每个函数分别声明。</li></ul><h2 id="7-4-类的作用域"><a href="#7-4-类的作用域" class="headerlink" title="7.4 类的作用域"></a>7.4 类的作用域</h2><ul><li>函数的返回值类型通常位与类的作用域之外，所以返回值类型必须明确指明他是哪个类的成员。</li></ul><pre><code>练习7.33Screen::pos Screen::size() const&#123;    return height*width;&#125;</code></pre><h3 id="7-4-1-名字的查找与类的作用域"><a href="#7-4-1-名字的查找与类的作用域" class="headerlink" title="7.4.1 名字的查找与类的作用域"></a>7.4.1 名字的查找与类的作用域</h3><ul><li>成员函数直到整个类可见后才会被处理，所以他可以使用类中定义的任何名字。</li><li>类型名的定义通常在类开始的地方，保证所有使用该类型的成员都在类名定义的后面。</li><li>如果要访问外层作用域的对象，可以使用::来访问。</li></ul><pre><code>练习7.35typedef string Type1;Type1 initVal();class Exercise&#123;public:    typedef double Type2;    Type2 setVal(Type2);    Type2 initVal();private:    int val;&#125;;Exercise::Type2 Exercise::setVal(Type2 parm)&#123;    val = parm + initVla();    return val;&#125;</code></pre><h2 id="7-5-构造函数再探"><a href="#7-5-构造函数再探" class="headerlink" title="7.5 构造函数再探"></a>7.5 构造函数再探</h2><h3 id="7-5-1-构造函数初始值列表"><a href="#7-5-1-构造函数初始值列表" class="headerlink" title="7.5.1 构造函数初始值列表"></a>7.5.1 构造函数初始值列表</h3><ul><li>当成员属于某个类类型而且该类没有定义默认构造函数的时候，必须为这个成员初始化。</li><li>如果成员是const、引用、或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始化值列表来为这些成员提供初值。</li><li>最好另构造函数的初始值的顺序和成员声明的顺序一致，而且如果可能尽量避免使用某些成员初始化其他成员。</li><li>如果一个构造函数为所以参数都提供了默认的实参，实际上也就定义了默认构造函数。<pre><code>class ConstRef&#123;    public:        ConstRef(int ii);    private:        int i;        const int ci;        int &amp;ri;&#125;;ConstRef::ConstRef(int ii)&#123;    i = ii;    ci = ii;    //错误不能给const赋值    ri = i;     //错误，ri没有初始化。&#125;</code></pre></li></ul><h3 id="7-5-2-委托构造函数"><a href="#7-5-2-委托构造函数" class="headerlink" title="7.5.2 委托构造函数"></a>7.5.2 委托构造函数</h3><ul><li>一个委托构造函数使用它所属的类的其他构造函数执行它自己的初始化过程。</li></ul><h3 id="7-5-3-默认构造函数的作用"><a href="#7-5-3-默认构造函数的作用" class="headerlink" title="7.5.3 默认构造函数的作用"></a>7.5.3 默认构造函数的作用</h3><ul><li>当对象被默认初始化或者值初始化的时候自动调用默认构造函数。</li><li>定义一个使用默认构造函数进行初始化的对象，正确方法是去掉对象后的括号，不然定义的是函数而不是对象了。</li><li>对于编译器合成的默认构造函数来说，类类型的成员执行各自所以属类的默认构造函数，而内置类型和符合类型的成员只对定义在全局作用域中的对象执行初始化。</li></ul><h3 id="7-5-4-隐式的类类型转换"><a href="#7-5-4-隐式的类类型转换" class="headerlink" title="7.5.4 隐式的类类型转换"></a>7.5.4 隐式的类类型转换</h3><ul><li>转换构造函数可以通过一个实参调用构造函数定义了一条从构造函数的参数类型想类类型的隐世转换的规则。</li><li>只允许一步类类型的转换，且转换并比总是有效的。</li><li>可以将构造函数声明为explicit来防止隐式转换。</li><li>需要多个参数的构造函数不能用于执行隐式转换。</li></ul><h3 id="7-5-5-聚合类"><a href="#7-5-5-聚合类" class="headerlink" title="7.5.5 聚合类"></a>7.5.5 聚合类</h3><ul><li>聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足条件：<ul><li>所有成员都是public的。</li><li>没有定义任何构造函数</li><li>没有类内初始值</li><li>没有基类，没有虚函数。</li></ul></li></ul><h3 id="7-5-6-字面值常量类"><a href="#7-5-6-字面值常量类" class="headerlink" title="7.5.6 字面值常量类"></a>7.5.6 字面值常量类</h3><ul><li>数据成员都是字面值类型的聚合类是字面值常量类型。聚合类的要求：<ul><li>数据成员都必须是字面值类型</li><li>类必须至少含有一个constexpr构造函数。</li><li>如果一个数据成员含类内初始值，则内置类型成员的初始值必须是一条常量表达式。或者若成员属于某种类型，则初始值必须使用成员自己的constexpr构造函数。</li><li>类必须使用析构函数的默认的定义，该成员负责销毁类的对象。</li></ul></li></ul><h2 id="7-6-类的静态成员"><a href="#7-6-类的静态成员" class="headerlink" title="7.6 类的静态成员"></a>7.6 类的静态成员</h2><ul><li>通过在成员声明前添加关键字static使得其余类关联在一起。</li><li>和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名，static关键字只能出现在类内部的声明语句中。</li><li>静态数据成员不属于类的任何一部分，所以我们不能再类的内部初始化静态成员。</li><li>可以为静态成员提供const整数类型的类内初始值。即使一个常量静态数据成员在类内被初始化了，一般情况下也要在类外部定义一下该成员。</li><li>静态数据成员的类型可以是他所属的类型，也就是静态成员可以是不完全类型。</li><li>我们可以使用静态成员作为默认实参。</li></ul><h1 id="第8章-IO库"><a href="#第8章-IO库" class="headerlink" title="第8章 IO库"></a>第8章 IO库</h1><h2 id="8-1-IO类"><a href="#8-1-IO类" class="headerlink" title="8.1 IO类"></a>8.1 IO类</h2><ul><li>iostream定义了用于读写流的基本类型，fstream定义了读写命名文件的类型，sstream定义了读写内存string对象的类型。</li><li>标准库使我们能忽略这些不同类型的流之间的差异是通过继承机制实现的。我们可以将一个继承类对象当做基类对象使用。</li></ul><h3 id="8-1-1-io对象无拷贝或赋值"><a href="#8-1-1-io对象无拷贝或赋值" class="headerlink" title="8.1.1 io对象无拷贝或赋值"></a>8.1.1 io对象无拷贝或赋值</h3><ul><li>由于不能拷贝IO对象所以不能将形参或者返回类型设置为流类型。进行IO操作的函数通常以引用形式传递和返回流</li></ul><h3 id="8-1-2-条件状态"><a href="#8-1-2-条件状态" class="headerlink" title="8.1.2 条件状态"></a>8.1.2 条件状态</h3><ul><li>IO类定义了一些函数和标志，帮助我们访问和操纵流的条件状态。</li><li>IO库定义了一个与机器无挂你的iostate类型，他提供了表达流状态的完整功能，包括4个iostate类型的constexpr值表示特定的位模式。badbit表示系统级错误，如不可恢复的读写错误，发生可恢复读写错误，failbit被置位。如果到文件末尾，eofbit和failbit会被置位。</li><li>流对象rdstate成员返回一个iostate值，setstate将给定条件位置位。</li></ul><pre><code>io库条件状态strm::iostate                       //条件表达状态完整功能strm::badbig                        //流已崩溃strm::failbit                       //io操作失败strm::eofbig                        //流到达了文件结束strm::goodbig                       //流末处于错误状态，此值保证为os.eof()                             //流的eofbig置位(变为1)，返回trues.fail()                            //流的failbit或badbit置位，返回trues.bad()                             //s.good()s.clear()s.clear(flags)s.setstate(flags)s.rdstate()                         //返回流s的当前状态，返回类型为strm::iostate</code></pre><pre><code>练习8.1 istream&amp; read(istream&amp; is)&#123;    int v;    while(in&gt;&gt;v,!in.eof())    &#123;        if(in.bad())            throw runtime_error(&quot;io流错误&quot;);        if(in.fail())        &#123;            cerr&lt;&lt;&quot;数据错误&quot;&lt;&lt;endl;            in.clear();            in.ignore(100,&#39;\n&#39;);            continue;        &#125;        cout&lt;&lt;v&lt;&lt;endl;    &#125;    in.clear();    return in;    while(is&gt;&gt;)&#125;</code></pre><pre><code>练习8.3 遇到了文件结束符，遇到了io流错误，遇到了无效数据。</code></pre><h3 id="8-1-3-管理输出缓冲"><a href="#8-1-3-管理输出缓冲" class="headerlink" title="8.1.3 管理输出缓冲"></a>8.1.3 管理输出缓冲</h3><ul><li>每个输出流都管理一个缓冲区，用来保存程序读写的数据。</li><li>导致缓冲刷新(数据真正写到输出设备或者文件)的原因：<ul><li>程序正常运行结束。</li><li>缓冲区满的时候。</li><li>使用操作符endl显示刷新缓冲区。</li><li>使用操作符unitbuf设置流内部状态。来清空缓冲区。</li><li>一个输出流关联到另一个流的时候，默认cin和cerr是关联到cout的，所以读cin和写cerr会导致cout缓冲区刷新。</li></ul></li><li>flush刷新缓冲区，但不输出任何额外的字符，ends向缓冲区中插入一个空字符，然后刷新缓冲区。</li><li>我们可以使用unitbuf操纵符告诉流接下来的每次操作之后都进行一次flush操作。<pre><code>cout&lt;&lt;unitbuf;          //所有输出操作都会被立即刷新cout&lt;&lt;nounitbuf;        //回到正常刷新模式</code></pre></li><li>x.tie(&amp;o)将流x关联到输出流o，每个流最多关联到一个流，但是多个流可以同时关联到同一ostream。</li></ul><h2 id="8-2-文件输入输出"><a href="#8-2-文件输入输出" class="headerlink" title="8.2 文件输入输出"></a>8.2 文件输入输出</h2><pre><code>fstream fstrm;          //创建一个未绑定的文件流fstream fstrm(s);       //创建一个fstream，并打开名为s的文件fstream fstrm(s,mode);  //按指定mode打开文件fstrm.open(s)           //打开名为s的文件fstrm.close()           //关闭与fstrm绑定的文件，返回voidfstrm.is_open()         //指出fstrm关联的文件是否打开成功也没有关闭。</code></pre><h3 id="8-2-1-使用文件流对象"><a href="#8-2-1-使用文件流对象" class="headerlink" title="8.2.1 使用文件流对象"></a>8.2.1 使用文件流对象</h3><ul><li>对文件名既可以是string也可以是c风格字符数组，c++11支持 。</li><li>一旦一个文件流打开，他就保持了与对应文件的关联，对一个已经打开的文件流调用open会失败，导致failbit被置位。为了将文件流关联到另一个文件中，必须关闭已关联的文件。</li><li>当fstream对象被销毁的时候，close被会自动调用。</li><li>ifstream 向一个文件中读取数据，ofstream向一个中写入数据</li></ul><pre><code>练习8.4vector&lt;string&gt; read(string filename)&#123;    ifstream in(filename);     if(!in)&#123;        cout&lt;&lt;&quot;打开文件失败&quot;&lt;&lt;endl;        return -1;    &#125;    string line;    vector&lt;string&gt; vs;    while(getline(in,line))    &#123;        vs.push_back(line);    &#125;&#125;</code></pre><h3 id="8-2-2-文件模式"><a href="#8-2-2-文件模式" class="headerlink" title="8.2.2 文件模式"></a>8.2.2 文件模式</h3><pre><code>in          //读out         //写app         //每次写操作前定位到文件末尾ate         //打开文件后立即定位到文件末尾trunc       //截断文件binary      //以二进制读写</code></pre><ul><li>默认情况下out模式是截断文件的，也就是不会追加读写，如果想追加读写，添加app。</li><li>对于一个给定的流，每次打开文件都可以改变文件的模式。</li></ul><h2 id="8-3-string流"><a href="#8-3-string流" class="headerlink" title="8.3 string流"></a>8.3 string流</h2><ul><li>istringstream从string读取数据，ostringstream向string写数据。</li></ul><pre><code>sstream strm;           //strm是一个未绑定stringstream对象sstream strm(s);        //strm是一个sstream对象，保存一个string s的拷贝。strm.str()              //返回strm保存的string 的拷贝strm.str(s)             //将string s拷贝到strm中。</code></pre><h3 id="8-3-1-使用istringstream"><a href="#8-3-1-使用istringstream" class="headerlink" title="8.3.1 使用istringstream"></a>8.3.1 使用istringstream</h3><pre><code>练习8.9int main()&#123;    ostringstream msg;    msg&lt;&lt;&quot;c++ primer&quot;&lt;&lt;endl;    istringstream in(msg.str());    f(in);    return 0;&#125;</code></pre><pre><code>练习8.10int main()&#123;    ifstream in(&quot;data&quot;);    if(!in)    &#123;        cerr&lt;&lt;&quot;无法打开输入文件&quot;&lt;&lt;endl;        return -1;    &#125;    string line ;    vector&lt;string&gt; vc;    while(getline(in,line)    &#123;        vc.push_back(line);    &#125;    in.close();    for(auto &amp;item : vc)    &#123;        istringstream line_str(item);        string word;        while(line_str&gt;&gt;word)            cout&lt;&lt;word&lt;&lt;&quot; &quot;;        cout&lt;&lt;endl;    &#125;&#125;</code></pre><h1 id="第9章-顺序容器"><a href="#第9章-顺序容器" class="headerlink" title="第9章 顺序容器"></a>第9章 顺序容器</h1><h2 id="9-1-顺序容器简介"><a href="#9-1-顺序容器简介" class="headerlink" title="9.1 顺序容器简介"></a>9.1 顺序容器简介</h2><ul><li>所有的顺序容器都提供了快速顺序访问元素的能力。</li></ul><pre><code>顺序容器类型vector          //可变大小数组，支持快速随机访问，在尾部之外的位置插入和删除元素可能很慢。deque           //双端队列，支持快速随机访问。在头尾插入删除元素快list            //双向链表，支持双向顺序访问，在list中的任何位置进行插入删除都快forward_list    //单向链表，只支持单向顺序访问array           //固定大小数组，支持快速随机访问。string          //与vector类似，但只用来存储string。</code></pre><h2 id="9-2-容器库概览"><a href="#9-2-容器库概览" class="headerlink" title="9.2 容器库概览"></a>9.2 容器库概览</h2><pre><code>容器的操作---------------------类型别名---------------------------------------iterator                                //此容器类型的迭代器类型const_iterator                          //可以读取元素但是不能修改元素的迭代器类型size_type                               //无符号整型，足够保存次容器最大可能容器的大小defference_type                         //带符号整型，足够保存两个容器之间的距离value_type                              //元素类型reference                               //元素的左值类型：与value_type&amp;含义相同const_reference                         //元素的const左值类型----------------------构造函数-----------------------------------------C c;                                    //默认初始化，构造空容器C c1(c2);                               //构造c2的拷贝c1C c(b,e);                               //构造c，将迭代器b和e指定范围内的容器元素拷贝到c(array不支持)C c&#123;a,b,c...&#125;;                          //列表初始化c------------------------赋值和swap------------------------------------------------c1 = c2                                 //将c1中的元素替换为c2中的元素c1 = &#123;a,b,c...&#125;                         //将c1中的元素替换为列表中的元素a.swap(b)                               //交换a和b的元素swap(a,b)                               //交换a和b的元素------------------------大小-------------------------------------------------c.size()                                //c中元素的数目(forward_list不支持)c.max_size()                            //c可以保存的最大元素数目c.empty()                               //若c中有元素为false------------------------添加和删除元素(不同容器，接口可能不一样)---------------c.insert(args)                          //将args中的元素拷贝到cc.emplace(inits)                        //使用inits构造c中的一个元素c.erase(args)                           //删除args指定的元素c.clear()                               //删除c中所有元素==,!=                                   //所欲容器支持&lt;,&lt;=,&gt;,&gt;=                               //无序关联容器不支持--------------------------获取迭代器--------------------------------------------c.begin(),c.end()c.cbegin(),c.cend()---------------------------反向容器的额外成员(不支持forward_list)---------------------reverse_iterator                        //按逆序寻址元素的迭代器const_reverse_iteratorc.rbegin(),c.rend()                     //返回c的尾元素和首元素之前位置的迭代器。c.crbegin(),c.crend()</code></pre><h3 id="9-2-1-迭代器"><a href="#9-2-1-迭代器" class="headerlink" title="9.2.1 迭代器"></a>9.2.1 迭代器</h3><ul><li>标准库使用左闭合范围。</li></ul><pre><code>练习9.4bool fine(vector&lt;int&gt;::iterator begin,vector&lt;int&gt;::iterator end,int value)&#123;    for(auto iter = begin;iter!=end,++iter)    &#123;        if(*iter==value)            return true;    &#125;    return false;&#125;</code></pre><pre><code>练习9.5vector&lt;int&gt;iterator fine(vector&lt;int&gt;::iterator begin,vector&lt;int&gt;::iterator end,int value)&#123;    for(auto iter = begin;iter!=end,++iter)    &#123;        if(*iter==value)            return iter;    &#125;    return -1;&#125;</code></pre><h3 id="9-2-2-容器类型成员"><a href="#9-2-2-容器类型成员" class="headerlink" title="9.2.2 容器类型成员"></a>9.2.2 容器类型成员</h3><pre><code>练习9.7使用迭代器类型索引元素</code></pre><pre><code>练习9.8读取string的list中的元素用 list&lt;string&gt;::value_type为了写入数据，使用引用类型，list&lt;string&gt;::reference</code></pre><h3 id="9-2-3-begin和end成员"><a href="#9-2-3-begin和end成员" class="headerlink" title="9.2.3 begin和end成员"></a>9.2.3 begin和end成员</h3><ul><li>不一c开头的being和end函数被重载过，当对一个非常量引用调用这些函数的时候，才会的到一个const版本。</li><li>当不需要写访问的时候，应该使用cbegin和cend</li></ul><pre><code>练习9.9begin返回的迭代器是非常量迭代器或者常量迭代器，根据调用的变量决定，而cbegin返回的是const迭代器。</code></pre><pre><code>练习9.10it1 vector&lt;int&gt;::iteratorit2 vector&lt;int&gt;::const_iteratorit3 vector&lt;int&gt;::const_iteratorvector&lt;int&gt;::const_iterator</code></pre><h3 id="9-2-4-容器的定义和初始化"><a href="#9-2-4-容器的定义和初始化" class="headerlink" title="9.2.4 容器的定义和初始化"></a>9.2.4 容器的定义和初始化</h3><ul><li>只有顺序容器的构造函数才接受大小参数(不包括array)<pre><code>C seq(n)C seq(n,t)</code></pre></li><li>将一个容器初始化为另一个容器的拷贝的时候，两个容器的容器类型和元素类型必须相同。</li><li>当用传递迭代器来拷贝的时候可以不同但是必须可以转化。</li><li>如果元素类型是内置类型或者是有默认构造参数的类类型，可以置位构造函数提供一个容器大小参数。如果元素类型没有默认构造函数，除了大小参数外，还需要一个显示的元素初始值。</li><li>标准库array的大小也是类型的一部分<pre><code>array&lt;int,42&gt; array&lt;string,10&gt;</code></pre></li><li>虽然不能对内置数组进行拷贝和对象的赋值操作，但是array没有限制。</li></ul><pre><code>练习9.11vector&lt;int&gt; v1;vector&lt;int&gt; v2(v1);vector&lt;int&gt; v3 = v2;vector&lt;int&gt; v4&#123;1,2,3&#125;;vector&lt;int&gt; v5= &#123;1,2,3&#125;;vector&lt;int&gt; v6(v5.begin(),v5.end());</code></pre><pre><code>练习9.9接受一个容器的构造函数会拷贝次容器中的所有值。而接受迭代器可以只拷贝部分值</code></pre><h3 id="9-2-5-赋值和swap"><a href="#9-2-5-赋值和swap" class="headerlink" title="9.2.5 赋值和swap"></a>9.2.5 赋值和swap</h3><ul><li>assign操作用参数所指定的元素(的拷贝)替换左边容器中的所有元素。如可以用assign实现一个vector中的一段char*赋值给list中的string。</li></ul><pre><code>seq.assign(b,e)             //迭代器seq.assign(il)              将元素替换为初始化列表il中的元素seq.assign(n,t)             //将元素替换为n个值为t的元素。</code></pre><ul><li>swap两个容器只是交换了两个容器的内部数据结构，但是array是交换了元素。</li></ul><pre><code>练习9.14list&lt;char *&gt; lc;vector&lt;string&gt; vs;vs.assign(lc.begin(),lc.end());</code></pre><h3 id="9-2-6-容器大小操作"><a href="#9-2-6-容器大小操作" class="headerlink" title="9.2.6 容器大小操作"></a>9.2.6 容器大小操作</h3><ul><li>size,emtpy,max_size</li></ul><h3 id="9-2-7-关系运算符"><a href="#9-2-7-关系运算符" class="headerlink" title="9.2.7 关系运算符"></a>9.2.7 关系运算符</h3><ul><li>关系运算的前提是两个容器类型必须相同，元素类型也要相同，其次是容器要支持该运算符的操作。</li></ul><h2 id="9-3-顺序容器操作"><a href="#9-3-顺序容器操作" class="headerlink" title="9.3 顺序容器操作"></a>9.3 顺序容器操作</h2><h3 id="9-3-1-向顺序容器中添加元素"><a href="#9-3-1-向顺序容器中添加元素" class="headerlink" title="9.3.1 向顺序容器中添加元素"></a>9.3.1 向顺序容器中添加元素</h3><pre><code>array不能改变容器的大小，所以不支持这些操作forward_list有自己版本的insert和emplaceforward_list不支持push_back和emplace_backvector和string不支持push_front和mepalce_frontc.push_back(t)                      //c.empalce_back(args)                //这个元素原地构造，不需要触发拷贝构造和转移构造c.push_front(t)     c.emplace_front(args)c.insert(p,t)                       //在p迭代器前插入t元素c.emplace(p,args)                   c.insert(p,n,t)                     //在p之前插入n个t元素c.insert(p,b,e)                     //p之前插入b和e级之间的元素c.insert(p,il)                      //il是元素值列表，插入在p之前</code></pre><ul><li>当我们使用一个对象初始化容器的时候，实际上放到容器中的是对象值的一个拷贝。</li><li>当我们传递给insert一对迭代器的时候，不能指向添加元素的目标元素。</li><li>emplace成员使用这些参数会在容器管理的内存空间中直接构造元素，根据元素的类型。而没有拷贝的操作。</li></ul><pre><code>练习9.18int main()&#123;    string str;    deque&lt;string&gt; ds;    while(cin&gt;&gt;str)    &#123;           ds.push_back(str);    &#125;    for(auto iter = ds.begin();iter!=ds.end();++iter)    &#123;        cout&lt;&lt;*iter&lt;&lt;endl;    &#125;&#125;</code></pre><pre><code>练习9.20int main()&#123;    list&lt;int&gt; li&#123;1,2,3,4,5,6,7,8&#125;;    deque&lt;int&gt; di1,di2;    for(auto iter = li.begin();iter!=li.end();++iter)    &#123;        if(*iter%2==0)             di1.push_back(*iter);        else            di2.push_back(*iter);    &#125;&#125;</code></pre><h3 id="9-3-2-访问元素"><a href="#9-3-2-访问元素" class="headerlink" title="9.3.2 访问元素"></a>9.3.2 访问元素</h3><pre><code>c.back()                //返回c中尾元素引用c.front()c[n]                    //返回下标为n的元素引用     vector,string,deque,arrayc.at(n)                 //返回下标为n的引用，如果越界，抛出异常。</code></pre><h3 id="9-3-3-删除元素"><a href="#9-3-3-删除元素" class="headerlink" title="9.3.3 删除元素"></a>9.3.3 删除元素</h3><pre><code>c.pop_back()            //删除尾元素，如果没有未定义c.pop_front()           //c.earse(p)c.earse(b,e)c.clear()</code></pre><h3 id="9-3-4-特殊的forward-list操作"><a href="#9-3-4-特殊的forward-list操作" class="headerlink" title="9.3.4 特殊的forward_list操作"></a>9.3.4 特殊的forward_list操作</h3><pre><code>forward_list中插入和删除元素的操作lst.before_begin()                  //返回指向链表首元素之前不存在的元素的迭代器，此迭代器不能解引用。lst.cbefore_begin()lst.insert_after(p,t)               //在迭代器p之后的位置插入元素，t是一个对象，n是数量lst.insert_after(p,n,t)lst.insert_after(p,b,e)lst.insert_after(p,il)empalce_after(p,args)lst.erase_after(p)                  //删除p指向位置之后的元素。或删除从b只有到e之间的元素lst.erase_after(b,e)</code></pre><ul><li><p>使用forward_list的时候我们关注两个迭代器一个是指向我们要处理的元素，一个指向其前驱</p><pre><code>forward_list&lt;int&gt; flst = &#123;0,1,2,3,4,5,6,7,8,9&#125;;auto prev = flst.before_begin();auto curr = flst.begin();while(curr!=flst.end())&#123;    if(*curr%2)        curr = flst.erase_after(prev);    else    &#123;        prev = curr;        ++curr;    &#125;&#125;</code></pre></li></ul><pre><code>练习 9.27int main()&#123;    forward_list&lt;int&gt; flst = &#123;0,1,2,3,4,5,6,7,8,9&#125;;    auto prev = flst.before_begin();    auto curr = flst.begin();    while(curr!=flst.end())    &#123;        if(*curr%2==1)            flst.erase_after(prev);        else        &#123;            prev = curr;            ++curr;        &#125;    &#125;&#125;</code></pre><pre><code>Exercises 9.28void insert(forward_list&lt;string&gt; &amp;flst,const string &amp;s1,const string &amp;s2)&#123;    auto prev = flst.before_begin();    bool isfind = false;    auto curr = flst.begin();    while(curr!=flst.end())    &#123;        if(*curr == s1)            flst.insert_after(curr,s2);            isfind = true;            break;        else            prev = curr;            ++curr;    &#125;    if(!isfind)        flst.insert_after(prev,s2);&#125;</code></pre><h3 id="9-3-5-改变容器大小"><a href="#9-3-5-改变容器大小" class="headerlink" title="9.3.5 改变容器大小"></a>9.3.5 改变容器大小</h3><ul><li>可以使用resize改变容器的大小，array不支持，如果当前大小大于所要求的大小，容器后面的元素会被删除，如果小于要求的大小，会添加元素到容器后部。<pre><code>c.resize(n)c.resize(n,t)如果resize缩小融侨i，迭代器、引用和指针都失效</code></pre></li></ul><pre><code>exercises 9.29将vec的元素增加到100，而且后面的元素默认为0，vec.resize(10)会将容器的元素减少到10个。</code></pre><pre><code>exercises 9.30要去元素必须是内置类型，或者是有默认构造函数的类类型</code></pre><h3 id="9-3-6-容器操纵可能使迭代器失效"><a href="#9-3-6-容器操纵可能使迭代器失效" class="headerlink" title="9.3.6 容器操纵可能使迭代器失效"></a>9.3.6 容器操纵可能使迭代器失效</h3><ul><li>向容器中添加元素或者从容器中删除元素可能会使得指向容器元素的指针、引用或迭代器失效。</li><li>我们在调用insert和erase后都会更新迭代器，在嗲用erase后不用递增迭代器，因为eraase返回的的迭代器已经指向序列中下一个元素，而调用insert会返回新插入元素的迭代器，而且insert操作是在迭代器之前插入元素。</li><li>必须在每次插入操作后重新调用end()，而不能再循环开始之前保存他的迭代器。</li></ul><pre><code>exercises 9.31list和forwoard_list不知道支持加减操作，所以只能多次调用++操作。</code></pre><h2 id="9-4-vector对象是如何增长的"><a href="#9-4-vector对象是如何增长的" class="headerlink" title="9.4 vector对象是如何增长的"></a>9.4 vector对象是如何增长的</h2><pre><code>only adapt to vector,string,dequec.shrint_to_fit()           //将capacity减小为size同样大小c.capacity()                //不重新分配空间的话，c可以保存多少元素c.reserve(n)                //分配至少能容纳n个元素的内存空间</code></pre><pre><code>exercises 9.35capacity是容器内存的大小，是当前容器在不改变内存的情况下最大可以容纳的元素的大小size是当前容器中的元素个数</code></pre><pre><code>exercises 9.36不可能</code></pre><pre><code>exercises 9.37list不需要一个连续的内存空间，array的内存空间是固定的</code></pre><pre><code>exercises 9.38 vector成倍的增长的</code></pre><pre><code>exercises 9.40256 384 1024512 768 10241000 1500 30001048 1572   1572*2</code></pre><h2 id="9-5-额外的string操作"><a href="#9-5-额外的string操作" class="headerlink" title="9.5 额外的string操作"></a>9.5 额外的string操作</h2><h3 id="9-5-1-构造string的其他方法"><a href="#9-5-1-构造string的其他方法" class="headerlink" title="9.5.1 构造string的其他方法"></a>9.5.1 构造string的其他方法</h3><pre><code>string s(cp,n)                  //s是cp指向数组中的前n个字符的拷贝string s(s2,pos2)               //s是string s2从下标pos2开始的字符的拷贝string s(s2,pos2,len2)s.substr(pos,n)                 //返回一个string，包含s从pos开始的n个字符的拷贝</code></pre><h3 id="9-5-2-改变string的其他方法"><a href="#9-5-2-改变string的其他方法" class="headerlink" title="9.5.2 改变string的其他方法"></a>9.5.2 改变string的其他方法</h3><pre><code>s.insert(pos,args)              //在pos之前插入args指定的字符，pso可以一个下标或者迭代器，接受下标的返回引用，接受迭代器返回迭代器s.erase(pos,len)                //删除pos开始的len个字符s.assign(args)                  //将s中的字符替换为args字符s.append(args)                  //将args追加到ss.replace(range,args)           //删除s中范围range内的字符，range可以是一个下标和一个长度，或者一对迭代器。args可以的形式是一下之一：append和assing可以使用所有形式str不能和s相同。迭代器b和e不能指向sstrstr,pos,lencp,lencpn,c                             //n个字符cb,e初始化列表replace和insert所允许的args依赖于range和pos是怎么定义的</code></pre><pre><code>exercises 9.43void changeString(string &amp;s,const string &amp;oldVal,const string &amp;newVal)&#123;    for(auto cur = s.begin();cur&lt;=s.end()-oldVal.size();)    &#123;        if(oldVal == string&#123;cur,cur+oldVal.size()&#125;)        &#123;            cur = s.earse(cur,cur+oldVal.size();            cur = s.insert(cur,newVal.begin(),newVal.end());            cur += newVal.size();        &#125;        else        &#123;            ++cur;            &#125;    &#125;       &#125;</code></pre><pre><code>exercises 9.44void changeString(string &amp;s,const string &amp;oldVal,const string &amp;newVal)&#123;    for(auto cur = s.begin();cur&lt;=s.end()-oldVal.size();)    &#123;        if(oldVal == string&#123;cur,cur+oldVal.size()&#125;)        &#123;            cur = cur.replace(cur,oldVal.size(),newVal);            cur += newValue.size();        &#125;        else        &#123;            ++cur;            &#125;    &#125;       &#125;</code></pre><pre><code>exercises 9.45auto add_pre_and_suffix(string &amp;name,const string &amp;pre,const string &amp;su)&#123;    name.insert(name.begin(),pre.cbegin(),pre.cend());    return name.append(su);&#125;</code></pre><pre><code>exercises 9.45auto add_pre_and_suffix(string &amp;name,const string &amp;pre,const string &amp;su)&#123;    name.insert(0,pre);    name.insert(name.size(),su);    return name;&#125;</code></pre><h3 id="9-5-3-string搜索操作"><a href="#9-5-3-string搜索操作" class="headerlink" title="9.5.3 string搜索操作"></a>9.5.3 string搜索操作</h3><ul><li>string搜索函数返回string::size_type值，表示匹配位置的下标，如果搜索失败返回一个string::npos的static成员，这个值初始化为1，所以代表了任意string最大可能的大小。</li></ul><pre><code>s.find(args)                //查找s中args第一次出现的位置s.rfind(args)               //查找s中args最后一次出现位置s.find_first_of(args)       //在s中查找ats中任意一个字符第一次出现位置s.find_last_of(args)        //最后一次出现位置s.find_first_not_of(args)   //在s中查找第一个不在args中的字符s.find_last_not_of(args)    //在s中查找最后一个不在args的字符args形式c,pos               //从位置pos查找cs2,pos              //从位置pos查找字符串s2cp,pos              //从位置pos查找c风格字符串cp,pos,n            //从位置pos查找cp前n个字符</code></pre><pre><code>exercise 9.47string number&#123;&quot;1234567689&quot;&#125;;string alphabet&#123;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#125;;string str&#123;&quot;ad2c3d7R4E6&quot;&#125;;for(int pos = 0;(pos = str.find_first_of(number,pos))!=string::npos;++pos)&#123;    cout&lt;&lt;str[pos]&lt;&lt;&quot; &quot;;&#125;cout&lt;&lt;endl;for(int pos = 0;(pos = str.find_first_of(alphabet,pos))!=string::npos;++pos)&#123;    cout&lt;&lt;str[pos]&lt;&lt;&quot; &quot;;&#125;for(int pos = 0;(pos = str.find_first_not_of(alphabet,pos))!=string::npos;++pos)&#123;    cout&lt;&lt;str[pos]&lt;&lt;&quot; &quot;;&#125;for(int pos = 0;(pos = str.find_first_not_of(number,pos))!=string::npos;++pos)&#123;    cout&lt;&lt;str[pos]&lt;&lt;&quot; &quot;;&#125;</code></pre><pre><code>exercises 9.48 string::npos</code></pre><h3 id="9-5-4-compare函数"><a href="#9-5-4-compare函数" class="headerlink" title="9.5.4 compare函数"></a>9.5.4 compare函数</h3><ul><li>compare有6个版本。compare用于字符串比较操作，类似于c标准库的strcmp函数。</li></ul><h3 id="9-5-5-数值转化"><a href="#9-5-5-数值转化" class="headerlink" title="9.5.5 数值转化"></a>9.5.5 数值转化</h3><pre><code>to_string(val)          //返回数值val的string表示stoi(s,p,b)             //返回s的起始子串的数值，b是转换所用的基数默认为10，p是size_t指针，，默认为0stol(s,p,b)stoul(s,p,b)stoll(s,p,b)stoull(s,p,b)stof(s,p)stod(s,p)stdld(s,p)</code></pre><pre><code>exercise 9.50int main()&#123;    int sum;    vector&lt;string&gt; vs&#123;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;&#125;;    for(auto &amp;temp:vs)        sum+= stoi(temp);    cout&lt;&lt;sum&lt;&lt;endl;&#125;</code></pre><pre><code>exercise 9.51class Data&#123;private:    unsinged year,month,day;public:    Data(const string &amp;s);&#125;;Data::Data(const string &amp;s)&#123;    unsigned tag;    unsigned format;    format = tag = 0;        if(s.find_first_of(&quot;/&quot;!=string::npos)        format = ox01;        if(s.find_first_of(&#39;,&#39;)&gt;=4&amp;&amp;s.find_first_of(&#39;,&#39;)!=string::npos)&#123;        format = ox10;    &#125;else&#123;        if(s.find_first_of(&#39; &#39;)&gt;=3&amp;&amp;s.find_first_of(&#39; &#39;)!=string::npos        &#123;            format = ox10;            tag = 1;        &#125;    &#125;        switch(format)    &#123;        case 0x01:            day = stoi(s.substr(0,s.find_first_of(&quot;/&quot;));            month = stoi(s.substr(s.find_first_of(&quot;/&quot;)+1,s.find_last_of(&quot;/&quot;)-s.find_first_of(&quot;/&quot;));            year = stoi(s.substr(s.find_last_of(&quot;/&quot;)+1,4));            break;        case 0x10:            if( s.find(&quot;Jan&quot;) &lt; s.size() )  month = 1;            if( s.find(&quot;Feb&quot;) &lt; s.size() )  month = 2;            if( s.find(&quot;Mar&quot;) &lt; s.size() )  month = 3;            if( s.find(&quot;Apr&quot;) &lt; s.size() )  month = 4;            if( s.find(&quot;May&quot;) &lt; s.size() )  month = 5;            if( s.find(&quot;Jun&quot;) &lt; s.size() )  month = 6;            if( s.find(&quot;Jul&quot;) &lt; s.size() )  month = 7;            if( s.find(&quot;Aug&quot;) &lt; s.size() )  month = 8;            if( s.find(&quot;Sep&quot;) &lt; s.size() )  month = 9;            if( s.find(&quot;Oct&quot;) &lt; s.size() )  month =10;            if( s.find(&quot;Nov&quot;) &lt; s.size() )  month =11;            if( s.find(&quot;Dec&quot;) &lt; s.size() )  month =12;                        char ch = &quot;,&quot;;            if(tag==1)            &#123;                ch = &quot; &quot;;            &#125;            day = stoi(s.substr(s.find_first_of(&quot;123456789&quot;),s.find_first_of(ch)-s.find_first_of(&quot;123456789&quot;));            year = stoi(s.substr(s.findfirst_of(ch)+1,4);            break;    &#125;&#125;</code></pre><h2 id="9-6-容器适配器"><a href="#9-6-容器适配器" class="headerlink" title="9.6 容器适配器"></a>9.6 容器适配器</h2><ul><li><p>除了顺序容器外，标准库还定义了三种容易适配器：stack、queue和priority_queue。</p></li><li><p>容器迭代器和函数都有适配器，适配器接受一种已有的类型，是他的行为看起来像另外一种类型。</p></li><li><p>默认情况下stack和queue是基于deque实现的，priority_queue是基于vector实现的。可以在创建容器的手将一个命的顺序容器作为第二个采参数，来重载默认容器类型。</p></li><li><p>栈适配器定义在头文件stack中，基本操作如下：</p><pre><code>s.pop()                 //删除栈顶元素，但不返回该元素值s.push(item)            //创建一个新的元素加入栈顶s.emplace(args)s.top()                 //returns,but does not remove,the top element on the stack</code></pre><pre><code>queue can use a list or vector as well ,priority_queue can use a dequeq.pop() removes,but dose not return q.front() return but does not removeq.back() vialid only for queueq.top() return ,but does not remove,valiad onlu for priority_queueq.push(item)        //create an element with value item or constructed fromn args at the end of queue or int its appropriate position in priority_queue.q.emplace(args)</code></pre></li><li><p>priority_queue允许我们为队列中的袁术那建立优先级，新加入的元素会排在所有优先级比他低的元素前面。</p></li></ul><pre><code>exercise 9.52 int main()&#123;    string expression&#123;&quot;thi is (pezy).&quot;&#125;;    bool bSeen = false;    stack&lt;char&gt; stk;    for(const auto &amp;s:expression)    &#123;        if(s==&#39;(&#39;)&#123;bSeen = true;continue;&#125;        else if(s==&#39;)&#39;) bSeen = false;        if(bSeen) stk.push(s);    &#125;&#125;</code></pre><h1 id="第10章-泛型算法"><a href="#第10章-泛型算法" class="headerlink" title="第10章 泛型算法"></a>第10章 泛型算法</h1><h2 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h2><ul><li>一般算法并不直接操作容器，而是遍历两个迭代器指定范围进行操作。</li><li>迭代器参数令算法不依赖特定容器，但是依赖于元素类型操作。</li><li>泛型算法本身不会执行容器的操作，算法永远不会改变底层容器的大小。算法可能改变容器保存元素的值，但是不会直接添加或者删除元素。</li></ul><pre><code>exercise 1int mian()&#123;    std::vecotr&lt;int&gt; v = &#123;1,2,3,4,5,6,7,8,9&#125;;    cout&lt;&lt;std::count(v.cbegin(),v.cend(),2)&lt;&lt;endl;    list&lt;string&gt; l = &#123;&quot;aa&quot;,&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;&#125;;    count(l.cbegin(),l.cend(),&quot;aa&quot;);&#125;</code></pre><h2 id="10-2-初识泛型算法"><a href="#10-2-初识泛型算法" class="headerlink" title="10.2 初识泛型算法"></a>10.2 初识泛型算法</h2><h3 id="10-2-1-只读算法"><a href="#10-2-1-只读算法" class="headerlink" title="10.2.1 只读算法"></a>10.2.1 只读算法</h3><pre><code>find()          count()accumulate()        //计算一个序列的和，第三个参数是和的初值(决定加法运算类型和返回值类型)equal()             //确定连个序列是否相同，只接受单一迭代器表示第二个操作序列的算法假定第二个序列至少和以第一个序列一样长。</code></pre><pre><code>exercise 3int  main()&#123;    vector&lt;int&gt; v(10,1);    int sum ;    sum = accumulate(v.cbegin(),c.cend(),0);&#125;</code></pre><pre><code>exercise 5for such case ,std::equal is going to compare the adderess value than the string value ,so the resultis not same as std::string .</code></pre><h3 id="10-2-2-写容器元素的算法"><a href="#10-2-2-写容器元素的算法" class="headerlink" title="10.2.2 写容器元素的算法"></a>10.2.2 写容器元素的算法</h3><ul><li>一个写入操作需要保证容器的大小大于要写入元素的大小。</li><li>fill函数接受两个迭代器表示序列范围，还接受一个值作为第三个参数，将给定范围内的每个值赋值<pre><code>//rest each element to 0fill(vec.begin(),vec.end(),0);</code></pre></li><li>fill_n函数接受单个迭代器参数一个计数值和一个值，将给定值赋予迭代器指定位置开始的指定个元素<pre><code>//reset all the element of vec to 0fill_n(vec.begin(),vec.size(),0)</code></pre></li><li>插入迭代器是一种向容器中添加元素的迭代器。插入迭代器接受一个指向容器的引用，返回与该容器绑定的插入迭代器，通过迭代器赋值，将元素添加到容器中。<pre><code>vector&lt;int&gt; vec;auto it = back_intserter(vec);*it = 42;fill_n(back_inserter(vec),10,0);</code></pre></li><li>copy函数接受三个迭代器参数，1,2指定输入序列，3指定目标序列的起始位置，返回目标位置迭代器递增后的位置。<pre><code>int a1[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;int a2[sizeof(a1)/sizeof(*a1)];auto ret = copy(begin(a1),end(a1),a2);</code></pre></li><li>replace 读入一个序列将，所有的给定元素改为另一值。<pre><code>//将所有0改为42repalce(ilst.begin().ilst.end(),0,42)replace_copy(ilst.begin(),ilst.end(),back_inserter(ivec),0,42);//不改变ilst，ivec包含ilst的一份拷贝。</code></pre></li></ul><pre><code>exercise 6vector&lt;int&gt; vec&#123;1,2,3&#125;;fill_n(vec.begin(),vec.end(),0);</code></pre><pre><code>exercise 7(a) flasecopy(lst.cbegin(),lst.cend(),back_inserter(vec));</code></pre><pre><code>exercise 8inserter like back_inserters is part of &lt;iterator&gt; rathon than &lt;algorithm&gt;</code></pre><h3 id="10-2-3-重排容器元素算法"><a href="#10-2-3-重排容器元素算法" class="headerlink" title="10.2.3 重排容器元素算法"></a>10.2.3 重排容器元素算法</h3><ul><li>sort() 算法接受两个迭代器表示要排序的元素范围。</li><li>unique() 返回迭代器指向最后一个不重复元素之后的位置。</li></ul><pre><code>exercise 9void elimDumps(vector&lt;string&gt; &amp;vs)&#123;    sort(vs.cbegin(),vs.cend());    for(auto const &amp;temp:vs)        cout&lt;&lt;temp;    cout&lt;&lt;endl;    auto iter = unique(vs.cbegin(),vs.cend());    vs.erase(iter,vs.end());&#125;</code></pre><pre><code>exercise 10cause the library algorithm operator on iterator,not contains,thus,an algorithm cannot add or remove element</code></pre><h2 id="10-3-定制操作"><a href="#10-3-定制操作" class="headerlink" title="10.3 定制操作"></a>10.3 定制操作</h2><h3 id="10-3-1-向算法传递函数"><a href="#10-3-1-向算法传递函数" class="headerlink" title="10.3.1 向算法传递函数"></a>10.3.1 向算法传递函数</h3><ul><li>谓词是一个可以调用的表达式，其返回结果是一个能用作条件的值。</li><li>谓词可以是一元谓词或者二元谓词，sort接受的是二元谓词<pre><code>bool isShorter(const string &amp;s1,const string &amp;s2)&#123;    return s1.size()&lt;s2.size();&#125;sort(words.begin(),words.end().isShorter);</code></pre></li><li>stable_sort可以维持输入序列中相等元素的原有位置。</li></ul><pre><code>exercise 12 inline bool compareIsbn(const Sales_data &amp;sdl,const Sales_data &amp;sdl2)&#123;    return sdl.isbn().size()&lt;sdl2.isbn().size();&#125;int mian()&#123;    std::sort(v.begin(),v.end(),compareIsbn);&#125;</code></pre><pre><code>inline bool ismaxfive(const string&amp; str)&#123;    return str.size()&gt;=5;&#125;int main()&#123;    vector&lt;string&gt; vs = &#123;&quot;adfsad&quot;,&quot;fafdsaf&quot;,&quot;fdsf&quot;&#125;;    auto iter = paretition(vs.begin(),vs.end(),ismaxfive);    for(auto iter1 = vs.begin();iter1!=iter;++iter1)        cout&lt;&lt;*iter1&lt;&lt;endl;&#125;</code></pre><h3 id="10-3-2-lambda表达式"><a href="#10-3-2-lambda表达式" class="headerlink" title="10.3.2 lambda表达式"></a>10.3.2 lambda表达式</h3><ul><li>对于一个对象或者表达式，可以对其使用(),则称它为可调用对象。可以向算法传递任何类别的可调用对象。</li><li>一个lambda表达式表示一个可调用代码单元，类似未命名的内联函数，但可以定义在函数内部。<pre><code>[capture list] (parameter list) -&gt; return type&#123;function body&#125;capture list是一个lambda所在函数中定义的局部变量的列表。通常为空其他和普通函数一样。我们可以忽略参数列表和返回值。但是必须包含捕获列表和函数体。</code></pre></li><li>lambda可以使用其所在函数的局部变量，但必须先将其包含在捕获列表中，捕获列表只能用于局部非static变量。lambda可以直接使用局部static变量和所在函数之外声明的名字<pre><code>//获取一个迭代器，指向第一个满足size()&gt;sz的元素。auto wc = find_if(words.begin(),words.end(),                    [sz](const string &amp;a)&#123;return a.size()&gt;=sz;&#125;);</code></pre></li><li>for_eack函数接受一个输入序列和一个可调用对象，他对输入序列的每一个元素调用次对象。<pre><code>for_each(wc,words.end(),            [](const string &amp;s)&#123;cout&lt;&lt;s&lt;&lt;&quot; &quot;;&#125;);</code></pre></li></ul><pre><code>exercise 14[](int a,int b)&#123;return a+b;&#125;int main()&#123;    int a = 2;    [a](int b)&#123;return a+b;&#125;&#125;</code></pre><pre><code>exercise 15std::sort(v.begin(),v.end(),            [](const string &amp;str,const string &amp; str2)&#123;return str.size()&lt;str2.size();&#125;);</code></pre><h3 id="10-3-3-lambda捕获和返回"><a href="#10-3-3-lambda捕获和返回" class="headerlink" title="10.3.3 lambda捕获和返回"></a>10.3.3 lambda捕获和返回</h3><ul><li>当向一个函数传递一个lambda的时候，同时定义了一个新类型和该类型的一个对象。传递的参数就是该编译器生成类类型的未命名对象。</li><li>别lambda捕获的变量值是在lambda创建时拷贝，而不是在调用的时候拷贝<pre><code>size_t v1 = 42;auto f = [v1] &#123;return v1;&#125;;v1 = 0;auto j = f();       //j为42，f保存了我们创建v1时的拷贝。</code></pre></li><li>lambda可以以引用的形式捕获变量，但是必须抱枕lambda执行时变量存在。</li><li>可以让编译器根据lambda隐式捕获函数变量。方法是在捕获列表中写一个&amp;或者&#x3D;符号。</li><li>可以混用显示和隐式捕获。显示捕获的变量使用和隐式捕获不同的方式。<pre><code>[&amp;,inenfitier_list]后面的变量采用显示值捕获[=,identifier_list]identifier_list中的变量采用显示的引用捕获，其他采用隐式值捕获。</code></pre></li><li>默认情况下，对值捕获方式变量，lambda不能修改器值，如果希望修改，在参数列表后加mutable<pre><code>size_t v1 = 42;auto f = [v1] () mutawble&#123;return ++v1;&#125;;v1 = 0;auto j = f();           //j = 42;</code></pre></li><li>transform函数接受三个迭代器参数和一个可调用对象，前两个迭代器指定输入序列，第三个迭代器表示目的位置。对输入序列中的没个对象调用可调用对象，将写入到目的位置。<pre><code>transform(vi.begin(),vi.end(),vi.begin(),            [](int i)-&gt;int&#123;if(i&lt;0)return -1;else return i;&#125;);</code></pre></li></ul><pre><code>exercise 20int num = count_if(vec.begin(),vec.end(),                        [](const string &amp;s)&#123;return s.size()&gt;6&#125;);</code></pre><pre><code>int mian()&#123;    int a  = 10;    [&amp;a]()&#123;return i&gt;0?!--i:!i;&#125;;&#125;</code></pre><h3 id="10-3-4-参数绑定"><a href="#10-3-4-参数绑定" class="headerlink" title="10.3.4 参数绑定"></a>10.3.4 参数绑定</h3><ul><li>**问题提出:**为了解决用函数调用的时候如果只接受一个谓词，不能像形参传递一个参数的问题。<pre><code>bool check_size(const string &amp;s,string::size_type sz)&#123;    return s.size() &gt;= sz;&#125;不能将这个函数作为find_if的一个参数。因为find_if只接受一个一元谓词。</code></pre></li><li>**解决方法:**使用一个新的名为bind的标准库函数，定义在functional中，bind是一个函数适配器，接受一个可调用对象，生成一个新的可调用对象适应元对象的参数列表。<pre><code>auto newCallable = bind(callable,arg_list);//check6是一个可调用对象，接受一个string类型参数，并用次string和6来调用check_sizeauto check6 = bind(check_size,_1,6);//bind 调用只接受一个占位符，表示check6值接受一个参数，如果调用check6需要传入一个参数const string&amp;，然后改参数会传给check_sizeauto wc = find_if(words.begin(),word.end()                    bind(check_size,_1,sz));</code></pre></li><li>名字_n定义在一个名为placeholders的命名空间中，该空间位域std中。</li><li>bind函数可以调整给定可调用对象的参数顺序。<pre><code>auto g = bind(f,a,b,_2,c,_1);g(X,Y);映射为f(a,b,Y,c,X);</code></pre></li><li>默认情况下bind函数的非占位元素被拷贝到bind返回的可调用对象中。</li><li>如果希望传递给bind一个对象而不拷贝他，必须使用标准库的ref()函数，该函数返回一个对象，包含给定的引用。cref()返回的是const引用类。</li></ul><pre><code>exercise 22bool isLesserRoEqualTo6(const string &amp;s,int num)&#123;    return s.size()&lt;=num;&#125;int mian()&#123;    vector&lt;string&gt; vs;    count_if(vs.begin(),vs.end()                bind(isLessRoEqualTo6,_1,6);&#125;</code></pre><pre><code>exercise 23assuming the function to be bound have n parameters,bind take n+1 parameters.the additional one is for the function to be bound itself.</code></pre><h2 id="10-4-再探迭代器"><a href="#10-4-再探迭代器" class="headerlink" title="10.4 再探迭代器"></a>10.4 再探迭代器</h2><h3 id="10-4-1-插入迭代器"><a href="#10-4-1-插入迭代器" class="headerlink" title="10.4.1 插入迭代器"></a>10.4.1 插入迭代器</h3><ul><li>插入迭代器是一种迭代器适配器。接受一个容器生成一个迭代器，能向给定容器添加元素。</li><li>插入迭代器类型(差异在于元素插入位置)<ul><li>back_inserter :创建一个使用push_back的迭代器</li><li>front_inserter:创建一个使用push_front的迭代器</li><li>inserter：创建一个使用insert的迭代器，该函数第二个参数，该参数是一个指向给定容器的迭代器，插入到元素之前。</li></ul></li><li>使用inserter插入器迭代器的位置一直都没有变，所有是1234。</li></ul><pre><code>exercise 10.26 back_insert use push_back front_inserter use push_front inserter uses insert</code></pre><pre><code>exercise 10.27int main()&#123;    vector&lt;int&gt; vec &#123;1,2,3,4,5,6,7,8,4,3&#125;;    list&lt;int&gt; li;    unique_copy(vec.begin(),vec.end(),back_inserter(li));&#125;</code></pre><pre><code>exercise 10.28int main()&#123;    vector&lt;int&gt; vec&#123;1,2,3,4,5,6,7,8,9&#125;;    vector&lt;int&gt; vec1,vec2,vec3;    copy(vec.begin(),vec.end(),back_inserter(vec1));    //123456789    copy(vec.begin(),vec.end(),front_inserter(vec1));   //987654321    copy(vec.begin(),vec.end(),inserter(vec1,vec1.begin()));    //123456789&#125;</code></pre><h3 id="10-4-2-iostream-迭代器"><a href="#10-4-2-iostream-迭代器" class="headerlink" title="10.4.2 iostream 迭代器"></a>10.4.2 iostream 迭代器</h3><ul><li>istream_iterator从输入流读取数据，ostream_iterator向输出流写入数据。这些迭代器将流当做特定类型的元素数列理解。</li><li>创建一个流迭代器，必须制定迭代器将要读写的对象类型。如果默认初始化，创建的是尾后迭代器<pre><code>istrem_iterator&lt;int&gt; int_it(cin);           //从cin读取intistream_iterator&lt;int&gt; int_eof;              //尾后迭代器ifstream in(&quot;afile&quot;);istream_iterator&lt;string&gt; str_it(in);        //从afile读取字符串</code></pre><pre><code>//从标准输入读取数据存入vectoristream_iterator&lt;int&gt; int_it(cin);istream_iterator&lt;int&gt; int_eof;while(int_it!=int_eof)&#123;    vec.push_back(*in_it++);&#125;</code></pre></li><li>将一个istream_iterator绑定到一个流中，标准库不保证迭代器立即从流读取数据，但保证第一次解引用迭代器之前那个从流中读取数据的操作引进完成了。</li><li>定义ostream_iterator对象，必须将其绑定包一个指定是的输出流，不允许定义空的或表示尾后位置的ostream_iterator</li><li>*和++运算符实际不会对ostream_iterator对象做任何操作，但是建议代码写法和其他迭代器保持一致。</li><li>创建ostream_iterator可以提供第二个参数，表示每个元素输出都会打印该字符串。<pre><code>ostream_iterator&lt;int&gt; out_iter(cout,&quot; &quot;);for(auto e:vec)&#123;    *out_iter++ = e;    out_iter = e;//也可以这样写&#125;cout&lt;&lt;endl;</code></pre></li></ul><pre><code>exercise 29int main()&#123;    vector&lt;string&gt; vec;    ifstream file(&quot;data&quot;);    istream_iterator&lt;string&gt; str_in(file);    istream_iterator&lt;string&gt; str_eof;    while(str_in!=str_eof)    &#123;        vec.push(*str_in++);    &#125;        std::copy(str_in,str_eof,back_inserter(vec));    copy(vec.begin(),vec.end(),std::ostream_iterator&lt;string&gt;(std::cout,&quot;\n&quot;));&#125;</code></pre><pre><code>exiercise 30int main()&#123;    vector&lt;int&gt; vec&#123;1,2,3,4,5,6,7,8,9&#125;;    vector&lt;int&gt; vec(std::istream_iterator&lt;int&gt;(std::cin),std::istream_iterator&lt;int&gt;());    sort(vec.begin(),vec.end());    std::copy(vec.cbegin(),vec.cend(),std::ostream_iterator&lt;int&gt;(std::cout,&quot; &quot;));&#125;</code></pre><pre><code>exercise 33void write(const string &amp;inputfile,const string &amp;outfile1,const string &amp;outfile2)&#123;    vector&lt;int&gt; vec(std::istream_iterator&lt;int&gt;(istream(inpufile)),std::istream_iterator&lt;int&gt;());    ostream_iterator&lt;int&gt; out_odd(ostream(outfile1)),out_even(ostream(outfile2));    for_each(vec.begin(),vec.end()                [&amp;out_odd,&amp;out_even](const int i)&#123;*(i&amp;0x1?out_odd:out_even)++;&#125;;&#125;</code></pre><h3 id="10-4-3-反向迭代器"><a href="#10-4-3-反向迭代器" class="headerlink" title="10.4.3 反向迭代器"></a>10.4.3 反向迭代器</h3><ul><li>反向迭代器在容器中从尾元素反向移动迭代器。递增一个迭代器会移动到前一个元素。</li><li>调用反向迭代器的base函数可以获得其对应的普通迭代器。</li><li>反向迭代器表示的是元素的范围，而这些范围是不对称的，用普通迭代器初始化反向迭代器，结果迭代器与原来迭代器指向的不是相同的元素。</li></ul><pre><code>exercise 34-37int main()&#123;    vector&lt;int&gt; vec&#123;2,3,1&#125;;        //10.34    for(auto it = vec.crbegin();it!=vec.crend();++it)    &#123;        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;        //10.35    for(auto it = vec.cbegin(),it!=vec.end();++it)        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;    cout&lt;&lt;endl;        //10.36    list&lt;int&gt; li&#123;1,2,3,4,0,2,6,0,6&#125;;    find(li.crbegin(),li.crend(),0);    &#125;</code></pre><h2 id="10-5-泛型算法结构"><a href="#10-5-泛型算法结构" class="headerlink" title="10.5 泛型算法结构"></a>10.5 泛型算法结构</h2><pre><code>---------------迭代器类型--------------------输入迭代器                  只读，不写；单遍扫描，只能递增输出迭代器                  只写，不读；单遍扫描，只能递增前向迭代器                  可读写；多遍扫描，只能递增双向迭代器                  可读写；多遍扫描，递增递减随机访问迭代器              可读写；多遍扫描，支持全面迭代器运算</code></pre><h3 id="10-5-1-五类迭代器"><a href="#10-5-1-五类迭代器" class="headerlink" title="10.5.1 五类迭代器"></a>10.5.1 五类迭代器</h3><h3 id="10-5-2-算法形参模式"><a href="#10-5-2-算法形参模式" class="headerlink" title="10.5.2 算法形参模式"></a>10.5.2 算法形参模式</h3><ul><li>一般算法形式<pre><code>alg(beg,end,other args);alg(beg,end，dest,other args)alg(beg,end,beg2,other args)alg(beg,end,beg2,end2,othe args)</code></pre></li></ul><h3 id="10-5-3-算法命名规范"><a href="#10-5-3-算法命名规范" class="headerlink" title="10.5.3 算法命名规范"></a>10.5.3 算法命名规范</h3><ul><li>一些算法使用重载形式传递谓词<pre><code>unique(beg,end);    //使用==比较元素unique(beg,end,comp)//使用comp比较元素</code></pre></li><li>接受谓语参数的算法那都有_if后缀<pre><code>find(beg,end,val);          //查找范围内val第一次出现位置find_if(beg,end,pred);      //查找第一个另pred为真的元</code></pre></li><li>区分拷贝元素的版本和不拷贝元素的版本用_copy<pre><code>reveser(beg,end);reveser_copy(beg,end,dest);     //将元按照逆序拷贝到dest</code></pre></li></ul><pre><code>exercise 41将beg-end中的元素替换为old_val-new_val中的元素判断new_val是否符合pred条件符合替换范围内元素copy the new_element which is old_elements in the input range into destcopy the new_element which pred is true in the input range into dest</code></pre><h3 id="10-6-特定容器算法"><a href="#10-6-特定容器算法" class="headerlink" title="10.6 特定容器算法"></a>10.6 特定容器算法</h3><ul><li>对list和forward_list，应该优先使用成员函数版本的算法，而不是通用算法。<pre><code>lst.merge(lst2)                 //将链表合并，但是都是必须排序过的lst.merge(lst2,comp)lst.remove(val)lst.remove_if(pred)lst.reverse()lst.sort()lst.sort(comp)lst.unique()lst.unique(pred)lst.splice(args)                //将一个链表连接到另一个链表中flst.splice_after(args)</code></pre></li></ul><h1 id="第11章-关联容器"><a href="#第11章-关联容器" class="headerlink" title="第11章 关联容器"></a>第11章 关联容器</h1><ul><li>标准库提供8个关联容器，可以体现在三个维度上<ul><li>是一个set或者是一个map，map是关联数组：保存关键字-值对，set关键字即值，只保存关键字的容器</li><li>要求不重复的关键字，或者要求可重复的关键字，可重复的关键字都是multi。</li><li>按顺序保存，或者无顺序保存。无顺序保存的以unordered开头。</li></ul></li></ul><h2 id="11-1-使用关联容器"><a href="#11-1-使用关联容器" class="headerlink" title="11.1 使用关联容器"></a>11.1 使用关联容器</h2><ul><li>map类型通常被称为关联数组</li><li>从map中提取一个元素的时候回得到一个pair类型的对象。pair是一个模板类型。保存两个名为first和second的共有数据成员。map所使用的pair用first成员保存关键字。用second成员保存对应的值。<pre><code>map&lt;string,size_t&gt; word_count;string word;while(cin&gt;&gt;word)&#123;    ++word_count[word];&#125;for(const auto &amp; w:word_count)    cout&lt;&lt;w.first&lt;&lt;&quot; &quot;&lt;&lt;w.second&lt;&lt;endl;</code></pre></li><li>set类型的find成员返回一个迭代器，如果给定关键字在set中，迭代器指向该关键字，否则返回尾后迭代器。</li></ul><pre><code>exercise 11.1map is associative container whereas vector is sequence container</code></pre><pre><code>exercise 11.2 any time when a doubly-linjked list is required.vector:anytime when a dynamic array is required.deque:application of the deque is storing a web broser&#39;s historymap:dictionaryset: when to keep element sorted and unique</code></pre><h2 id="11-2-关联容器概述"><a href="#11-2-关联容器概述" class="headerlink" title="11.2 关联容器概述"></a>11.2 关联容器概述</h2><h3 id="11-2-1-定义关联容器"><a href="#11-2-1-定义关联容器" class="headerlink" title="11.2.1 定义关联容器"></a>11.2.1 定义关联容器</h3><ul><li>定义map时，必须指定关键字类型和值类型。定义set是纸需要指定关键字类型</li><li>初始化map，提供的每个键值对用{}包围<pre><code>map&lt;string,size_t&gt;word_coumnt;set&lt;string&gt; exclude  = &#123;&quot;the&quot;,&quot;but&quot;,&quot;and&quot;&#125;;map&lt;string,string&gt; authors =&#123;    &#123;&quot;a&quot;,&quot;1&quot;&#125;,    &#123;&quot;b&quot;,&quot;2&quot;&#125;,    &#123;&quot;c&quot;,&quot;3&quot;&#125;&#125;;</code></pre></li><li>map和set的关键字必须唯一，multimap和multiset没有这限制。</li></ul><pre><code>exercise 11.5 set contain only the key,while in map there is an associated value.</code></pre><pre><code>exercise 11.6两者都可以保存元素集合，如果需要顺序访问这些元素，或者按照位置访问元素，可以使用list如果需要快速判定是否有元素等于给定的值，用set比较好。</code></pre><pre><code>exercise 11.7map&lt;string,vector&lt;string&gt;&gt; family;</code></pre><h3 id="11-2-2-关键字类型的要求"><a href="#11-2-2-关键字类型的要求" class="headerlink" title="11.2.2 关键字类型的要求"></a>11.2.2 关键字类型的要求</h3><ul><li>对于有序关联容器，关键字类型必须定义元素的比较方法。</li><li>用来组织容器元素的操作类型也是该容器类型的一部分，如果需要使用自定义的比较类型，则必须在定义关联容器类型是提供此操作的类型。操作类型在尖括号中跟着元素类型给出<pre><code>bool compareIsbn(const Sales_data &amp;lhs,const Sales_data &amp;rhs)&#123;    return lhs.isbn()&lt;rhs.isbn();&#125;multiset&lt;Sales_data,decltype(compareIsbn)*&gt; bookstore(compareIsbn);</code></pre></li></ul><pre><code>exercise 9map&lt;string,list&lt;size_t&gt;&gt; m;</code></pre><pre><code>exercise 10vector支持，因为vector支持&lt;操作list不支持，list不支持&lt;操作</code></pre><pre><code>typedef bool(*Less)(Sales_data const&amp;,Sales_data const &amp;);std::multiset&lt;Sales_data,Less&gt; bookstore(less);</code></pre><h3 id="11-2-3-pair类型"><a href="#11-2-3-pair类型" class="headerlink" title="11.2.3 pair类型"></a>11.2.3 pair类型</h3><ul><li>pair定义在utility中，一个pair可以保存两个数据成员，分别为first和second。pair的默认构造函数对数据成员进行值初始化。</li></ul><pre><code>--------------------------------pair上的操作----------------------------pair&lt;T1,T2&gt; p;pair&lt;T1,T2&gt; p(v1,v2);pair&lt;T1,T2&gt; p = &#123;v1,v2&#125;;make_pair(v1,v2);               //返回一个用v1和v2初始化的pairp.firstp.secondp1 relop p2                     //按字典排序关系运算符p1  == p2p1!=p2</code></pre><pre><code>exercise 11.12int main()&#123;    string str;    int i;    vector&lt;pair&lt;string,int&gt;&gt; vec;    while(cin&gt;&gt;str,cin&gt;&gt;i)    &#123;        pair&lt;string,int&gt; p(cin&gt;&gt;str,cin&gt;&gt;i);        vec.push_back(p);    &#125;        &#125;</code></pre><h2 id="11-3-关联容器操作"><a href="#11-3-关联容器操作" class="headerlink" title="11.3 关联容器操作"></a>11.3 关联容器操作</h2><pre><code>-------------------------关联容器额外的类型别名------------------------key_type                此容器类型的关键字类型mapped_type             每个关键字关联的类型：只适用于mapvalue_type              对于set和key_type相同，对于map为pair&lt;const key_type,mapped_type&gt;</code></pre><pre><code>map&lt;string,int&gt;::value_type v5;     //v5为pair&lt;const string,int&gt;</code></pre><h3 id="11-3-1-关联容器迭代器"><a href="#11-3-1-关联容器迭代器" class="headerlink" title="11.3.1 关联容器迭代器"></a>11.3.1 关联容器迭代器</h3><ul><li>当解引用一个关联容器迭代器的时候我们会得到一个类型为容器的value_type的值的引用。</li><li>虽然set同时定义了iterator和const_iterator，但是两种迭代器都只允许度访问set中的元素。</li><li>通常不对关联容器使用泛型算法</li></ul><pre><code>exercise 11.15vector&lt;int&gt; int pair&lt;const int,vector&lt;int&gt;&gt;</code></pre><pre><code>exercise 11.16map&lt;int,std::string&gt; map;map[25] = &quot;alan&quot;;map&lt;int,std::string&gt;::iterator it = map.begin();it-&gt;second = &quot;wang&quot;;</code></pre><pre><code>using compareType = bool(*)(const Sales_data &amp;lhs,const Sales_dat &amp;rhs);std::multiset&lt;Sales_data,compareType&gt; bookstore(compareIsbn);std::multiset&lt;Sales_data,compareType&gt;::iterator c_it = bookstore.begin();</code></pre><h3 id="11-3-2-添加元素"><a href="#11-3-2-添加元素" class="headerlink" title="11.3.2 添加元素"></a>11.3.2 添加元素</h3><ul><li>使用insert成员向容器插入元素，如果插入已存在元素无影响。</li><li>insert有两个版本一个接受一对迭代器，或者是一个初始化列表。</li><li>向一个map进行insert操作，元素的类型需要时pair类型。创建一个pair最简单的方法是使用花括号初始化。</li><li>关于insert的返回值，返回一个pair，如果插入成功，pair-&gt;first是一个迭代器指向具有关键字类型的元素，second为ture，如果已经存在second为false。</li><li>对于允许重复关键字的容器，接受单个元素的insert操作返回一个指向新元素的迭代器。</li></ul><pre><code>exercise 11.20#include&lt;iostream&gt;#include&lt;map&gt;#inlcude&lt;string&gt;int mian()&#123;    std::map&lt;std::string,size_t&gt; counts;    for(string word;cin&gt;&gt;word;)    &#123;        auto result = couts.insert(&#123;word,1&#125;);        if(!result.second)            ++result.first-&gt;second;    &#125;&#125;</code></pre><pre><code>exercise 11.22pair&lt;map&lt;string,vector&lt;int&gt;&gt;::iterator,bool&gt; ret = map.insert(&#123;string,int&#125;);</code></pre><h3 id="11-3-3-删除元素"><a href="#11-3-3-删除元素" class="headerlink" title="11.3.3 删除元素"></a>11.3.3 删除元素</h3><ul><li>erase有三个版本的，可以提供一个迭代器删除一个元素，可以通过一对迭代器删除一个范围的元素，也可以通过一个关键字删除元素。最后一个版本可以返回删除元素的数量。</li></ul><h3 id="11-3-4-map的下标操作"><a href="#11-3-4-map的下标操作" class="headerlink" title="11.3.4 map的下标操作"></a>11.3.4 map的下标操作</h3><ul><li>map下标操作符接受一个关键字获取与关键字相互关联的值。如果关键字不在容器中。会创建一个元素并插入到map中。</li><li>at函数访问关键字为k的元素，带参数检查，如果k不在c中，抛出一个异常。</li><li>当对一个map进行下标操作的时候回获得一个mapped_type对象。</li></ul><pre><code>exercise 11.24 add a key-value pair&#123;0,1&#125; into mapexervcise 11.25 it&#39;s try to deference an item out of range </code></pre><h3 id="11-3-5-访问元素"><a href="#11-3-5-访问元素" class="headerlink" title="11.3.5 访问元素"></a>11.3.5 访问元素</h3><pre><code>find(k)                    返回一个迭代器，指向第一个关键字为k的元素，如果没有指向尾后迭代器count(k)                   返回关键字等于k的元素的数量lower_bound(k)             返回一个迭代器，指向第一个关键字不小于k的元素upper_bound(k)             返回一个迭代器，执行第一个关键字大于k的元素equal_range(k)             返回一个迭代器pair，表示关键字等于k的范围</code></pre><ul><li>使用find代替下标操作的情况：我们指向查找一个元素是否在map中，如果不在也不想插入。</li><li>在multimap和multiset查找元素的方法，具有相同关键字的元素是相邻的<ul><li>使用count获得总元素数目，然后调用迭代器获得第一个元素，依次获得即可。</li><li>使用lower_bound和upper_bound.</li><li>使用equal_range</li></ul></li></ul><pre><code>exercise 11.27i would use count to deal with multimap and multisetuse find to deal with map and setexercise 11.28std::map&lt;std::string,vector&lt;int&gt;&gt; map;auto iter = map.find(&quot;a&quot;);exercise 11.29lower_bound和upper_bound返回一样的迭代器，构成一个空的范围。如果给定关键字比所有关键字都大，返回尾后迭代器。equal_range返回一个正确插入的位置的迭代器pair。exercise 11.30pos a pair ; pos.first: a iterator refering to the first element with the matching keypos.first-&gt;second:the value of the element with the matching key</code></pre><h2 id="11-4-无序容器"><a href="#11-4-无序容器" class="headerlink" title="11.4 无序容器"></a>11.4 无序容器</h2><ul><li>无序同期在存储上组织为一组桶，无序容器使用哈希函数将元素映射到桶，为了访问一个元素，容器先计算元素的哈希值，会搜索出在那个桶中。</li></ul><pre><code>-----------------------无序容器管理操作------------------------c.bucket_count()           //正在使用的桶数目                              c.max_bucket_count()       //容器能容纳最多桶数目      c.bucket_size(n)           //第n个桶中元素个数c.bucket(k)                //关键字k在那个桶中local_iterator             //访问同种元素的迭代器类型              const_local_iterator       //                      c.begin(n)/c.end(n)        //                  c.cbegin(n)c.cend(n)       //                      c.load_factor()            //每个桶中的平均元素数量c.max_load_factor()        //c试图维护的平均桶大小c.rehash()                 //          c.reserve(n)               //              </code></pre><ul><li>默认情况下，无序容器使用关键字类型&#x3D;&#x3D;运算符比较元素。还使用hash<key_type>类型对象生成每个元素的哈希值。</li></ul><h1 id="第12章-动态内存"><a href="#第12章-动态内存" class="headerlink" title="第12章 动态内存"></a>第12章 动态内存</h1><h2 id="12-1-动态内存和智能指针"><a href="#12-1-动态内存和智能指针" class="headerlink" title="12.1 动态内存和智能指针"></a>12.1 动态内存和智能指针</h2><ul><li>shared_ptr允许多个指针同时指向一个对象，unique_ptr独占所指对象。标准库还定义了一种名为weak_ptr的伴随类，是一种弱引用，指向shared_ptr所管理的对象。三个类型都定义在memory中。</li></ul><h3 id="12-1-1-shared-ptr类"><a href="#12-1-1-shared-ptr类" class="headerlink" title="12.1.1 shared_ptr类"></a>12.1.1 shared_ptr类</h3><ul><li>智能指针也是模板，需要给出类型，默认初始化是一个空指针。</li></ul><pre><code>------------------shared_ptr和unique_ptr支持操作------------------shared_ptr&lt;T&gt; sp;unique_ptr&lt;T&gt; up;p*pp-&gt;memp.get()                 //返回p中保存的指针swap(p,q)p.swap(q)-------------shared_ptr独有操作---------------------------make_shared&lt;T&gt;(args)            //返回一个shared_ptr,指向一个动态分配的类型t的对象，使用args初始化该对象shared_ptr&lt;T&gt;p(q)     p是share_ptr q的拷贝：此操作递增q中计数器p.unique()p.usr_count()           //返回与p共享对象的smartptr的数量</code></pre><ul><li>make_shared函数   <pre><code>//p指向一个动态分配的空的vectorauto p = make_shared&lt;vector&lt;string&gt;&gt;();</code></pre></li><li>shared_ptr的拷贝构造：会增加引用计数，当计数为0自动释放管理的对象。</li><li>shared_ptr自动销毁所管理的对象：调用析构函数完成销毁工作。</li><li>使用动态内存的原因:<ul><li>程序不知道自己使用多少对象</li><li>程序不知道所需对象的准确类型</li><li>程序需要在多个对象间共享数据。</li></ul></li><li>可以在一个类中定义之智能指针指向一个vector，该vector就可以在这个类的对象中共享了。</li></ul><h3 id="12-1-2-直接管理内存"><a href="#12-1-2-直接管理内存" class="headerlink" title="12.1.2 直接管理内存"></a>12.1.2 直接管理内存</h3><ul><li>默认情况下，动态分配的对象是默认初始化的，所以内置类型或者组合类型的对象是未定义的。而类类型对象使用默认构造函数初始化。<pre><code>string * ps = new string;           //initialized to empty stringint *pi = new int;                  //pi points to an uninitialized int</code></pre></li><li>只要当初始化的括号中仅有单以初始化才可以使用auto<pre><code>auto p1 = new auto(obj);            //p points to an object of the type of obj that object is initialized from objauto p2 = new auto&#123;a,b,c&#125;;</code></pre></li><li>使用delete释放一块非new分配的内存，或将相同的指针值多次是放是未定义的。</li></ul><h3 id="12-1-3-shared-ptr和new结合使用"><a href="#12-1-3-shared-ptr和new结合使用" class="headerlink" title="12.1.3 shared_ptr和new结合使用"></a>12.1.3 shared_ptr和new结合使用</h3><ul><li>可以使用普通指指针来初始化智能指针，但是不支持隐世转化，所以必须直接初始化。</li><li>不要混用内置指针和只能指针，当讲shared_ptr绑定到内置指针后，资源管理就交给了share_ptr,不应该在使用内置指针访问shared_ptr说指向的内存了。</li><li>智能指针的get函数返回一个内置指针，指向智能指针所指对象，不要用get初始哈另一个指针指针或位智能指针赋值。如果初始化了另一个智能指针，两个智能指针指向同一对象。</li><li>可以使用reset函数将新的指针赋予shared_ptr,与赋值相似，reset会更新引用计数。reset常和unique一起使用，用来控制多个shared_ptr共享对象。<pre><code>if(!p.unique())    p.reset(new string(*p));        //不是唯一的用户，重新分配拷贝，然后将p绑定拷贝后的指针。*p += newVal;</code></pre></li></ul><h3 id="12-1-4-智能指针异常"><a href="#12-1-4-智能指针异常" class="headerlink" title="12.1.4 智能指针异常"></a>12.1.4 智能指针异常</h3><ul><li>如果使用智能指针，即使程序过早的结束，智能指针也能确保内存在不需要的时候释放。</li><li>默认下shared_ptr假定其指向动态内存，使用delete释放对象，创建shared_ptr可以传递一个指向删除函数的指针参数。用来代替delete。</li><li>智能指针陷阱：<ul><li>不使用相同的内置指针初始化或reset多个智能指针。</li><li>不delete get()返回的指针</li><li>不使用get()初始化或reset另一个智能指针</li><li>如果使用get()返回的指针，记得在对应智能指针销毁后，内置指针也无效了。</li><li>如果使用智能指针管理的资源不是new分配的内存，记住传递给他一个删除器。</li></ul></li></ul><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;memory&gt;//连接信息struct connection&#123;    std::string ip;    int port;    connection(std::string ip_,int port_):ip(ip_),port(port_)&#123;&#125;&#125;;//连接什么struct destination&#123;    std:: string ip;    int port ;    destination(std::string ip_,int port_):ip(ip_),port(port_)&#123;&#125;&#125;;connection connect(destination* pDest)&#123;    std::shared_ptr&lt;connection&gt; pConn(new connection(pDest-&gt;ip,pDest-&gt;prot));    std::cout&lt;&lt;&quot;creatin connection&quot;;    return *pCon;&#125;void disconnect(connection pConn)&#123;    cout&lt;&lt;&quot;connection close&quot;;&#125;void end_connection(connection * pConn)&#123;    disconnect(*pConn);&#125;void f(destination &amp;d)&#123;    connection conn = connect(d);    std::shared_ptr&lt;connection&gt; p(&amp;conn,end_connection);    std::cout&lt;&lt;&quot;conneciton now&quot;;&#125;int mian()&#123;    destination dest(&quot;202.118.176.67&quot;, 3316);    f(dest);&#125;</code></pre><h3 id="12-1-5-unique-ptr"><a href="#12-1-5-unique-ptr" class="headerlink" title="12.1.5 unique_ptr"></a>12.1.5 unique_ptr</h3><ul><li>与shared_ptr不同，unique同一时刻只能有一个给定的对象。放unique-ptr被销毁，对象也随之销毁。</li><li>make_unique函数在动态内存中分配一个对象并初始化它。</li><li>虽然unique_ptr不支持拷贝和构造，但是可以使用哪个release和reset将他否给另一个指针。</li><li>release函数返回unique_ptr当前保存的指针，并将其设为空</li><li>reset函数接受一个可选指针参数。重新设置unique_ptr保存的参数，但是原来的对象会被销毁。</li><li>调用release会切断unique_ptr和他原来管理的对象对象之间的关系，如果没有用另一个智能指针保存返回的指针，需要手动清理。</li><li>不能拷贝unique_ptr的特例：可以赋值拷贝一个即将别销毁的unique_ptr</li><li>定义unique_\ptr是必须在尖括号中提供删除器类型。创建或reset这种类型对象，必须提供一个指定的可调用对象(删除器).</li></ul><h3 id="12-1-6-weak-ptr"><a href="#12-1-6-weak-ptr" class="headerlink" title="12.1.6 weak_ptr"></a>12.1.6 weak_ptr</h3><ul><li>weak_ptr是一种不控制所指向对象生存期的智能指针，它指向一个由shared_ptr管理的对象。将weak_ptr绑定到shared_ptr不会改变shared_ptr的引用计数。如果shared_ptr被销毁，即使有weak_ptr指向对象，对象仍然有可能被释放。</li><li>建一个weak_ptr时，需要使用shared_ptr来初始化它。</li><li>使用weak_ptr访问对象时，必须先调用lock函数。该函数检查weak_ptr指向的对象是否仍然存在。如果存在，则返回指向共享对象的shared_ptr，否则返回空指针。</li><li>weak_ptr可以阻止用户访问一个不存在的对象的企图</li></ul><h2 id="12-2-动态数组"><a href="#12-2-动态数组" class="headerlink" title="12.2 动态数组"></a>12.2 动态数组</h2><ul><li>使用allocator类可以将内存分配和初始化过程分离，这通常会提供更好的性能和更加灵活的内存管理能力。</li></ul><h3 id="12-2-1-new和数组"><a href="#12-2-1-new和数组" class="headerlink" title="12.2.1 new和数组"></a>12.2.1 new和数组</h3><ul><li>使用new分配对象数组时需要在类型名之后跟一对方括号，在其中指明要分配的对象数量（必须是整型，但不必是常量）。new返回指向第一个对象的指针（元素类型）。<pre><code>int *pia = new int[get_size()];</code></pre></li><li>由于new分配的内存并不是数组类型，因此不能对动态数组调用begin和end，也不能用范围for语句处理其中的元素。</li><li>默认情况下，new分配的对象是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小后面跟一对空括号()。在新标准中，还可以提供一个元素初始化器的花括号列表。如果初始化器数量大于元素数量，则new表达式失败，不会分配任何内存，并抛出bad_array_new_length异常。</li><li>动态分配一个空数组是合法的，此时new会返回一个合法的非空指针。对于零长度的数组来说，该指针类似尾后指针，不能解引用。</li><li>使用delete[]释放动态数组。</li><li>unique_ptr可以直接管理动态数组，定义时需要在对象类型后添加一对空方括号[]。</li><li>与unique\ptr不同，shared_ptr不直接支持动态数组管理。如果想用shared_ptr管理动态数组，必须提供自定义的删除器。</li><li>shared_ptr未定义下标运算符，智能指针类型也不支持指针算术运算。因此如果想访问shared_ptr管理的数组元素，必须先用get获取内置指针，再用内置指针进行访问。</li></ul><h3 id="12-2-2-allocator类"><a href="#12-2-2-allocator类" class="headerlink" title="12.2.2 allocator类"></a>12.2.2 allocator类</h3><ul><li>allocator类是一个模板，定义时必须指定其可以分配的对象类型。</li><li>allocator分配的内存是未构造的，程序需要在此内存中构造对象。新标准库的construct函数接受一个指针和零或多个额外参数，在给定位置构造一个元素。额外参数用来初始化构造的对象，必须与对象类型相匹配。</li><li>直接使用allocator返回的未构造内存是错误行为，其结果是未定义的。</li><li>对象使用完后，必须对每个构造的元素调用destroy进行销毁。destroy函数接受一个指针，对指向的对象执行析构函数</li><li>deallocate函数用于释放allocator分配的内存空间。传递给deallocate的指针不能为空，它必须指向由allocator分配的内存。而且传递给deallocate的大小参数必须与调用allocator分配内存时提供的大小参数相一致。</li><li>传递给uninitialized_copy的目的位置迭代器必须指向未构造的内存，它直接在给定位置构造元素。返回（递增后的）目的位置迭代器。</li></ul><pre class=" language-.h"><code class="language-.h">#pragam once#include<string>using std::string;#include<vector>using std::vector;#include <memory>using std::shared_ptr;#include <iostream>#include <fstream>#include <map>using std::map;#include <set>using std::set;class QueryResult;class TextQuery{public:    using LineNum = vector<string>::size_type;        TextQuery(std::ifstream &);    QueryResult query(const string&) const;private:    share_ptr<vector<string>> input;    map<string,shared_ptr<set<LineNum>>> result;};class QueryResult {public:    friend std::ostream& print(std::ostream&,const QueryResult&);public:    QueryResult(const string &shared_ptr<set<TextQuery::LineNum>> set,share_ptr<vector<string>> vec):                word(s),input(vec),nos(set);private:    string word;    share_ptr<vector<string>> input;    shared_ptr<set<TextQuery::LineNum>> nos;};std::ostream& print(std::ostream&,const QueryResult&);</code></pre><pre class=" language-.cpp"><code class="language-.cpp">TextQuery::TextQuery(std::ifstream &ifs):input(new vector<string>){    LineNum lineNo{0};    for(string line,std::getline(ifs,line);++lineNo)    {        input->push_back(line);        std::isstringstream line_stream(line);        for(string text，word;line_stream>>text;word.clear())        {            std::remove_copy_if(text.begin(),text.end(),std::back_inserter(word),ispuct);            auto &nos = result[word];            if(!nos)nos.reset(new std::set<lineNum>);            nos->insert(lineNum);        }    }}QueryResult TextQuery::query(const string& str) const{    static shared_ptr<set<LineNum>> nodata(new set<LineNum>);    auto found = result.find(str);    if(found == result.end())return QueryResult(str,nodata,input);    else return QueryResult(str,found->second,input);}std::ostream & print(std::ostream &out,const QueryResult &qr){    out << qr.word << " occurs " << qr.nos->size() << (qr.nos->size() > 1 ? " times" : " time") << std::endl;    for (auto i : *qr.nos)        out << "\t(line " << i+1 << ") " << qr.input->at(i) << std::endl;    return out;}</code></pre><h1 id="第13章-拷贝控制"><a href="#第13章-拷贝控制" class="headerlink" title="第13章 拷贝控制"></a>第13章 拷贝控制</h1><h2 id="13-1-拷贝、赋值与销毁"><a href="#13-1-拷贝、赋值与销毁" class="headerlink" title="13.1 拷贝、赋值与销毁"></a>13.1 拷贝、赋值与销毁</h2><h3 id="13-1-1-拷贝构造函数"><a href="#13-1-1-拷贝构造函数" class="headerlink" title="13.1.1 拷贝构造函数"></a>13.1.1 拷贝构造函数</h3><ul><li>如果一个构造函数的第一个参数是自身类类型的引用（几乎总是const引用），且任何额外参数都有默认值，则此构造函数是拷贝构造函数。<pre><code>class Foo&#123;public:    Foo();   // default constructor    Foo(const Foo&amp;);   // copy constructor    // ...&#125;;</code></pre></li><li>由于拷贝构造函数在一些情况下会被隐式使用，因此通常不会声明为explicit的。</li><li>如果类未定义自己的拷贝构造函数，编译器会为类合成一个。一般情况下，合成拷贝构造函数（synthesized copy constructor）会将其参数的非static成员逐个拷贝到正在创建的对象中。<pre><code>class Sales_data&#123;public:    // other members and constructors as before    // declaration equivalent to the synthesized copy constructor    Sales_data(const Sales_data&amp;);    private:    std::string bookNo;    int units_sold = 0;    double revenue = 0.0;&#125;;// equivalent to the copy constructor that would be synthesized for Sales_dataSales_data::Sales_data(const Sales_data &amp;orig):    bookNo(orig.bookNo),    // uses the string copy constructor    units_sold(orig.units_sold),    // copies orig.units_sold    revenue(orig.revenue)   // copies orig.revenue    &#123; &#125; // empty bod</code></pre></li><li>使用直接初始化时，实际上是要求编译器按照函数匹配规则来选择与实参最匹配的构造函数。使用拷贝初始化时，是要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。<pre><code>string dots(10, &#39;.&#39;);   // direct initializationstring s(dots);         // direct initializationstring s2 = dots;       // copy initializationstring null_book = &quot;9-999-99999-9&quot;;    // copy initializationstring nines = string(100, &#39;9&#39;);       // copy initialization</code></pre></li><li>拷贝初始化通常使用拷贝构造函数来完成。但如果一个类拥有移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。</li><li>发生拷贝的情况：<ul><li>使用&#x3D;定义变量</li><li>将对象作为实参传递给非引用实参。</li><li>从返回类型为非引用类型的函数返回对象。</li><li>用花括号列表初始化数组中的元素或聚合类中的成员。</li></ul></li><li>当传递一个实参或者从函数返回一个值时，不能隐式使用explicit构造函数。</li><li>如果类未定义自己的拷贝赋值运算符，编译器会为类合成一个。一般情况下，合成拷贝赋值运算符（synthesized copy-assignment operator）会将其右侧运算对象的非static成员逐个赋值给左侧运算对象的对应成员，之后返回左侧运算对象的引用。<pre><code>// equivalent to the synthesized copy-assignment operatorSales_data&amp; Sales_data::operator=(const Sales_data &amp;rhs)&#123;    bookNo = rhs.bookNo;    // calls the string::operator=    units_sold = rhs.units_sold;    // uses the built-in int assignment    revenue = rhs.revenue;  // uses the built-in double    assignment...    return *this;   // return a reference to this object&#125;</code></pre></li></ul><h3 id="12-1-2-拷贝赋值运算符"><a href="#12-1-2-拷贝赋值运算符" class="headerlink" title="12.1.2 拷贝赋值运算符"></a>12.1.2 拷贝赋值运算符</h3><ul><li>重载运算符（overloaded operator）的参数表示运算符的运算对象。如果一个运算符是成员函数，则其左侧运算对象会绑定到隐式的this参数上。赋值运算符通常应该返回一个指向其左侧运算对象的引用。<pre><code>class Foo&#123;public:    Foo&amp; operator=(const Foo&amp;);  // assignment operator    // ...&#125;;</code></pre></li><li>标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值是左侧运算对象的引用。</li><li>如果类未定义自己的拷贝赋值运算符，编译器会为类合成一个。一般情况下，合成拷贝赋值运算符（synthesized copy-assignment operator）会将其右侧运算对象的非static成员逐个赋值给左侧运算对象的对应成员，之后返回左侧运算对象的引用。<pre><code>// equivalent to the synthesized copy-assignment operatorSales_data&amp; Sales_data::operator=(const Sales_data &amp;rhs)&#123;    bookNo = rhs.bookNo;    // calls the string::operator=    units_sold = rhs.units_sold;    // uses the built-in int assignment    revenue = rhs.revenue;  // uses the built-in double    assignment    return *this;   // return a reference to this object&#125;</code></pre></li></ul><h3 id="12-1-3-析构函数"><a href="#12-1-3-析构函数" class="headerlink" title="12.1.3 析构函数"></a>12.1.3 析构函数</h3><ul><li>析构函数负责释放对象使用的资源，并销毁对象的非static数据成员。</li><li>析构函数的名字由波浪号~接类名构成，它没有返回值，也不接受参数。<pre><code>class Foo&#123;public:    ~Foo(); // destructor    // ...&#125;;</code></pre></li><li>由于析构函数不接受参数，所以它不能被重载。</li><li>如果类未定义自己的析构函数，编译器会为类合成一个。合成析构函数（synthesized destructor）的函数体为空。</li></ul><h3 id="13-1-4-三五准则"><a href="#13-1-4-三五准则" class="headerlink" title="13.1.4 三五准则"></a>13.1.4 三五准则</h3><ul><li>需要析构函数的类一般也需要拷贝和赋值操作。</li><li>需要拷贝操作的类一般也需要赋值操作，反之亦然。</li></ul><h3 id="13-1-5-使用-x3D-default"><a href="#13-1-5-使用-x3D-default" class="headerlink" title="13.1.5 使用&#x3D;default"></a>13.1.5 使用&#x3D;default</h3><ul><li>可以通过将拷贝控制成员定义为&#x3D;default来显式地要求编译器生成合成版本。</li><li>在类内使用&#x3D;default修饰成员声明时，合成的函数是隐式内联的。如果不希望合成的是内联函数，应该只对成员的类外定义使用&#x3D;default。</li></ul><h3 id="13-1-6-阻止拷贝"><a href="#13-1-6-阻止拷贝" class="headerlink" title="13.1.6 阻止拷贝"></a>13.1.6 阻止拷贝</h3><ul><li>在C++11新标准中，将拷贝构造函数和拷贝赋值运算符定义为删除的函数（deleted function）可以阻止类对象的拷贝。删除的函数是一种虽然进行了声明，但是却不能以任何方式使用的函数。定义删除函数的方式是在函数的形参列表后面添加&#x3D;delete。<pre><code>struct NoCopy&#123;    NoCopy() = default; // use the synthesized default constructor    NoCopy(const NoCopy&amp;) = delete; // no copy    NoCopy &amp;operator=(const NoCopy&amp;) = delete; // no assignment    ~NoCopy() = default; // use the synthesized destructor    // other members&#125;;</code></pre></li><li>&#x3D;delete和&#x3D;default有两点不同：<ul><li>&#x3D;delete可以对任何函数使用；&#x3D;default只能对具有合成版本的函数使用。</li><li>&#x3D;delete必须出现在函数第一次声明的地方；&#x3D;default既能出现在类内，也能出现在类外。</li></ul></li><li>析构函数不能是删除的函数。对于析构函数被删除的类型，不能定义该类型的变量或者释放指向该类型动态分配对象的指针。</li><li>如果一个类中有数据成员不能默认构造、拷贝或销毁，则对应的合成拷贝控制成员将被定义为删除的。</li><li>在旧版本的C++标准中，类通过将拷贝构造函数和拷贝赋值运算符声明为private成员来阻止类对象的拷贝。并且只声明该函数而定义，子类访问。在新标准中建议使用&#x3D;delete而非private。</li></ul><h2 id="13-2-拷贝控制和资源管理"><a href="#13-2-拷贝控制和资源管理" class="headerlink" title="13.2 拷贝控制和资源管理"></a>13.2 拷贝控制和资源管理</h2><h3 id="13-2-1-行为像值的类"><a href="#13-2-1-行为像值的类" class="headerlink" title="13.2.1 行为像值的类"></a>13.2.1 行为像值的类</h3><pre><code>class HasPtr&#123;public:    HasPtr(const std::string &amp;s = std::string()):        ps(new std::string(s)), i(0) &#123; &#125;    // each HasPtr has its own copy of the string to which ps points    HasPtr(const HasPtr &amp;p):        ps(new std::string(*p.ps)), i(p.i) &#123; &#125;    HasPtr&amp; operator=(const HasPtr &amp;);    ~HasPtr() &#123; delete ps; &#125;    private:    std::string *ps;    int i;&#125;;</code></pre><ul><li>编写赋值运算符有两点需要注意：<ul><li>即使将一个对象赋予它自身，赋值运算符也能正确工作。</li><li>赋值运算符通常结合了拷贝构造函数和析构函数的工作。</li></ul></li><li>编写赋值运算符时，一个好的方法是先将右侧运算对象拷贝到一个局部临时对象中。拷贝完成后，就可以安全地销毁左侧运算对象的现有成员了。<pre><code>HasPtr&amp; HasPtr::operator=(const HasPtr &amp;rhs)&#123;    auto newp = new string(*rhs.ps);    // copy the underlying string    delete ps;   // free the old memory    ps = newp;   // copy data from rhs into this object    i = rhs.i;    return *this;   // return this object&#125;</code></pre></li></ul><h3 id="13-3-2-定义行为像指针的类"><a href="#13-3-2-定义行为像指针的类" class="headerlink" title="13.3.2 定义行为像指针的类"></a>13.3.2 定义行为像指针的类</h3><pre><code>class HasPtr&#123;public:    // constructor allocates a new string and a new counter, which it sets to 1    HasPtr(const std::string &amp;s = std::string()):        ps(new std::string(s)), i(0), use(new std::size_t(1)) &#123;&#125;    // copy constructor copies all three data members and increments the counter    HasPtr(const HasPtr &amp;p):        ps(p.ps), i(p.i), use(p.use) &#123; ++*use; &#125;    HasPtr&amp; operator=(const HasPtr&amp;);    ~HasPtr();private:    std::string *ps;    int i;    std::size_t *use; // member to keep track of how many objects share *ps&#125;;HasPtr::~HasPtr()&#123;    if (--*use == 0)    &#123;   // if the reference count goes to 0        delete ps;   // delete the string        delete use;  // and the counter    &#125;&#125;HasPtr&amp; HasPtr::operator=(const HasPtr &amp;rhs)&#123;    ++*rhs.use;    // increment the use count of the right-hand operand    if (--*use == 0)    &#123;   // then decrement this object&#39;s counter        delete ps; // if no other users        delete use; // free this object&#39;s allocated members    &#125;    ps = rhs.ps;    // copy data from rhs into this object    i = rhs.i;    use = rhs.use;    return *this;   // return this object&#125;</code></pre><h2 id="13-3-交换操作"><a href="#13-3-交换操作" class="headerlink" title="13.3 交换操作"></a>13.3 交换操作</h2><ul><li>通常，管理类外资源的类会定义swap函数。如果一个类定义了自己的swap函数，算法将使用自定义版本，否则将使用标准库定义的swap。</li><li>一些算法在交换两个元素时会调用swap函数，其中每个swap调用都应该是未加限定的。如果存在类型特定的swap版本，其匹配程度会优于std中定义的版本（假定作用域中有using声明）。</li><li>与拷贝控制成员不同，swap函数并不是必要的。但是对于分配了资源的类，定义swap可能是一种重要的优化手段。</li><li>定义了swap的类通常用swap来实现赋值运算符。在这种版本的赋值运算符中，右侧运算对象以值方式传递，然后将左侧运算对象与右侧运算对象的副本进行交换（拷贝并交换，copy and swap）。这种方式可以正确处理自赋值情况。<pre><code>// note rhs is passed by value, which means the HasPtr copy constructor// copies the string in the right-hand operand into rhsHasPtr&amp; HasPtr::operator=(HasPtr rhs)&#123;    // swap the contents of the left-hand operand with the local variable rhs    swap(*this, rhs);   // rhs now points to the memory this object had used    return *this;       // rhs is destroyed, which deletes the pointer in rhs&#125;</code></pre></li></ul><h2 id="13-4-拷贝控制实例"><a href="#13-4-拷贝控制实例" class="headerlink" title="13.4 拷贝控制实例"></a>13.4 拷贝控制实例</h2><h2 id="13-5-动态内存管理类"><a href="#13-5-动态内存管理类" class="headerlink" title="13.5 动态内存管理类"></a>13.5 动态内存管理类</h2><h2 id="13-6-对象移动"><a href="#13-6-对象移动" class="headerlink" title="13.6 对象移动"></a>13.6 对象移动</h2><h1 id="第14章-操作重载和类型转换"><a href="#第14章-操作重载和类型转换" class="headerlink" title="第14章 操作重载和类型转换"></a>第14章 操作重载和类型转换</h1><h2 id="14-1-基本概念"><a href="#14-1-基本概念" class="headerlink" title="14.1 基本概念"></a>14.1 基本概念</h2><ul><li>重载的运算符是具有特殊名字的函数，它们的名字由关键字operator和其后要定义的运算符号组成。</li><li>重载运算符函数的参数数量和该运算符作用的运算对象数量一样多。对于二元运算符来说，左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数。除了重载的函数调用运算符operator()之外，其他重载运算符不能含有默认实参。</li><li>如果一个运算符函数是类的成员函数，则它的第一个运算对象会绑定到隐式的this指针上。因此成员运算符函数的显式参数数量比运算对象的数量少一个。</li><li>当运算符作用于内置类型的运算对象时，无法改变该运算符的含义。</li><li>只能重载大多数已有的运算符，无权声明新的运算符号。</li><li>重载运算符的优先级和结合律与对应的内置运算符一致。</li><li>可以像调用普通函数一样直接调用运算符函数。<pre><code>// equivalent calls to a nonmember operator functiondata1 + data2;              // normal expressionoperator+(data1, data2);    // equivalent function calldata1 += data2;             // expression-based &#39;&#39;call&#39;&#39;data1.operator+=(data2);    // equivalent call to a member operator function</code></pre></li><li>通常情况下，不应该重载逗号,、取地址&amp;、逻辑与&amp;&amp;和逻辑或||运算符。</li><li>建议只有当操作的含义对于用户来说清晰明了时才使用重载运算符，重载运算符的返回类型也应该与其内置版本的返回类型兼容。</li><li>如果类中含有算术运算符或位运算符，则最好也提供对应的复合赋值运算符。</li><li>把运算符定义为成员函数时，它的左侧运算对象必须是运算符所属类型的对象。<pre><code>string s = &quot;world&quot;;string t = s + &quot;!&quot;;     // ok: we can add a const char* to a stringstring u = &quot;hi&quot; + s;    // would be an error if + were a member of string</code></pre></li><li>如何选择将运算符定义为成员函数还是普通函数：<ul><li>赋值&#x3D;、下标[]、调用()和成员访问箭头-&gt;运算符必须是成员函数。</li><li>复合赋值运算符一般是成员函数，但并非必须。</li><li>改变对象状态或者与给定类型密切相关的运算符，如递增、递减、解引用运算符，通常是成员函数。</li><li>具有对称性的运算符可能转换任意一端的运算对象，如算术、相等性、关系和位运算符，通常是普通函数。</li></ul></li></ul><h2 id="14-2-输出运算符"><a href="#14-2-输出运算符" class="headerlink" title="14.2 输出运算符"></a>14.2 输出运算符</h2><h3 id="14-2-1-重载输出运算符"><a href="#14-2-1-重载输出运算符" class="headerlink" title="14.2.1 重载输出运算符"></a>14.2.1 重载输出运算符</h3><ul><li>通常情况下，输出运算符的第一个形参是ostream类型的普通引用，第二个形参是要打印类型的常量引用，返回值是它的ostream形参。<pre><code>ostream &amp;operator&lt;&lt;(ostream &amp;os, const Sales_data &amp;item)&#123;    os &lt;&lt; item.isbn() &lt;&lt; &quot; &quot; &lt;&lt; item.units_sold &lt;&lt; &quot; &quot;        &lt;&lt; item.revenue &lt;&lt; &quot; &quot; &lt;&lt; item.avg_price();    return os;&#125;</code></pre></li><li>输出运算符应该尽量减少格式化操作。</li><li>输入输出运算符必须是非成员函数。而由于IO操作通常需要读写类的非公有数据，所以输入输出运算符一般被声明为友元。</li></ul><h3 id="14-2-2-重载输入运算符-gt-gt"><a href="#14-2-2-重载输入运算符-gt-gt" class="headerlink" title="14.2.2 重载输入运算符&gt;&gt;"></a>14.2.2 重载输入运算符&gt;&gt;</h3><ul><li>通常情况下，输入运算符的第一个形参是要读取的流的普通引用，第二个形参是要读入的目的对象的普通引用，返回值是它的第一个形参。</li></ul><pre><code>istream &amp;operator&gt;&gt;(istream &amp;is, Sales_data &amp;item)&#123;    double price;   // no need to initialize; we&#39;ll read into price before we use it    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;    if (is)    // check that the inputs succeeded        item.revenue = item.units_sold * price;    else        item = Sales_data();    // input failed: give the object the default state    return is;&#125;</code></pre><ul><li>输入运算符必须处理输入失败的情况，而输出运算符不需要。</li><li>当读取操作发生错误时，输入操作符应该负责从错误状态中恢复。</li><li>如果输入的数据不符合规定的格式，即使从技术上看IO操作是成功的，输入运算符也应该设置流的条件状态以标示出失败信息。通常情况下，输入运算符只设置failbit状态。eofbit、badbit等错误最好由IO标准库自己标示。</li></ul><h2 id="14-3-算数运算符"><a href="#14-3-算数运算符" class="headerlink" title="14.3 算数运算符"></a>14.3 算数运算符</h2><ul><li>通常情况下，算术和关系运算符应该定义为非成员函数，以便两侧的运算对象进行转换。其次，由于这些运算符一般不会改变运算对象的状态，所以形参都是常量引用。</li><li>算术运算符通常会计算它的两个运算对象并得到一个新值，这个值通常存储在一个局部变量内，操作完成后返回该局部变量的副本作为结果（返回类型建议设置为原对象的const类型）。<pre><code>// assumes that both objects refer to the same bookSales_data operator+(const Sales_data &amp;lhs, const Sales_data &amp;rhs)&#123;    Sales_data sum = lhs;   // copy data members from lhs into sum    sum += rhs;     // add rhs into sum    return sum;&#125;</code></pre></li><li>如果类同时定义了算术运算符合相关的复合运算符，通常情况下应该使用复合赋值来实现算术运算符。</li></ul><h3 id="14-3-1-相等运算符"><a href="#14-3-1-相等运算符" class="headerlink" title="14.3.1 相等运算符"></a>14.3.1 相等运算符</h3><ul><li>相等运算符设计准则：<ul><li>如果类在逻辑上有相等性的含义，则应该定义operator&#x3D;&#x3D;而非一个普通的命名函数。这样做便于使用标准库容器和算法，也更容易记忆。</li><li>通常情况下，operator&#x3D;&#x3D;应该具有传递性。</li><li>如果类定义了operator&#x3D;&#x3D;，则也应该定义operator!&#x3D;。operator&#x3D;&#x3D;和operator!&#x3D;中的一个应该把具体工作委托给另一个。<pre><code>bool operator==(const Sales_data &amp;lhs, const Sales_data &amp;rhs)&#123;    return lhs.isbn() == rhs.isbn() &amp;&amp;        lhs.units_sold == rhs.units_sold &amp;&amp;        lhs.revenue == rhs.revenue;&#125;bool operator!=(const Sales_data &amp;lhs, const Sales_data &amp;rhs)&#123;    return !(lhs == rhs);&#125;</code></pre></li></ul></li></ul><h3 id="14-3-2-关系运算符"><a href="#14-3-2-关系运算符" class="headerlink" title="14.3.2 关系运算符"></a>14.3.2 关系运算符</h3><ul><li>定义了相等运算符的类通常也会定义关系运算符。因为关联容器和一些算法要用到小于运算符，所以定义operator&lt;会比较实用。</li><li>关系运算符设计准则：<ul><li>定义顺序关系，令其与关联容器中对关键字的要求保持一致。</li><li>如果类定义了operator&#x3D;&#x3D;，则关系运算符的定义应该与operator&#x3D;&#x3D;保持一致。特别是，如果两个对象是不相等的，那么其中一个对象应该小于另一个对象。</li><li>只有存在唯一一种逻辑可靠的小于关系时，才应该考虑为类定义operator&lt;。</li></ul></li></ul><h2 id="14-4-赋值运算符"><a href="#14-4-赋值运算符" class="headerlink" title="14.4 赋值运算符"></a>14.4 赋值运算符</h2><ul><li>赋值运算符必须定义为成员函数，复合赋值运算符通常也是如此。这两类运算符都应该返回其左侧运算对象的引用<pre><code>StrVec &amp;StrVec::operator=(initializer_list&lt;string&gt; il)&#123;    // alloc_n_copy allocates space and copies elements from the given range    auto data = alloc_n_copy(il.begin(), il.end());    free();     // destroy the elements in this object and free the space    elements = data.first;      // update data members to point to the new    space    first_free = cap = data.second;    return *this;&#125;// member binary operator: left-hand operand is bound to the implicit this pointer// assumes that both objects refer to the same bookSales_data&amp; Sales_data::operator+=(const Sales_data &amp;rhs)&#123;    units_sold += rhs.units_sold;    revenue += rhs.revenue;    return *this;&#125;</code></pre></li></ul><h2 id="14-5-下标运算符"><a href="#14-5-下标运算符" class="headerlink" title="14.5 下标运算符"></a>14.5 下标运算符</h2><ul><li>下标运算符必须定义为成员函数。</li><li>类通常会定义两个版本的下标运算符：一个返回普通引用，另一个是类的常量成员并返回常量引用。<pre><code>class StrVec&#123;public:    std::string&amp; operator[](std::size_t n)    &#123; return elements[n]; &#125;    const std::string&amp; operator[](std::size_t n) const    &#123; return elements[n]; &#125;private:    std::string *elements;  // pointer to the first element in the array&#125;</code></pre></li></ul><h2 id="14-6-递增递减运算符"><a href="#14-6-递增递减运算符" class="headerlink" title="14.6 递增递减运算符"></a>14.6 递增递减运算符</h2><ul><li>定义递增和递减运算符的类应该同时定义前置和后置版本，这些运算符通常定义为成员函数。</li><li>为了与内置操作保持一致，前置递增或递减运算符应该返回运算后对象的引用。<pre><code>// prefix: return a reference to the incremented/decremented objectStrBlobPtr&amp; StrBlobPtr::operator++()&#123;    ++curr;     // advance the current state    return *this;&#125;</code></pre></li><li>后置递增或递减运算符接受一个额外的（不被使用）int类型形参，该形参的唯一作用就是区分运算符的前置和后置版本。<pre><code>class StrBlobPtr&#123;public:    // increment and decrement    StrBlobPtr&amp; operator++();    // prefix operators    StrBlobPtr&amp; operator--();    StrBlobPtr operator++(int);  // postfix operators    StrBlobPtr operator--(int);&#125;;</code></pre></li><li>为了与内置操作保持一致，后置递增或递减运算符应该返回运算前对象的原值（返回类型建议设置为原对象的const类型）.</li><li>如果想通过函数调用的方式使用后置递增或递减运算符，则必须为它的整型参数传递一个值。</li></ul><h2 id="14-7-成员访问运算符"><a href="#14-7-成员访问运算符" class="headerlink" title="14.7 成员访问运算符"></a>14.7 成员访问运算符</h2><ul><li>箭头运算符必须定义为成员函数，解引用运算符通常也是如此。</li><li>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的类的对象。<pre><code>class StrBlobPtr&#123;public:    std::string&amp; operator*() const    &#123;        return (*p)[curr];   // (*p) is the vector to which this object points    &#125;    std::string* operator-&gt;() const    &#123;   // delegate the real work to the dereference operator        return &amp; this-&gt;operator*();    &#125;&#125;;</code></pre></li><li>对于形如point-&gt;mem的表达式来说，point必须是指向类对象的指针或者是一个重载了operator-&gt;的类的对象。point类型不同，point-&gt;mem的含义也不同。<ul><li>如果point是指针，则调用内置箭头运算符，表达式等价于(*point).mem。</li><li>如果point是重载了operator-&gt;的类的对象，则使用point.operator-&gt;()的结果来获取mem，表达式等价于(point.opeator-&gt;())-&gt;mem。其中，如果该结果是一个指针，则执行内置操作，否则重复调用当前操作。</li></ul></li></ul><h2 id="14-8-函数调用运算符"><a href="#14-8-函数调用运算符" class="headerlink" title="14.8 函数调用运算符"></a>14.8 函数调用运算符</h2><ul><li>函数调用运算符必须定义为成员函数。一个类可以定义多个不同版本的调用运算符，相互之间必须在参数数量或类型上有所区别。<pre><code>class PrintString&#123;public:    PrintString(ostream &amp;o = cout, char c = &#39; &#39;):        os(o), sep(c) &#123; &#125;    void operator()(const string &amp;s) const    &#123;        os &lt;&lt; s &lt;&lt; sep;    &#125;    private:    ostream &amp;os;   // stream on which to write    char sep;      // character to print after each output&#125;;PrintString printer;  // uses the defaults; prints to coutprinter(s);     // prints s followed by a space on cout</code></pre></li><li>如果类定义了调用运算符，则该类的对象被称作函数对象（function object），函数对象常常作为泛型算法的实参。<pre><code>for_each(vs.begin(), vs.end(), PrintString(cerr, &#39;\n&#39;));  </code></pre></li></ul><h3 id="14-8-1-lambda是函数对象"><a href="#14-8-1-lambda是函数对象" class="headerlink" title="14.8.1 lambda是函数对象"></a>14.8.1 lambda是函数对象</h3><ul><li>编写一个lambda后，编译器会将该表达式转换成一个未命名类的未命名对象，类中含有一个重载的函数调用运算符。<pre><code>// sort words by size, but maintain alphabetical order for words of the same sizestable_sort(words.begin(), words.end(),    [](const string &amp;a, const string &amp;b) &#123; return a.size() &lt; b.size(); &#125;);// acts like an unnamed object of a class that would look something likeclass ShorterString&#123;public:    bool operator()(const string &amp;s1, const string &amp;s2) const    &#123;        return s1.size() &lt; s2.size();    &#125;&#125;;</code></pre></li><li>lambda默认不能改变它捕获的变量。因此在默认情况下，由lambda产生的类中的函数调用运算符是一个const成员函数。如果lambda被声明为可变的，则调用运算符就不再是const函数了。</li><li>lambda通过引用捕获变量时，由程序负责确保lambda执行时该引用所绑定的对象确实存在。因此编译器可以直接使用该引用而无须在lambda产生的类中将其存储为数据成员。相反，通过值捕获的变量被拷贝到lambda中，此时lambda产生的类必须为每个值捕获的变量建立对应的数据成员，并创建构造函数，用捕获变量的值来初始化数据成员。</li><li>lambda产生的类不包含默认构造函数、赋值运算符和默认析构函数，它是否包含默认拷贝&#x2F;移动构造函数则通常要视捕获的变量类型而定。</li></ul><h3 id="14-8-2-标准库定义的函数对象（Library-Defined-Function-Objects）"><a href="#14-8-2-标准库定义的函数对象（Library-Defined-Function-Objects）" class="headerlink" title="14.8.2 标准库定义的函数对象（Library-Defined Function Objects）"></a>14.8.2 标准库定义的函数对象（Library-Defined Function Objects）</h3><ul><li>标准库在头文件functional中定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。这些类都被定义为模板的形式，可以为其指定具体的应用类型（即调用运算符的形参类型）。<img src="/2020/01/09/c/c-primer/%E8%A1%A814.2.png" class="" title="表14.2.png">)</li><li>关系运算符的函数对象类通常被用来替换算法中的默认运算符，这些类对于指针同样适用。<pre><code>vector&lt;string *&gt; nameTable;    // vector of pointers// error: the pointers in nameTable are unrelated, so &lt; is undefinedsort(nameTable.begin(), nameTable.end(),        [](string *a, string *b) &#123; return a &lt; b; &#125;);// ok: library guarantees that less on pointer types is well definedsort(nameTable.begin(), nameTable.end(), less&lt;string*&gt;());</code></pre></li></ul><h3 id="14-8-3-可调用对象语与function"><a href="#14-8-3-可调用对象语与function" class="headerlink" title="14.8.3 可调用对象语与function"></a>14.8.3 可调用对象语与function</h3><ul><li>调用形式指明了调用返回的类型以及传递给调用的实参类型。不同的可调用对象可能具有相同的调用形式。</li><li>标准库function类型是一个模板，定义在头文件functional中，用来表示对象的调用形式。<img src="/2020/01/09/c/c-primer/%E8%A1%A814.3.png" class="" title="表14.3.png">)</li><li>创建一个具体的function类型时必须提供其所表示的对象的调用形式。<pre><code>// ordinary functionint add(int i, int j) &#123; return i + j; &#125;// function-object classstruct div&#123;    int operator()(int denominator, int divisor)    &#123;        return denominator / divisor;    &#125;&#125;;function&lt;int(int, int)&gt; f1 = add;      // function pointerfunction&lt;int(int, int)&gt; f2 = div();    // object of a function-object classfunction&lt;int(int, int)&gt; f3 = [](int i, int j) &#123; return i * j; &#125;;  // lambda                                cout &lt;&lt; f1(4,2) &lt;&lt; endl;   // prints 6cout &lt;&lt; f2(4,2) &lt;&lt; endl;   // prints 2cout &lt;&lt; f3(4,2) &lt;&lt; endl;   // prints 8</code></pre></li><li>不能直接将重载函数的名字存入function类型的对象中，这样做会产生二义性错误。消除二义性的方法是使用lambda或者存储函数指针而非函数名字。</li><li>C++11新标准库中的function类与旧版本中的unary_function和binary_function没有关系，后两个类已经被bind函数代替。</li></ul><h2 id="14-9-重载、类型转换、运算符"><a href="#14-9-重载、类型转换、运算符" class="headerlink" title="14.9 重载、类型转换、运算符"></a>14.9 重载、类型转换、运算符</h2><h3 id="14-9-1-类型转换运算符"><a href="#14-9-1-类型转换运算符" class="headerlink" title="14.9.1 类型转换运算符"></a>14.9.1 类型转换运算符</h3><ul><li>类型转换运算符是类的一种特殊成员函数，负责将一个类类型的值转换成其他类型。它不能声明返回类型，形参列表也必须为空，一般形式如下：<br>  <code>operator type() const;</code></li><li>类型转换运算符可以面向除了void以外的任意类型（该类型要能作为函数的返回类型）进行定义。</li><li>隐式的用户定义类型转换可以置于一个标准（内置）类型转换之前或之后，并与其一起使用。</li><li>应该避免过度使用类型转换函数。如果在类类型和转换类型之间不存在明显的映射关系，则这样的类型转换可能具有误导性.</li><li>C++11引入了显示的类型转换运算符（explicit conversion operator）。和显式构造函数一样，编译器通常不会将显式类型转换运算符用于隐式类型转换。<pre><code>class SmallInt&#123;public:    // the compiler won&#39;t automatically apply this conversion    explicit operator int() const &#123; return val; &#125;    // other members as before&#125;;SmallInt si = 3;    // ok: the SmallInt constructor is not explicitsi + 3;     // error: implicit is conversion required, but operator int is explicitstatic_cast&lt;int&gt;(si) + 3;    // ok: explicitly request the conversion</code></pre></li><li>如果表达式被用作条件，则编译器会隐式地执行显式类型转换。<ul><li>if、while、do-while语句的条件部分。</li><li>for语句头的条件表达式。</li><li>条件运算符? :的条件表达式。</li><li>逻辑非运算符!、逻辑或运算符||、逻辑与运算符&amp;&amp;的运算对象。</li></ul></li></ul><h3 id="14-9-2-避免有二义性的类型转换"><a href="#14-9-2-避免有二义性的类型转换" class="headerlink" title="14.9.2 避免有二义性的类型转换"></a>14.9.2 避免有二义性的类型转换</h3><ul><li>如果一个类中包含一个或者多个类型转换，必须确保在类类型中。</li><li>两种情况下可能产生多重转换路径：<ul><li>A类定义了一个接受B类对象的转换构造函数，同时B类定义了一个转换目标是A类的类型转换运算符。</li><li>类定义了多个类型转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。</li></ul></li><li>可以通过显式调用类型转换运算符或转换构造函数解决二义性问题，但不能使用强制类型转换，因为强制类型转换本身也存在二义性。</li><li>通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标都是算术类型的转换。</li><li>使用两个用户定义的类型转换时，如果转换前后存在标准类型转换，则由标准类型转换决定最佳匹配。</li><li>调用重载函数时，如果需要额外的标准类型转换，则该转换只有在所有可行函数都请求同一个用户定义类型转换时才有用。如果所需的用户定义类型转换不止一个，即使其中一个调用能精确匹配而另一个调用需要额外的标准类型转换，也会产生二义性错误。</li></ul><h3 id="14-9-3-函数匹配与重载运算符"><a href="#14-9-3-函数匹配与重载运算符" class="headerlink" title="14.9.3 函数匹配与重载运算符"></a>14.9.3 函数匹配与重载运算符</h3><ul><li>表达式中运算符的候选函数集包括成员函数，也包括非成员函数。</li><li>如果类既定义了转换目标是算术类型的类型转换，也定义了重载的运算符，则会遇到重载运算符与内置运算符的二义性问题。</li></ul><h1 id="第15章-面型对象程序设计"><a href="#第15章-面型对象程序设计" class="headerlink" title="第15章 面型对象程序设计"></a>第15章 面型对象程序设计</h1><h2 id="15-1-oop：概述"><a href="#15-1-oop：概述" class="headerlink" title="15.1 oop：概述"></a>15.1 oop：概述</h2><ul><li>面向对象程序设计（object-oriented programming）的核心思想是数据抽象（封装）、继承和动态绑定（多态）。</li><li>通过继承（inheritance）联系在一起的类构成一种层次关系。通常在层次关系的根部有一个基类（base class），其他类则直接或间接地从基类继承而来，这些继承得到的类叫做派生类（derived class）。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</li><li>对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类应该将这些函数声明为虚函数（virtual function）。方法是在函数名称前添加virtual关键字。<pre><code>class Quote&#123;public:    std::string isbn() const;    virtual double net_price(std::size_t n) const;&#125;;</code></pre></li><li>派生类必须通过类派生列表（class derivation list）明确指出它是从哪个或哪些基类继承而来的。类派生列表的形式首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以添加访问说明符。   <pre><code>class Bulk_quote : public Quote&#123; // Bulk_quote inherits from Quotepublic:    double net_price(std::size_t) const override;&#125;;</code></pre></li><li>派生类必须在其内部对所有重新定义的虚函数进行声明。</li><li>使用基类的引用或指针调用一个虚函数时将发生动态绑定（dynamic binding），也叫运行时绑定（run-time binding）。函数的运行版本将由实参决定。</li></ul><h2 id="15-2-定义基类和派生类"><a href="#15-2-定义基类和派生类" class="headerlink" title="15.2 定义基类和派生类"></a>15.2 定义基类和派生类</h2><h3 id="15-2-1-定义基类"><a href="#15-2-1-定义基类" class="headerlink" title="15.2.1 定义基类"></a>15.2.1 定义基类</h3><ul><li>基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</li><li>除构造函数之外的任何非静态函数都能定义为虚函数。virtual关键字只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明为虚函数，则该函数在派生类中隐式地也是虚函数。</li><li>成员函数如果没有被声明为虚函数，则其解析过程发生在编译阶段而非运行阶段。</li><li>派生类能访问基类的公有成员，不能访问私有成员。如果基类希望定义外部代码无法访问，但是派生类对象可以访问的成员，可以使用受保护的（protected）访问运算符进行说明。</li></ul><h3 id="15-2-2-定义派生类"><a href="#15-2-2-定义派生类" class="headerlink" title="15.2.2 定义派生类"></a>15.2.2 定义派生类</h3><ul><li>类派生列表中的访问说明符用于控制派生类从基类继承而来的成员是否对派生类的用户可见。</li><li>如果派生类没有覆盖其基类的某个虚函数，则该虚函数的行为类似于其他的普通函数，派生类会直接继承其在基类中的版本</li><li>C++标准并没有明确规定派生类的对象在内存中如何分布，一个对象中继承自基类的部分和派生类自定义的部分不一定是连续存储的。</li><li>因为在派生类对象中含有与其基类对应的组成部分，所以能把派生类的对象当作基类对象来使用，也能将基类的指针或引用绑定到派生类对象中的基类部分上。这种转换通常称为派生类到基类的（derived-to-base）类型转换，编译器会隐式执行。<pre><code>Quote item;         // object of base typeBulk_quote bulk;    // object of derived typeQuote *p = &amp;item;   // p points to a Quote objectp = &amp;bulk;          // p points to the Quote part of bulkQuote &amp;r = bulk;    // r bound to the Quote part of bulk</code></pre></li><li>每个类控制它自己的成员初始化过程，派生类必须使用基类的构造函数来初始化它的基类部分。派生类的构造函数通过构造函数初始化列表来将实参传递给基类构造函数。<pre><code>Bulk_quote(const std::string&amp; book, double p,         std::size_t qty, double disc) :Quote(book, p), min_qty(qty), discount(disc) &#123; &#125;</code></pre></li><li>除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。派生类初始化时首先初始化基类部分，然后按照声明的顺序依次初始化派生类成员。派生类可以访问基类的公有成员和受保护成员。</li><li>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。如果某静态成员是可访问的，则既能通过基类也能通过派生类使用它。</li><li>已经完整定义的类才能被用作基类。</li><li>Base是D1的直接基类（direct base），是D2的间接基类（indirect base）。最终的派生类将包含它直接基类的子对象以及每个间接基类的子对象。<pre><code>class Base &#123; /* ... */ &#125; ;class D1: public Base &#123; /* ... */ &#125;;class D2: public D1 &#123; /* ... */ &#125;;</code></pre></li><li>C++11中，在类名后面添加final关键字可以禁止其他类继承它。<pre><code>class NoDerived final &#123; /* */ &#125;;    // NoDerived can&#39;t be a base classclass Base &#123; /* */ &#125;;// Last is final; we cannot inherit from Lastclass Last final : Base &#123; /* */ &#125;;  // Last can&#39;t be a base classclass Bad : NoDerived &#123; /* */ &#125;;    // error: NoDerived is finalclass Bad2 : Last &#123; /* */ &#125;;        // error: Last is final</code></pre></li></ul><h3 id="15-2-3-类型转换和继承"><a href="#15-2-3-类型转换和继承" class="headerlink" title="15.2.3 类型转换和继承"></a>15.2.3 类型转换和继承</h3><ul><li>和内置指针一样，智能指针类也支持派生类到基类的类型转换，所以可以将一个派生类对象的指针存储在一个基类的智能指针内。</li><li>表达式的静态类型（static type）在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型（dynamic type）则是变量或表达式表示的内存中对象的类型，只有运行时才可知。</li><li>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。</li><li>不存在从基类到派生类的隐式类型转换，即使一个基类指针或引用绑定在一个派生类对象上也不行，因为编译器只能通过检查指针或引用的静态类型来判断转换是否合法。</li><li>不存在从基类到派生类的隐式类型转换，即使一个基类指针或引用绑定在一个派生类对象上也不行，因为编译器只能通过检查指针或引用的静态类型来判断转换是否合法。</li><li>如果已知某个基类到派生类的转换是安全的，可以使用static_cast强制覆盖掉编译器的检查工作。</li><li>派生类到基类的自动类型转换只对指针或引用有效，在派生类类型和基类类型之间不存在这种转换。</li><li>派生类到基类的转换允许我们给基类的拷贝&#x2F;移动操作传递一个派生类的对象，这些操作是基类定义的，只会处理基类自己的成员，派生类的部分被切掉（sliced down）了。<pre><code>Bulk_quote bulk;    // object of derived typeQuote item(bulk);   // uses the Quote::Quote(const Quote&amp;) constructoritem = bulk;        // calls Quote::operator=(const Quote&amp;)</code></pre></li><li>用一个派生类对象为一个基类对象初始化或赋值时，只有该对象中的基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略掉。</li></ul><h2 id="15-3-虚函数"><a href="#15-3-虚函数" class="headerlink" title="15.3 虚函数"></a>15.3 虚函数</h2><ul><li>当且仅当通过指针或引用调用虚函数时，才会在运行过程解析该调用，也只有在这种情况下对象的动态类型有可能与静态类型不同。</li><li>在派生类中覆盖某个虚函数时，可以再次使用virtual关键字说明函数性质，但这并非强制要求。因为一旦某个函数被声明为虚函数，则在所有派生类中它都是虚函数。</li><li>在派生类中覆盖某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。</li><li>派生类可以定义一个与基类中的虚函数名字相同但形参列表不同的函数，但编译器会认为该函数与基类中原有的函数是相互独立的，此时派生类的函数并没有覆盖掉基类中的版本。</li><li>C++11允许派生类使用override关键字显式地注明虚函数。如果override标记了某个函数，但该函数并没有覆盖已存在的虚函数，编译器将报告错误。override位于函数参数列表之后。<pre><code>struct B&#123;    virtual void f1(int) const;    virtual void f2();    void f3();&#125;;struct D1 : B &#123;    void f1(int) const override;    // ok: f1 matches f1 in the base    void f2(int) override;      // error: B has no f2(int) function    void f3() override;     // error: f3 not virtual    void f4() override;     // error: B doesn&#39;t have a function named f4&#125;</code></pre></li><li>与禁止类继承类似，函数也可以通过添加final关键字来禁止覆盖操作。<pre><code>struct D2 : B&#123;    // inherits f2() and f3() from B and overrides f1(int)    void f1(int) const final;   // subsequent classes can&#39;t override f1(int)&#125;;</code></pre></li><li>final和override关键字出现在形参列表（包括任何const或引用修饰符）以及尾置返回类型之后。</li><li>虚函数也可以有默认实参，每次函数调用的默认实参值由本次调用的静态类型决定。如果通过基类的指针或引用调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。</li><li>如果虚函数使用默认实参，则基类和派生类中定义的默认实参值最好一致。</li><li>使用作用域运算符::可以强制执行虚函数的某个版本，不进行动态绑定。<pre><code>// calls the version from the base class regardless of the dynamic type of basePdouble undiscounted = baseP-&gt;Quote::net_price(42);</code></pre></li><li>通常情况下，只有成员函数或友元中的代码才需要使用作用域运算符来回避虚函数的动态绑定机制。</li><li>如果一个派生类虚函数需要调用它的基类版本，但没有使用作用域运算符，则在运行时该调用会被解析为对派生类版本自身的调用，从而导致无限递归。</li></ul><h2 id="15-4-抽象基类"><a href="#15-4-抽象基类" class="headerlink" title="15.4 抽象基类"></a>15.4 抽象基类</h2><ul><li>在类内部虚函数声明语句的分号前添加&#x3D;0可以将一个虚函数声明为纯虚（pure virtual）函数。一个纯虚函数无须定义。<br>  <code>double net_price(std::size_t) const = 0;</code></li><li>可以为纯虚函数提供定义，但函数体必须定义在类的外部。</li><li>含有（或未经覆盖直接继承）纯虚函数的类是抽象基类。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。</li><li>不能创建抽象基类的对象。</li><li>派生类构造函数只初始化它的直接基类。</li><li>重构（refactoring）负责重新设计类的体系以便将操作或数据从一个类移动到另一个类中。</li></ul><h2 id="15-5-访问控制与继承"><a href="#15-5-访问控制与继承" class="headerlink" title="15.5 访问控制与继承"></a>15.5 访问控制与继承</h2><ul><li>一个类可以使用protected关键字来声明外部代码无法访问，但是派生类对象可以访问的成员。</li><li>派生类的成员或友元只能通过派生类对象来访问基类的protected成员。派生类对于一个基类对象中的protected成员没有任何访问权限。<pre><code>class Base&#123;protected:    int prot_mem;   // protected member&#125;;class Sneaky : public Base&#123;    friend void clobber(Sneaky&amp;);   // can access Sneaky::prot_mem    friend void clobber(Base&amp;);     // can&#39;t access Base::prot_mem    int j;   // j is private by default&#125;;// ok: clobber can access the private and protected members in Sneaky objectsvoid clobber(Sneaky &amp;s) &#123; s.j = s.prot_mem = 0; &#125;// error: clobber can&#39;t access the protected members in Basevoid clobber(Base &amp;b) &#123; b.prot_mem = 0; &#125;</code></pre></li><li>基类中成员的访问说明符和派生列表中的访问说明符都会影响某个类对其继承成员的访问权限。</li><li>派生访问说明符对于派生类的成员及友元能否访问其直接基类的成员没有影响，对基类成员的访问权限只与基类中的访问说明符有关。</li><li>派生访问说明符的作用是控制派生类（包括派生类的派生类）用户对于基类成员的访问权限。<ul><li>如果使用公有继承，则基类的公有成员和受保护成员在派生类中属性不发生改变。</li><li>如果使用受保护继承，则基类的公有成员和受保护成员在派生类中变为受保护成员。</li><li>如果使用私有继承，则基类的公有成员和受保护成员在派生类中变为私有成员。</li></ul></li><li>派生类到基类转换的可访问性（假定D继承自B）：<ul><li>只有当D公有地继承B时，用户代码才能使用派生类到基类的转换。</li><li>不论D以什么方式继承B，D的成员函数和友元都能使用派生类到基类的转换。</li><li>如果D继承B的方式是公有的或者受保护的，则D的派生类的成员函数和友元可以使用D到B的类型转换；反之，如果D继承B的方式是私有的，则不能使用。</li></ul></li><li>对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类到基类的类型转换也是可访问的。</li><li>友元对基类的访问权限由基类自身控制，即使对于派生类中的基类部分也是如此。<pre><code>class Base&#123;    // added friend declaration; other members as before    friend class Pal;   // Pal has no access to classes derived from Base&#125;;class Pal&#123;public:    int f(Base b) &#123; return b.prot_mem; &#125;     // ok: Pal is a friend of Base    int f2(Sneaky s) &#123; return s.j; &#125;         // error: Pal not friend of Sneaky    // access to a base class is controlled by the base class, even inside a derived object    int f3(Sneaky s) &#123; return s.prot_mem; &#125;  // ok: Pal is a friend&#125;;</code></pre></li><li>友元关系不能继承，每个类负责控制各自成员的访问权限。</li><li>使用using声明可以改变派生类继承的某个名字的访问级别。新的访问级别由该using声明之前的访问说明符决定。</li><li>派生类只能为那些它可以访问的名字提供using声明。</li><li>默认情况下，使用class关键字定义的派生类是私有继承的，而使用struct关键字定义的派生类是公有继承的。</li><li>建议显式地声明派生类的继承方式，不要仅仅依赖于默认设置。</li></ul><h2 id="15-6-继承中的类作用域"><a href="#15-6-继承中的类作用域" class="headerlink" title="15.6 继承中的类作用域"></a>15.6 继承中的类作用域</h2><ul><li>当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。</li><li>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。</li><li>派生类定义的成员会隐藏同名的基类成员。<pre><code>struct Base&#123;protected:    int mem;&#125;;struct Derived : Base&#123;    int get_mem() &#123; return mem; &#125;   // returns Derived::mem  protected:    int mem;    // hides mem in the base&#125;;</code></pre></li><li>可以通过作用域运算符::来使用被隐藏的基类成员。<pre><code>struct Derived : Base&#123;    int get_base_mem() &#123; return Base::mem; &#125;    // ...&#125;;</code></pre></li><li>除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。</li><li>和其他函数一样，成员函数无论是否是虚函数都能被重载。</li><li>派生类可以覆盖重载函数的0个或多个实例。如果派生类希望所有的重载版本对它来说都是可见的，那么它就需要覆盖所有版本，或者一个也不覆盖。</li><li>有时一个类仅需覆盖重载集合中的一些而非全部函数，此时如果我们不得不覆盖基类中的每一个版本的话，操作会极其繁琐。为了简化操作，可以为重载成员提供using声明。using声明指定了一个函数名字但不指定形参列表，所以一条基类成员函数的using声明语句就可以把该函数的所有重载实例添加到派生类作用域中。<pre><code>class Base&#123;private:    int x;    public:    virtual void mf1() = 0;    virtual void mf1(int);    virtual void mf2();    void fm3();    void fm3(double);&#125;;class Derived : public Base&#123;public:    // 让Base内名为mf1和mf3的所有定义    // 在Derived作用域内可见    using Base::mf1;    using Base::mf3;    virtual void mf1();    void fm3();    void fm4();&#125;;</code></pre></li><li>类内使用using声明改变访问级别的规则同样适用于重载函数的名字。</li></ul><h2 id="15-7-构造函数与拷贝控制"><a href="#15-7-构造函数与拷贝控制" class="headerlink" title="15.7 构造函数与拷贝控制"></a>15.7 构造函数与拷贝控制</h2><h3 id="15-7-1-虚析构函数"><a href="#15-7-1-虚析构函数" class="headerlink" title="15.7.1 虚析构函数"></a>15.7.1 虚析构函数</h3><ul><li>一般来说，如果一个类需要析构函数，那么它也需要拷贝和赋值操作。但基类的析构函数不遵循该规则。</li><li>基类通常应该定义一个虚析构函数。</li><li>如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针会产生未定义的结果。</li><li>虚析构函数会阻止编译器为类合成移动操作。</li></ul><h3 id="15-7-2-合成拷贝控制与继承"><a href="#15-7-2-合成拷贝控制与继承" class="headerlink" title="15.7.2 合成拷贝控制与继承"></a>15.7.2 合成拷贝控制与继承</h3><ul><li>对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类直接基类的成员。</li><li>在实际编程中，如果基类没有默认、拷贝或移动构造函数，则一般情况下派生类也不会定义相应的操作。</li><li>因为基类缺少移动操作会阻止编译器为派生类合成自己的移动操作，所以当我们确实需要执行移动操作时，应该首先在基类中进行定义。</li></ul><h3 id="15-7-3-派生类的拷贝控制成员"><a href="#15-7-3-派生类的拷贝控制成员" class="headerlink" title="15.7.3 派生类的拷贝控制成员"></a>15.7.3 派生类的拷贝控制成员</h3><ul><li>当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类成员在内的整个对象。</li><li>当为派生类定义拷贝或移动构造函数时，通常使用对应的基类构造函数初始化对象的基类部分。</li><li>在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果想拷贝或移动基类部分，则必须在派生类的构造函数初始化列表中显式地使用基类的拷贝或移动构造函数。</li><li>派生类的赋值运算符必须显式地为其基类部分赋值。</li><li>派生类的析构函数只负责销毁派生类自己分配的资源。</li><li>如果构造函数或析构函数调用了某个虚函数，则应该执行与构造函数或析构函数所属类型相对应的虚函数版本。</li></ul><h3 id="15-7-4-继承的构造函数"><a href="#15-7-4-继承的构造函数" class="headerlink" title="15.7.4 继承的构造函数"></a>15.7.4 继承的构造函数</h3><ul><li>C++11新标准允许派生类重用（非常规方式继承）其直接基类定义的构造函数。继承方式是提供一条注明了直接基类名的using声明语句。</li><li>通常情况下，using声明语句只是令某个名字在当前作用域内可见。而作用于构造函数时，using声明将令编译器产生代码。对于基类的每个构造函数，编译器都会生成一个与其形参列表完全相同的派生类构造函数。如果派生类含有自己的数据成员，则这些成员会被默认初始化。</li><li>构造函数的using声明不会改变该函数的访问级别，不能指定explicit或constexpr属性。</li><li>定义在派生类中的构造函数会替换继承而来的具有相同形参列表的构造函数。</li><li>派生类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器会为其合成它们。</li><li>当一个基类构造函数含有默认实参时，这些默认值不会被继承。相反，派生类会获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认值的形参</li></ul><h3 id="15-8-容器和继承"><a href="#15-8-容器和继承" class="headerlink" title="15.8 容器和继承"></a>15.8 容器和继承</h3><ul><li>因为容器中不能保存不同类型的元素，所以不能把具有继承关系的多种类型的对象直接存储在容器中。容器不能和存在继承关系的类型兼容。如果想在容器中存储具有继承关系的对象，则应该存放基类的指针。</li></ul><h1 id="第16章-模板与泛型编程"><a href="#第16章-模板与泛型编程" class="headerlink" title="第16章 模板与泛型编程"></a>第16章 模板与泛型编程</h1><h2 id="16-1-定义模板"><a href="#16-1-定义模板" class="headerlink" title="16.1 定义模板"></a>16.1 定义模板</h2><h3 id="16-1-1-函数模板"><a href="#16-1-1-函数模板" class="headerlink" title="16.1.1 函数模板"></a>16.1.1 函数模板</h3><ul><li>函数模板可以用来生成针对特定类型的函数版本。</li><li>模板定义以关键字template开始，后跟一个模板参数列表（template parameter list）。模板参数列表以尖括号&lt;&gt;包围，内含用逗号分隔的一个或多个模板参数（template parameter）。<pre><code>template&lt;typename T&gt;int compare(const T &amp;v1,const T&amp;v2)&#123;    if(v1&lt;v2) return -1;    if(v2&lt;v1) return 1;    return 0;&#125;</code></pre></li><li>定义模板时，模板参数列表不能为空。</li><li>模板参数表示在类或函数定义中用到的类型或值。当使用模板时，需要显式或隐式地指定模板实参（template argument），并将其绑定到模板参数上。</li><li>使用函数模板时，编译器用推断出的模板参数来实例化（instantiate）一个特定版本的函数，这些生成的函数通常被称为模板的实例（instantiation）。<pre><code>// instantiates int compare(const int&amp;, const int&amp;)cout &lt;&lt; compare(1, 0) &lt;&lt; endl;    // T is int// instantiates int compare(const vector&lt;int&gt;&amp;, const vector&lt;int&gt;&amp;)vector&lt;int&gt; vec1&#123;1, 2, 3&#125;, vec2&#123;4, 5, 6&#125;;cout &lt;&lt; compare(vec1, vec2) &lt;&lt; endl;    // T is vector&lt;int&gt;</code></pre></li><li>模板类型参数（type parameter）可以用来指定函数的返回类型或参数类型，以及在函数体内用于变量声明和类型转换。类型参数前必须使用关键字class或typename。<pre><code>// ok: same type used for the return type and parametertemplate &lt;typename T&gt;T foo(T* p)&#123;    T tmp = *p; // tmp will have the type to which p points    // ...    return tmp;&#125;// error: must precede U with either typename or classtemplate &lt;typename T, U&gt; T calc(const T&amp;, const U&amp;);// ok: no distinction between typename and class in a template parameter listtemplate &lt;typename T, class U&gt; calc (const T&amp;, const U&amp;);</code></pre></li><li>建议使用typename而不是class来指定模板类型参数，这样更加直观。</li><li>模板非类型参数（nontype parameter）需要用特定的类型名来指定，表示一个值而非一个类型。非类型参数可以是整型、指向对象或函数类型的指针或左值引用。<pre><code>template&lt;unsigned N, unsigned M&gt;int compare(const char (&amp;p1)[N], const char (&amp;p2)[M])&#123;    return strcmp(p1, p2);&#125;int compare(const char (&amp;p1)[3], const char (&amp;p2)[4]);</code></pre></li><li>绑定到整型非类型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参必须具有静态的生存期，不能用普通局部变量或动态对象作为指针或引用非类型参数的实参。</li><li>函数模板也可以声明为inline或constexpr的，说明符放在模板参数列表之后，返回类型之前。<pre><code>// ok: inline specifier follows the template parameter listtemplate &lt;typename T&gt; inline T min(const T&amp;, const T&amp;);// error: incorrect placement of the inline specifierinline template &lt;typename T&gt; T min(const T&amp;, const T&amp;);</code></pre></li><li>模板程序应该尽量减少对实参类型的要求。</li><li>只有当模板的一个特定版本被实例化时，编译器才会生成代码。此时编译器需要掌握生成代码所需的信息，因此函数模板和类模板成员函数的定义通常放在头文件中。</li><li>使用模板时，所有不依赖于模板参数的名字都必须是可见的，这是由模板的设计者来保证的。模板设计者应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声明。</li><li>调用者负责保证传递给模板的实参能正确支持模板所要求的操作。</li></ul><h3 id="16-1-2-类模板"><a href="#16-1-2-类模板" class="headerlink" title="16.1.2 类模板"></a>16.1.2 类模板</h3><ul><li>使用一个类模板时，必须提供显式模板实参（explicit template argument）列表，编译器使用这些模板实参来实例化出特定的类。<pre><code>template &lt;typename T&gt;class Blob&#123;public:    Blob();    Blob(std::initializer_list&lt;T&gt; il);    void push_back(const T &amp;t) &#123; data-&gt;push_back(t); &#125;    void push_back(T &amp;&amp;t) &#123; data-&gt;push_back(std::move(t)); &#125;    // ...    private:    std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data;&#125;;Blob&lt;int&gt; ia;   // empty Blob&lt;int&gt;Blob&lt;int&gt; ia2 = &#123; 0, 1, 2, 3, 4 &#125;;    // Blob&lt;int&gt; with five elements// these definitions instantiate two distinct Blob typesBlob&lt;string&gt; names;     // Blob that holds stringsBlob&lt;double&gt; prices;    // different element type</code></pre></li><li>一个类模板的每个实例都形成一个独立的类，相互之间没有关联。</li><li>如果一个类模板中的代码使用了另一个模板，通常不会将一个实际类型（或值）的名字用作其模板实参，而是将模板自己的参数用作被使用模板的实参。</li><li>类模板的成员函数具有和类模板相同的模板参数，因此定义在类模板外的成员函数必须以关键字template开始，后跟类模板参数列表。<pre><code>template &lt;typename T&gt;ret-type Blob&lt;T&gt;::member-name(parm-list)</code></pre></li><li>默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化。</li><li>在类模板自己的作用域内，可以直接使用模板名而不用提供模板实参。<pre><code>template &lt;typename T&gt;class BlobPtr&#123;public:    // 类模板作用域内不需要写成BlobPtr&lt;T&gt;形式    BlobPtr&amp; operator++();&#125;// 类外定义时需要提供模板实参template &lt;typename T&gt;BlobPtr&lt;T&gt;&amp; BlobPtr&lt;T&gt;::operator++()&#123;    // 进入类模板作用域    BlobPtr Ret = *this;&#125;</code></pre></li><li>当一个类包含一个友元声明时，类与友元各自是否是模板并无关联。如果一个类模板包含一个非模板友元，则友元可以访问所有类模板实例。如果友元自身是模板，则类可以给所有友元模板实例授予访问权限，也可以只授权给特定实例。</li><li>一对一友元关系:为了引用模板的一个特定实例，必须首先声明模板自身。模板声明包括模板参数列表。<pre><code>// forward declarations needed for friend declarations in Blobtemplate &lt;typename&gt; class BlobPtr;template &lt;typename&gt; class Blob;    // needed for parameters in operator==template &lt;typename T&gt;bool operator==(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;);template &lt;typename T&gt;class Blob&#123;    // each instantiation of Blob grants access to the version of    // BlobPtr and the equality operator instantiated with the same type    friend class BlobPtr&lt;T&gt;;    friend bool operator==&lt;T&gt;(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;);&#125;;</code></pre></li><li>通用和特定的模板友元关系:为了让模板的所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。<pre><code>// forward declaration necessary to befriend a specific instantiation of a templatetemplate &lt;typename T&gt; class Pal;class C&#123; // C is an ordinary, nontemplate class    friend class Pal&lt;C&gt;;    // Pal instantiated with class C is a friend to C    // all instances of Pal2 are friends to C;    // no forward declaration required when we befriend all instantiations    template &lt;typename T&gt; friend class Pal2;&#125;;template &lt;typename T&gt;class C2&#123; // C2 is itself a class template    // each instantiation of C2 has the same instance of Pal as a friend    friend class Pal&lt;T&gt;;    // a template declaration for Pal must be in scope    // all instances of Pal2 are friends of each instance of C2, prior declaration needed    template &lt;typename X&gt; friend class Pal2;    // Pal3 is a nontemplate class that is a friend of every instance of C2    friend class Pal3;      // prior declaration for Pal3 not needed&#125;;</code></pre></li><li>C++11中，类模板可以将模板类型参数声明为友元。<pre><code>template &lt;typename Type&gt;class Bar&#123;    friend Type;   // grants access to the type used to instantiate Bar    // ...&#125;;</code></pre></li><li>C++11允许使用using为类模板定义类型别名。<pre><code>template&lt;typename T&gt; using twin = pair&lt;T, T&gt;;twin&lt;string&gt; authors;   // authors is a pair&lt;string, string&gt;</code></pre></li><li>类模板可以声明static成员。<pre><code>template &lt;typename T&gt;class Foo&#123;public:    static std::size_t count() &#123; return ctr; &#125;    private:    static std::size_t ctr;&#125;;// instantiates static members Foo&lt;string&gt;::ctr and Foo&lt;string&gt;::countFoo&lt;string&gt; fs;// all three objects share the same Foo&lt;int&gt;::ctr and Foo&lt;int&gt;::count membersFoo&lt;int&gt; fi, fi2, fi3;</code></pre></li><li>类模板的每个实例都有一个独有的static对象，而每个static成员必须有且只有一个定义。因此与定义模板的成员函数类似，static成员也应该定义成模板。<pre><code>template &lt;typename T&gt;size_t Foo&lt;T&gt;::ctr = 0;    // define and initialize ctr</code></pre></li></ul><h3 id="16-1-3-模板参数"><a href="#16-1-3-模板参数" class="headerlink" title="16.1.3 模板参数"></a>16.1.3 模板参数</h3><ul><li>模板参数遵循普通的作用域规则。与其他任何名字一样，模板参数会隐藏外层作用域中声明的相同名字。但是在模板内不能重用模板参数名。<pre><code>typedef double A;template &lt;typename A, typename B&gt;void f(A a, B b)&#123;    A tmp = a;   // tmp has same type as the template parameter A, not double    double B;    // error: redeclares template parameter B&#125;</code></pre></li><li>由于模板参数名不能重用，所以一个名字在一个特定模板参数列表中只能出现一次。</li><li>与函数参数一样，声明中模板参数的名字不必与定义中的相同。</li><li>一个特定文件所需要的所有模板声明通常一起放置在文件开始位置，出现在任何使用这些模板的代码之前</li><li>模板中的代码使用作用域运算符::时，编译器无法确定其访问的名字是类型还是static成员。</li><li>默认情况下，C++假定模板中通过作用域运算符访问的名字是static成员。因此，如果需要使用一个模板类型参数的类型成员，就必须使用关键字typename显式地告知编译器该名字是一个类型。<pre><code>template &lt;typename T&gt;typename T::value_type top(const T&amp; c)&#123;    if (!c.empty())        return c.back();    else        return typename T::value_type();&#125;</code></pre></li><li>C++11允许为函数和类模板提供默认实参。<pre><code>// compare has a default template argument, less&lt;T&gt;// and a default function argument, F()template &lt;typename T, typename F = less&lt;T&gt;&gt;int compare(const T &amp;v1, const T &amp;v2, F f = F())&#123;    if (f(v1, v2)) return -1;    if (f(v2, v1)) return 1;    return 0;&#125;</code></pre></li><li>如果一个类模板为其所有模板参数都提供了默认实参，在使用这些默认实参时，必须在模板名后面跟一个空尖括号对&lt;&gt;。<pre><code>template &lt;class T = int&gt;class Numbers&#123; // by default T is intpublic:    Numbers(T v = 0): val(v) &#123; &#125;    // various operations on numbersprivate:    T val;&#125;;Numbers&lt;long double&gt; lots_of_precision;Numbers&lt;&gt; average_precision;    // empty &lt;&gt; says we want the default type</code></pre></li></ul><h3 id="16-1-4-成员模板"><a href="#16-1-4-成员模板" class="headerlink" title="16.1.4 成员模板"></a>16.1.4 成员模板</h3><ul><li>一个类（无论是普通类还是模板类）可以包含本身是模板的成员函数，这种成员被称为成员模板。成员模板不能是虚函数。<pre><code>class DebugDelete&#123;public:    DebugDelete(std::ostream &amp;s = std::cerr): os(s) &#123; &#125;    // as with any function template, the type of T is deduced by the compiler    template &lt;typename T&gt;    void operator()(T *p) const    &#123;         os &lt;&lt; &quot;deleting unique_ptr&quot; &lt;&lt; std::endl;        delete p;    &#125;    private:    std::ostream &amp;os;&#125;;</code></pre></li><li>在类模板外定义一个成员模板的时候，必须同时为类模板和成员模板参数列表。<pre><code>template &lt;typename T&gt;class Blob&#123;    template &lt;typename It&gt;    Blob(It b, It e);&#125;;template &lt;typename T&gt;   // type parameter for the classtemplate &lt;typename It&gt;  // type parameter for the constructorBlob&lt;T&gt;::Blob(It b, It e):    data(std::make_shared&lt;std::vector&lt;T&gt;&gt;(b, e))    &#123; &#125;</code></pre></li><li>为了实例化一个类模板的成员模板，必须同时提供类和函数模板的实参。</li></ul><h3 id="16-1-5-控制实例化"><a href="#16-1-5-控制实例化" class="headerlink" title="16.1.5 控制实例化"></a>16.1.5 控制实例化</h3><ul><li>因为模板在使用时才会进行实例化，所以相同的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中都会有该模板的一个实例。</li><li>在大型程序中，多个文件实例化相同模板的额外开销可能非常严重。C++11允许通过显式实例化（explicit instantiation）来避免这种开销。<pre><code>extern template declaration;    // instantiation declarationtemplate declaration;           // instantiation definition</code></pre></li><li>declaration是一个类或函数声明，其中所有模板参数已被替换为模板实参。当编译器遇到extern模板声明时，它不会在本文件中生成实例化代码。对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。<pre><code>// templateBuild.cc// instantiation file must provide a (nonextern) definition for every// type and function that other files declare as externtemplate int compare(const int&amp;, const int&amp;);template class Blob&lt;string&gt;;    // instantiates all members of the class template// Application.cc// these template types must be instantiated elsewhere in the programextern template class Blob&lt;string&gt;;extern template int compare(const int&amp;, const int&amp;);Blob&lt;string&gt; sa1, sa2;    // instantiation will appear elsewhere// Blob&lt;int&gt; and its initializer_list constructor instantiated in this fileBlob&lt;int&gt; a1 = &#123; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;;Blob&lt;int&gt; a2(a1);    // copy constructor instantiated in this fileint i = compare(a1[0], a2[0]);    // instantiation will appear elsewhere</code></pre></li><li>当编译器遇到类模板的实例化定义时，它不清楚程序会使用哪些成员函数。和处理类模板的普通实例化不同，编译器会实例化该模板的所有成员，包括内联的成员函数。因此，用来显式实例化类模板的类型必须能用于模板的所有成员。</li></ul><h3 id="16-1-6-效率与灵活性"><a href="#16-1-6-效率与灵活性" class="headerlink" title="16.1.6 效率与灵活性"></a>16.1.6 效率与灵活性</h3><ul><li>unique_ptr在编译时绑定删除器，避免了间接调用删除器的运行时开销。shared_ptr在运行时绑定删除器，使用户重载删除器的操作更加简便。</li></ul><h2 id="16-2-模板实参推断"><a href="#16-2-模板实参推断" class="headerlink" title="16.2 模板实参推断"></a>16.2 模板实参推断</h2><ul><li>对于函数模板，编译器通过调用的函数实参来确定其模板参数。这个过程被称作<strong>模板实参推断</strong>。</li></ul><h3 id="16-2-1-类型转换与模板类型参数"><a href="#16-2-1-类型转换与模板类型参数" class="headerlink" title="16.2.1 类型转换与模板类型参数"></a>16.2.1 类型转换与模板类型参数</h3><ul><li>与非模板函数一样，调用函数模板时传递的实参被用来初始化函数的形参。如果一个函数形参的类型使用了模板类型参数，则会采用特殊的初始化规则，只有有限的几种类型转换会自动地应用于这些实参。编译器通常会生成新的模板实例而不是对实参进行类型转换。</li><li>有3种类型转换可以在调用中应用于函数模板：<ul><li>顶层const会被忽略。</li><li>可以将一个非const对象的引用或指针传递给一个const引用或指针形参。</li><li>如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。数组实参可以转换为指向其首元素的指针。函数实参可以转换为该函数类型的指针。</li></ul></li><li>其他的类型转换，如算术转换、派生类向基类的转换以及用户定义的转换，都不能应用于函数模板。</li><li>一个模板类型参数可以作为多个函数形参的类型。由于允许的类型转换有限，因此传递给这些形参的实参必须具有相同的类型，否则调用失败。</li><li>如果想增强函数的兼容性，可以使用两个类型参数定义函数模板。<pre><code>// argument types can differ but must be compatibletemplate &lt;typename A, typename B&gt;int flexibleCompare(const A&amp; v1, const B&amp; v2)&#123;    if (v1 &lt; v2) return -1;    if (v2 &lt; v1) return 1;    return 0;&#125;long lng;flexibleCompare(lng, 1024);   // ok: calls flexibleCompare(long, int)</code></pre></li><li>函数模板中使用普通类型定义的参数可以进行正常的类型转换.<pre><code>template &lt;typename T&gt;ostream &amp;print(ostream &amp;os, const T &amp;obj)&#123;    return os &lt;&lt; obj;&#125;print(cout, 42);   // instantiates print(ostream&amp;, int)ofstream f(&quot;output&quot;);print(f, 10);      // uses print(ostream&amp;, int); converts f to ostream&amp;</code></pre></li></ul><h3 id="16-2-2-函数模板显示实参"><a href="#16-2-2-函数模板显示实参" class="headerlink" title="16.2.2 函数模板显示实参"></a>16.2.2 函数模板显示实参</h3><ul><li>某些情况下，编译器无法推断出模板实参的类型。<pre><code>// T1 cannot be deduced: it doesn&#39;t appear in the function parameter listtemplate &lt;typename T1, typename T2, typename T3&gt;T1 sum(T2, T3);</code></pre></li><li>显式模板实参（explicit template argument）可以让用户自己控制模板的实例化。提供显式模板实参的方式与定义类模板实例的方式相同。显式模板实参在尖括号&lt;&gt;中指定，位于函数名之后，实参列表之前。<pre><code>// T1 is explicitly specified; T2 and T3 are inferred from the argument typesauto val3 = sum&lt;long long&gt;(i, lng);   // long long sum(int, long)</code></pre></li><li>显式模板实参按照从左到右的顺序与对应的模板参数匹配，只有尾部参数的显式模板实参才可以忽略，而且前提是它们可以从函数参数推断出来。<pre><code>// poor design: users must explicitly specify all three template parameterstemplate &lt;typename T1, typename T2, typename T3&gt;T3 alternative_sum(T2, T1);// error: can&#39;t infer initial template parametersauto val3 = alternative_sum&lt;long long&gt;(i, lng);// ok: all three parameters are explicitly specifiedauto val2 = alternative_sum&lt;long long, int, long&gt;(i, lng);</code></pre></li><li>对于模板类型参数已经显式指定了的函数实参，可以进行正常的类型转换。<pre><code>long lng;compare(lng, 1024);         // error: template parameters don&#39;t matchcompare&lt;long&gt;(lng, 1024);   // ok: instantiates compare(long, long)compare&lt;int&gt;(lng, 1024);    // ok: instantiates compare(int, int)</code></pre></li></ul><h3 id="16-2-3-尾置返回类型与类型转换"><a href="#16-2-3-尾置返回类型与类型转换" class="headerlink" title="16.2.3 尾置返回类型与类型转换"></a>16.2.3 尾置返回类型与类型转换</h3><ul><li>由于尾置返回出现在函数列表之后，因此它可以使用函数参数来声明返回类型。<pre><code>// a trailing return lets us declare the return type after the parameter list is seentemplate &lt;typename It&gt;auto fcn(It beg, It end) -&gt; decltype(*beg)&#123;    // process the range    return *beg;   // return a reference to an element from the range&#125;</code></pre></li><li>标准库在头文件type_traits中定义了类型转换模板，这些模板常用于模板元程序设计。其中每个模板都有一个名为type的公有类型成员，表示一个类型。此类型与模板自身的模板类型参数相关。如果不可能（或不必要）转换模板参数，则type成员就是模板参数类型本身。<img src="/2020/01/09/c/c-primer/%E8%A1%A816.1.png" class="" title="表16.1.png">)</li><li>使用remove_reference可以获得引用对象的元素类型，如果用一个引用类型实例化remove_reference，则type表示被引用的类型。因为type是一个类的类型成员，所以在模板中必须使用关键字typename来告知编译器其表示一个类型。<pre><code>// must use typename to use a type member of a template parametertemplate &lt;typename It&gt;auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;::type&#123;    // process the range    return *beg;  // return a copy of an element from the range&#125;</code></pre></li></ul><h3 id="16-2-4-函数指针和实参推断"><a href="#16-2-4-函数指针和实参推断" class="headerlink" title="16.2.4 函数指针和实参推断"></a>16.2.4 函数指针和实参推断</h3><ul><li>使用函数模板初始化函数指针或为函数指针赋值时，编译器用指针的类型来推断模板实参。<pre><code>template &lt;typename T&gt; int compare(const T&amp;, const T&amp;);// pf1 points to the instantiation int compare(const int&amp;, const int&amp;)int (*pf1)(const int&amp;, const int&amp;) = compare;</code></pre></li></ul><h3 id="16-2-5-模板实参推断和引用"><a href="#16-2-5-模板实参推断和引用" class="headerlink" title="16.2.5 模板实参推断和引用"></a>16.2.5 模板实参推断和引用</h3><ul><li>当一个函数参数是模板类型参数的普通（左值）引用（形如T&amp;）时，只能传递给它一个左值（如一个变量或一个返回引用类型的表达式）。T被推断为实参所引用的类型，如果实参是const的，则T也为const类型。<pre><code>template &lt;typename T&gt; void f1(T&amp;);    // argument must be an lvalue// calls to f1 use the referred-to type of the argument as the template parameter typef1(i);     // i is an int; template parameter T is intf1(ci);    // ci is a const int; template parameter T is const intf1(5);     // error: argument to a &amp; parameter must be an lvalue</code></pre></li><li>当一个函数参数是模板类型参数的常量引用（形如const T&amp;）时，可以传递给它任何类型的实参。函数参数本身是const时，T的类型推断结果不会是const类型。const已经是函数参数类型的一部分了，因此不会再是模板参数类型的一部分。<pre><code>template &lt;typename T&gt; void f2(const T&amp;);    // can take an rvalue// parameter in f2 is const &amp;; const in the argument is irrelevant// in each of these three calls, f2&#39;s function parameter is inferred as const int&amp;f2(i);     // i is an int; template parameter T is intf2(ci);    // ci is a const int, but template parameter T is intf2(5);     // a const &amp; parameter can be bound to an rvalue; T is int</code></pre></li><li>当一个函数参数是模板类型参数的右值引用（形如T&amp;&amp;）时，如果传递给它一个右值，类型推断过程类似普通左值引用函数参数的推断过程，推断出的T类型是该右值实参的类型。<pre><code>template &lt;typename T&gt; void f3(T&amp;&amp;);f3(42);    // argument is an rvalue of type int; template parameter T is int</code></pre></li><li>模板参数绑定的两个例外规则：<ul><li>如果将一个左值传递给函数的右值引用参数，且此右值引用指向模板类型参数时，编译器推断模板类型参数为实参的左值引用类型。</li><li>如果间接创建了一个引用的引用（通过类型别名或者模板类型参数间接定义），则这些引用会被“折叠”。右值引用的右值引用会被折叠为右值引用。其他情况下，引用都被折叠为普通左值引用。</li></ul></li><li>模板参数绑定的两个例外规则导致了两个结果：<ul><li>如果一个函数参数是指向模板类型参数的右值引用，则可以传递给它任意类型的实参。</li><li>如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用。</li></ul></li><li>当代码中涉及的类型可能是普通（非引用）类型，也可能是引用类型时，编写正确的代码就变得异常困难。</li><li>实际编程中，模板的右值引用参数通常用于两种情况：模板转发其实参或者模板被重载。函数模板的常用重载形式如下：<pre><code>template &lt;typename T&gt; void f(T&amp;&amp;);         // binds to nonconst rvaluestemplate &lt;typename T&gt; void f(const T&amp;);    // lvalues and const rvalues</code></pre></li></ul><h3 id="16-2-6-理解std-move"><a href="#16-2-6-理解std-move" class="headerlink" title="16.2.6 理解std::move"></a>16.2.6 理解std::move</h3><ul><li>std::move的定义如下：<pre><code>template &lt;typename T&gt;typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; t)&#123;    return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);&#125;</code></pre></li><li>std::move的工作过程：<pre><code>string s1(&quot;hi!&quot;), s2;s2 = std::move(string(&quot;bye!&quot;));     // ok: moving from an rvalues2 = std::move(s1);     // ok: but after the assigment s1 has indeterminate value</code></pre></li><li>在std::move(string(“bye!”))中传递的是右值。<ul><li>推断出的T类型为string。</li><li>remove_reference用string进行实例化。</li><li>remove_reference<string>的type成员是string。</li><li>move的返回类型是string&amp;&amp;。</li><li>move的函数参数t的类型为string&amp;&amp;。</li></ul></li><li>在std::move(s1)中传递的是左值。<ul><li>推断出的T类型为string&amp;。</li><li>remove_reference用string&amp;进行实例化。</li><li>remove_reference&lt;string&amp;&gt;的type成员是string。</li><li>move的返回类型是string&amp;&amp;。</li><li>move的函数参数t的类型为string&amp; &amp;&amp;，会折叠成string&amp;。</li></ul></li><li>可以使用static_cast显式地将一个左值转换为一个右值引用。</li></ul><h3 id="16-2-7-转发"><a href="#16-2-7-转发" class="headerlink" title="16.2.7 转发"></a>16.2.7 转发</h3><ul><li>某些函数需要将其一个或多个实参连同类型不变地转发给其他函数。在这种情况下，需要保持被转发实参的所有性质，包括实参的const属性以及左值&#x2F;右值属性。<pre><code>// template that takes a callable and two parameters// and calls the given callable with the parameters &#39;&#39;flipped&#39;&#39;// flip1 is an incomplete implementation: top-level const and references are losttemplate &lt;typename F, typename T1, typename T2&gt;void flip1(F f, T1 t1, T2 t2)&#123;    f(t2, t1);&#125;void f(int v1, int &amp;v2)   // note v2 is a reference&#123;    cout &lt;&lt; v1 &lt;&lt; &quot; &quot; &lt;&lt; ++v2 &lt;&lt; endl;&#125;f(42, i);   // f changes its argument iflip1(f, j, 42);    // f called through flip1 leaves j unchanged                    // void flip1(void(*fcn)(int, int&amp;), int t1, int t2)</code></pre></li><li>上例中，j被传递给flip1的参数t1，该参数是一个普通（非引用）类型int，而非int&amp;，因此flip1(f, j, 42)调用会被实例化为void flip1(void(*fcn)(int, int&amp;), int t1, int t2)。j的值被拷贝至t1中，f中的引用参数被绑定至t1，而非j，因此j不会被修改。</li><li>将函数参数定义为指向模板类型参数的右值引用（形如T&amp;&amp;），通过引用折叠，可以保持翻转实参的左值&#x2F;右值属性。并且引用参数（无论是左值还是右值）可以保持实参的const属性，因为在引用类型中的const是底层的。<pre><code>template &lt;typename F, typename T1, typename T2&gt;void flip2(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)&#123;    f(t2, t1);&#125;</code></pre></li><li>对于修改后的版本，若调用flip2(f, j, 42)，会传递给参数t1一个左值j，但此时推断出的T1类型为int&amp;，t1的类型会被折叠为int&amp;，从而解决了flip1的错误。</li><li>但flip2只能用于接受左值引用的函数，不能用于接受右值引用的函数。函数参数与其他变量一样，都是左值表达式。所以即使是指向模板类型的右值引用参数也只能传递给接受左值引用的函数，不能传递给接受右值引用的函数。<pre><code>void g(int &amp;&amp;i, int&amp; j)&#123;    cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;&#125;// error: can&#39;t initialize int&amp;&amp; from an lvalueflip2(g, i, 42);  // flip2 passes an lvalue to g’s rvalue reference parameter</code></pre></li><li>C++11在头文件utility中定义了forward。与move不同，forward必须通过显式模板实参调用，返回该显式实参类型的右值引用。即forward<T>返回类型T&amp;&amp;。</li><li>通常情况下，可以使用forward传递定义为指向模板类型参数的右值引用函数参数。通过其返回类型上的引用折叠，forward可以保持给定实参的左值&#x2F;右值属性<pre><code>template &lt;typename Type&gt;intermediary(Type &amp;&amp;arg)&#123;    finalFcn(std::forward&lt;Type&gt;(arg));    // ...&#125;</code></pre><ul><li>如果实参是一个右值，则Type是一个普通（非引用）类型，forward<Type>返回类型Type&amp;&amp;。</li><li>如果实参是一个左值，则通过引用折叠，Type也是一个左值引用类型，forward<Type>返回类型Type&amp;&amp; &amp;，对返回 类型进行引用折叠，得到Type&amp;。</li></ul></li><li>使用forward编写完善的转发函数。<pre><code>template &lt;typename F, typename T1, typename T2&gt;void flip(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)&#123;    f(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));&#125;</code></pre></li><li>与std::move一样，对std::forward也不应该使用using声明。</li></ul><h2 id="16-3-重载与模板"><a href="#16-3-重载与模板" class="headerlink" title="16.3 重载与模板"></a>16.3 重载与模板</h2><ul><li>函数模板可以被另一个模板或普通非模板函数重载。</li><li>如果重载涉及函数模板，则函数匹配规则会受到一些影响：<ul><li>对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例。</li><li>候选的函数模板都是可行的，因为模板实参推断会排除任何不可行的模板。</li><li>和往常一样，可行函数（模板与非模板）按照类型转换（如果需要的话）来排序。但是可以用于函数模板调用的类型转换非常有限。</li><li>和往常一样，如果恰有一个函数提供比其他任何函数都更好的匹配，则选择此函数。但是如果多个函数都提供相同级别的匹配，则：<ul><li>如果同级别的函数中只有一个是非模板函数，则选择此函数。</li><li>如果同级别的函数中没有非模板函数，而有多个函数模板，且其中一个模板比其他模板更特例化，则选择此模板。</li><li>否则该调用有歧义。</li></ul></li></ul></li><li>通常，如果使用了一个没有声明的函数，代码将无法编译。但对于重载函数模板的函数而言，如果编译器可以从模板实例化出与调用匹配的版本，则缺少的声明就不再重要了。<pre><code>template &lt;typename T&gt; string debug_rep(const T &amp;t);template &lt;typename T&gt; string debug_rep(T *p);// the following declaration must be in scope// for the definition of debug_rep(char*) to do the right thingstring debug_rep(const string &amp;);string debug_rep(char *p)&#123;    // if the declaration for the version that takes a const string&amp; is not in scope    // the return will call debug_rep(const T&amp;) with T instantiated to string    return debug_rep(string(p));&#125;</code></pre></li><li>在定义任何函数之前，应该声明所有重载的函数版本。这样编译器就不会因为未遇到你希望调用的函数而实例化一个并非你所需要的版本。</li></ul><h2 id="16-4-可变参数模板"><a href="#16-4-可变参数模板" class="headerlink" title="16.4 可变参数模板"></a>16.4 可变参数模板</h2><ul><li>可变参数模板指可以接受可变数量参数的模板函数或模板类。可变数量的参数被称为参数包（parameter pack），分为两种：<ul><li>模板参数包（template parameter pack），表示零个或多个模板参数。</li><li>函数参数包（function parameter pack），表示零个或多个函数参数。</li></ul></li><li>用一个省略号…来指出模板参数或函数参数表示一个包。在一个模板参数列表中，class…或typename…指出接下来的参数表示零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数列表。在函数参数列表中，如果一个参数的类型是模板参数包，则此参数也是函数参数包。<pre><code>// Args is a template parameter pack; rest is a function parameter pack// Args represents zero or more template type parameters// rest represents zero or more function parameterstemplate &lt;typename T, typename... Args&gt;void foo(const T &amp;t, const Args&amp; ... rest);</code></pre></li><li>对于一个可变参数模板，编译器会推断模板参数类型和参数数量</li><li>可以使用sizeof…运算符获取参数包中的元素数量。类似sizeof，sizeof…也返回一个常量表达式，而且不会对其实参求值。<pre><code>template&lt;typename ... Args&gt;void g(Args ... args)&#123;    cout &lt;&lt; sizeof...(Args) &lt;&lt; endl;    // number of type parameters    cout &lt;&lt; sizeof...(args) &lt;&lt; endl;    // number of function parameters&#125;</code></pre></li></ul><h3 id="16-4-1-编写可变参数函数模板"><a href="#16-4-1-编写可变参数函数模板" class="headerlink" title="16.4.1 编写可变参数函数模板"></a>16.4.1 编写可变参数函数模板</h3><ul><li>可变参数函数通常是递归的，第一步调用参数包中的第一个实参，然后用剩余实参调用自身。为了终止递归，还需要定义一个非可变参数的函数。<pre><code>// function to end the recursion and print the last element// this function must be declared before the variadic version of print is definedtemplate&lt;typename T&gt;ostream &amp;print(ostream &amp;os, const T &amp;t)&#123;    return os &lt;&lt; t;   // no separator after the last element in the pack&#125;// this version of print will be called for all but the last element in the packtemplate &lt;typename T, typename... Args&gt;ostream &amp;print(ostream &amp;os, const T &amp;t, const Args&amp;... rest)&#123;    os &lt;&lt; t &lt;&lt; &quot;, &quot;;    // print the first argument    return print(os, rest...);   // recursive call; print the other arguments&#125;</code></pre></li></ul><h3 id="16-4-2-包扩展"><a href="#16-4-2-包扩展" class="headerlink" title="16.4.2 包扩展"></a>16.4.2 包扩展</h3><ul><li>对于一个参数包，除了获取其大小外，唯一能对它做的事情就是扩展。当扩展一个包时，需要提供用于每个扩展元素的模式（pattern）。扩展一个包就是将其分解为构成的元素，对每个元素应用模式，获得扩展后的列表。通过在模式右边添加一个省略号…来触发扩展操作。<pre><code>template &lt;typename T, typename... Args&gt;ostream&amp; print(ostream &amp;os, const T &amp;t, const Args&amp;... rest)   // expand Args&#123;    os &lt;&lt; t &lt;&lt; &quot;, &quot;;    return print(os, rest...);   // expand rest&#125;</code></pre><ul><li>第一个扩展操作扩展模板参数包，为print生成函数参数列表。编译器将模式const Args&amp;应用到模板参数包Args中的每个元素上。因此该模式的扩展结果是一个以逗号分隔的零个或多个类型的列表，每个类型都形如const type&amp;。</li></ul><pre><code>print(cout, i, s, 42);   // two parameters in the packostream&amp; print(ostream&amp;, const int&amp;, const string&amp;, const int&amp;);</code></pre><ul><li>第二个扩展操作扩展函数参数包，模式是函数参数包的名字。扩展结果是一个由包中元素组成、以逗号分隔的列表。</li></ul><p>  <code>print(os, s, 42);</code></p></li><li>扩展操作中的模式会独立地应用于包中的每个元素。<pre><code>// call debug_rep on each argument in the call to printtemplate &lt;typename... Args&gt;ostream &amp;errorMsg(ostream &amp;os, const Args&amp;... rest)&#123;    // print(os, debug_rep(a1), debug_rep(a2), ..., debug_rep(an)    return print(os, debug_rep(rest)...);&#125;// passes the pack to debug_rep; print(os, debug_rep(a1, a2, ..., an))print(os, debug_rep(rest...));   // error: no matching function to call</code></pre></li></ul><h3 id="16-4-3-转发参数包（Forwarding-Parameter-Packs）"><a href="#16-4-3-转发参数包（Forwarding-Parameter-Packs）" class="headerlink" title="16.4.3 转发参数包（Forwarding Parameter Packs）"></a>16.4.3 转发参数包（Forwarding Parameter Packs）</h3><ul><li>在C++11中，可以组合使用可变参数模板和forward机制来编写函数，实现将其实参不变地传递给其他函数。<pre><code>// fun has zero or more parameters each of which is// an rvalue reference to a template parameter typetemplate&lt;typename... Args&gt;void fun(Args&amp;&amp;... args)    // expands Args as a list of rvalue references&#123;    // the argument to work expands both Args and args    work(std::forward&lt;Args&gt;(args)...);&#125;</code></pre></li></ul><h2 id="16-5-模板特例化"><a href="#16-5-模板特例化" class="headerlink" title="16.5 模板特例化"></a>16.5 模板特例化</h2><ul><li>在某些情况下，通用模板的定义对特定类型是不合适的，可能编译失败或者操作不正确。如果不希望或不能使用模板版本时，可以定义类或函数模板的特例化版本。一个特例化版本就是模板的一个独立定义，其中的一个或多个模板参数被指定为特定类型。<pre><code>// first version; can compare any two typestemplate &lt;typename T&gt; int compare(const T&amp;, const T&amp;);// second version to handle string literalstemplate&lt;size_t N, size_t M&gt;int compare(const char (&amp;)[N], const char (&amp;)[M]);const char *p1 = &quot;hi&quot;, *p2 = &quot;mom&quot;;compare(p1, p2);        // calls the first templatecompare(&quot;hi&quot;, &quot;mom&quot;);   // calls the template with two nontype parameters// special version of compare to handle pointers to character arraystemplate &lt;&gt;int compare(const char* const &amp;p1, const char* const &amp;p2)&#123;    return strcmp(p1, p2);&#125;</code></pre></li><li>特例化一个函数模板时，必须为模板中的每个模板参数都提供实参。为了指明我们正在实例化一个模板，应该在关键字template后面添加一个空尖括号对&lt;&gt;。</li><li>特例化版本的参数类型必须与一个先前声明的模板中对应的类型相匹配。</li><li>定义特例化函数版本本质上是接管编译器的工作，为模板的一个特殊实例提供了定义。特例化并非重载，因此不影响函数匹配。</li><li>将一个特殊版本的函数定义为特例化模板还是独立的非模板函数会影响到重载函数匹配。</li><li>模板特例化遵循普通作用域规则。为了特例化一个模板，原模板的声明必须在作用域中。而使用模板实例时，也必须先包含特例化版本的声明。</li><li>通常，模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明放在文件开头，后面是这些模板的特例化版本。</li><li>类模板也可以特例化。与函数模板不同，类模板的特例化不必为所有模板参数提供实参，可以只指定一部分模板参数。一个类模板的部分特例化（partial specialization）版本本身还是一个模板，用户使用时必须为那些未指定的模板参数提供实参。</li><li>只能部分特例化类模板，不能部分特例化函数模板。</li><li>由于类模板的部分特例化版本是一个模板，所以需要定义模板参数。对于每个未完全确定类型的模板参数，在特例化版本的模板参数列表中都有一项与之对应。在类名之后，需要为特例化的模板参数指定实参，这些实参位于模板名之后的尖括号中，与原始模板中的参数按位置相对应。<pre><code>// 通用版本template &lt;typename T&gt;struct remove_reference&#123;    typedef T type;&#125;;// 部分特例化版本template &lt;typename T&gt;struct remove_reference&lt;T &amp;&gt;   // 左值引用&#123;    typedef T type;&#125;;template &lt;typename T&gt;struct remove_reference&lt;T &amp;&amp;&gt;  // 右值引用&#123;    typedef T type;&#125;;</code></pre></li><li>类模板部分特例化版本的模板参数列表是原始模板参数列表的一个子集或特例化版本。</li><li>可以只特例化类模板的指定成员函数，而不用特例化整个模板。<pre><code>template &lt;typename T&gt;struct Foo&#123;    Foo(const T &amp;t = T()): mem(t) &#123; &#125;    void Bar() &#123; /* ... */ &#125;    T mem;    // other members of Foo&#125;;template&lt;&gt;      // we&#39;re specializing a templatevoid Foo&lt;int&gt;::Bar()    // we&#39;re specializing the Bar member of Foo&lt;int&gt;&#123;    // do whatever specialized processing that applies to ints&#125;Foo&lt;string&gt; fs;     // instantiates Foo&lt;string&gt;::Foo()fs.Bar();    // instantiates Foo&lt;string&gt;::Bar()Foo&lt;int&gt; fi;    // instantiates Foo&lt;int&gt;::Foo()fi.Bar();    // uses our specialization of Foo&lt;int&gt;::Bar()</code></pre></li></ul><h1 id="第17章-标准库特殊设施"><a href="#第17章-标准库特殊设施" class="headerlink" title="第17章 标准库特殊设施"></a>第17章 标准库特殊设施</h1><h2 id="17-1-tuple类型"><a href="#17-1-tuple类型" class="headerlink" title="17.1 tuple类型"></a>17.1 tuple类型</h2><ul><li>tuple是类似pair的模板，定义在头文件tuple中。与pair不同，tuple可以有任意数量的成员。如果希望将一些数据组合成单一对象，但又不想定义新数据结构时，可以使用tuple（“快速而随意”的数据结构）。<img src="/2020/01/09/c/c-primer/%E8%A1%A817.1.png" class="" title="表17.1.png">)</li></ul><h3 id="17-1-1-定义和初始化tuple（Defining-and-Initializing-tuples）"><a href="#17-1-1-定义和初始化tuple（Defining-and-Initializing-tuples）" class="headerlink" title="17.1.1 定义和初始化tuple（Defining and Initializing tuples）"></a>17.1.1 定义和初始化tuple（Defining and Initializing tuples）</h3><ul><li>定义tuple时需要指定每个成员的类型。创建tuple对象时，可以使用tuple的默认构造函数，它会对每个成员进行值初始化。或者给每个成员提供初始值。包含初始值的构造函数是explicit的，因此必须使用直接初始化语法。<pre><code>tuple&lt;size_t, size_t, size_t&gt; threeD = &#123; 1, 2, 3 &#125;;   // errortuple&lt;size_t, size_t, size_t&gt; threeD&#123; 1, 2, 3 &#125;;      // ok</code></pre></li><li>类似make_pair，make_tuple函数可以生成tuple对象。tuple的类型由初始值决定。</li><li>可以使用get访问tuple的成员。get是一个函数模板，使用时必须指定一个显式模板实参，表示要访问的成员索引。传递给get一个tuple实参后，会返回其指定成员的引用。<pre><code>auto book = get&lt;0&gt;(item);    // returns the first member of itemauto cnt = get&lt;1&gt;(item);     // returns the second member of itemauto price = get&lt;2&gt;(item)/cnt;    // returns the last member of itemget&lt;2&gt;(item) *= 0.8;    // apply 20% discount</code></pre></li><li>可以使用tuple_size和tuple_element这两个辅助类模板查询tuple成员的数量和类型。<ul><li>tuple_size通过一个tuple类型来初始化，它有一个名为value的静态公有数据成员，类型为size_t，表示给定tuple中成员的数量。</li><li>tuple_element通过一个索引值（整型常量）和一个tuple类型来初始化，它有一个名为type的公有数据成员，表示给定tuple中指定成员的类型。</li><li>使用decltype可以确定一个对象的类型。</li></ul><pre><code>typedef decltype(item) trans;    // trans is the type of item// returns the number of members in object&#39;s of type transsize_t sz = tuple_size&lt;trans&gt;::value;    // returns 3// cnt has the same type as the second member in itemtuple_element&lt;1, trans&gt;::type cnt = get&lt;1&gt;(item);    // cnt is an int</code></pre></li><li>tuple的关系和相等运算符逐对比较两个tuple对象的成员。只有当两个tuple的成员数量相等时才可以进行比较。使用tuple的相等或不等运算符时，每对成员必须支持&#x3D;&#x3D;运算符；使用tuple的关系运算符时，每对成员必须支持&lt;运算符。</li><li>由于tuple定义了&lt;和&#x3D;&#x3D;运算符，因此tuple序列可以被传递给算法，无序容器的关键字也可以使用tuple类型。</li></ul><h3 id="17-1-2-使用tuple返回多个值"><a href="#17-1-2-使用tuple返回多个值" class="headerlink" title="17.1.2 使用tuple返回多个值"></a>17.1.2 使用tuple返回多个值</h3><ul><li>tuple的一个常见用途是从一个函数返回多个值。</li></ul><h2 id="17-2-bitset类型"><a href="#17-2-bitset类型" class="headerlink" title="17.2 bitset类型"></a>17.2 bitset类型</h2><h3 id="17-2-1-定义和初始化bitset"><a href="#17-2-1-定义和初始化bitset" class="headerlink" title="17.2.1 定义和初始化bitset"></a>17.2.1 定义和初始化bitset</h3><ul><li>itset类是一个模板，类似array，具有固定的大小。定义一个bitset时需要指明它包含的二进制位数。  <img src="/2020/01/09/c/c-primer/%E8%A1%A817.2.png" class="" title="表17.2.png">)</li><li>使用一个整型值初始化bitset时，此值会被转换为unsigned long long类型并被当作位模式处理。bitset中的二进制位就是此模式的副本。如果bitset的大小大于unsigned long long中的二进制位数，剩余的高位会被置为0。如果bitset的大小小于unsigned long long中的二进制位数，则只使用给定值的低位部分。</li><li>可以使用string或字符数组指针来初始化bitset，字符直接表示位模式。使用字符串表示数时，字符串中下标最小的字符对应bitset的高位。如果string包含的字符数比bitset少，则bitset的高位被置为0。</li></ul><h3 id="17-2-2-bitset操作"><a href="#17-2-2-bitset操作" class="headerlink" title="17.2.2 bitset操作"></a>17.2.2 bitset操作</h3><ul><li>bitset操作：  <img src="/2020/01/09/c/c-primer/%E8%A1%A817.3.png" class="" title="表17.3.png">)</li><li>bitset的下标运算符对const属性进行了重载。const版本的下标运算符在指定位置置位时返回true，否则返回false。非const版本返回bitset定义的一个特殊类型，用来控制指定位置的值。</li><li>to_ulong和to_ullong操作用来提取bitset的值。只有当bitset的大小不大于对应操作的返回值（to_ulong为unsigned long，to_ullong为unsigned long long）时，才能使用这两个操作。如果bitset中的值不能存入给定类型，则会引发overflow_error异常。</li><li>bitset的输入运算符从输入流读取字符，保存到临时的string对象中。遇到下列情况时停止读取：<ul><li>读取的字符数达到对应bitset的大小。</li><li>遇到不是1和0的字符。</li><li>遇到文件结尾。</li><li>输入出现错误。</li></ul></li><li>读取结束后用临时string对象初始化bitset。如果读取的字符数小于bitset的大小，则bitset的高位被置为0。</li></ul><h2 id="17-3-正则表达式"><a href="#17-3-正则表达式" class="headerlink" title="17.3 正则表达式"></a>17.3 正则表达式</h2><ul><li>正则表达式是一种描述字符序列的方法。C++11新标准增加了正则表达式库（RE库），定义在头文件regex中，包含多个组件。  <img src="/2020/01/09/c/c-primer/%E8%A1%A817.4.png" class="" title="表17.4.png">)</li><li>regex类表示一个正则表达式。<pre><code>// find the characters ei that follow a character other than cstring pattern(&quot;[^c]ei&quot;);// we want the whole word in which our pattern appearspattern = &quot;[[:alpha:]]*&quot; + pattern + &quot;[[:alpha:]]*&quot;;regex r(pattern);    // construct a regex to find patternsmatch results;      // define an object to hold the results of a search// define a string that has text that does and doesn&#39;t match patternstring test_str = &quot;receipt freind theif receive&quot;;// use r to find a match to pattern in test_strif (regex_search(test_str, results, r))     // if there is a match    cout &lt;&lt; results.str() &lt;&lt; endl;     // print the matching word</code></pre></li><li>regex_match和regex_search函数确定一个给定的字符序列与一个regex是否匹配。如果整个输入序列与表达式匹配，则regex_match函数返回true；如果输入序列中的一个子串与表达式匹配，则regex_search函数返回true。这两个函数的其中一个重载版本接受一个类型为smatch的附加参数。如果匹配成功，函数会将匹配信息保存在给定的smatch对象中。</li></ul><h3 id="17-3-1-使用正则表达式库"><a href="#17-3-1-使用正则表达式库" class="headerlink" title="17.3.1 使用正则表达式库"></a>17.3.1 使用正则表达式库</h3><ul><li>默认情况下，regex使用的正则表达式语言是ECMAScript。</li><li>定义一个regex或者对一个regex调用assign为其赋新值时，可以指定一些标志来影响regex的操作。ECMAScript、basic、extended、awk、grep和egrep这六个标志指定编写正则表达式时所使用的语言。这六个标志中必须设置其中之一，且只能设置一个。默认情况下，ECMAScript标志被设置，regex会使用ECMA-262规范，这也是很多Web浏览器使用的正则表达式语言。  <img src="/2020/01/09/c/c-primer/%E8%A1%A817.6.png" class="" title="表17.6.png">)</li><li>正则表达式的语法是否正确是在运行期间解析的。如果正则表达式存在错误，标准库会抛出类型为regex_error的异常。除了what操作外，regex_error还有一个名为code的成员，用来返回错误类型对应的数值编码。code返回的值是由具体实现定义的。RE库能抛出的标准错误如下，code返回对应错误的编号（从0开始）。</li><li>RE库为不同的输入序列都定义了对应的类型。使用时RE库类型必须与输入类型匹配。<ul><li>regex类保存char类型的正则表达式；wregex保存wchar_t类型的正则表达式。</li><li>smatch表示string类型的输入序列；cmatch表示字符数组类型的输入序列；wsmatch表示wstring类型的输入序列；wcmatch表示宽字符数组类型的输入序列。</li></ul></li></ul><h3 id="17-3-2-匹配与Regex迭代器类型"><a href="#17-3-2-匹配与Regex迭代器类型" class="headerlink" title="17.3.2 匹配与Regex迭代器类型"></a>17.3.2 匹配与Regex迭代器类型</h3><ul><li>regex迭代器是一种迭代器适配器，它被绑定到一个输入序列和一个regex对象上，每种输入类型都有对应的迭代器类型。</li><li>以sregex_iterator为例，将sregex_iterator绑定到一个string和一个regex对象时，迭代器自动定位至给定string中的第一个匹配位置。即，sregex_iterator构造函数对给定string和regex调用regex_search。解引用迭代器时，返回最近一次搜索结果的smatch对象。递增迭代器时，它调用regex_search在输入string中查找下一个匹配位置。<pre><code>// find the characters ei that follow a character other than cstring pattern(&quot;[^c]ei&quot;);// we want the whole word in which our pattern appearspattern = &quot;[[:alpha:]]*&quot; + pattern + &quot;[[:alpha:]]*&quot;;regex r(pattern, regex::icase);     // we&#39;ll ignore case in doing the match// it will repeatedly call regex_search to find all matches in filefor (sregex_iterator it(file.begin(), file.end(), r), end_it;        it != end_it; ++it)    cout &lt;&lt; it-&gt;str() &lt;&lt; endl;   // matched word</code></pre></li><li>匹配类型有两个名为prefix和suffix的成员，分别返回表示输入序列中当前匹配之前和之后部分的ssub_match对象。一个ssub_match对象有两个名为str和length的成员，分别返回匹配的string和该string的长度。<pre><code>// same for loop header as beforefor (sregex_iterator it(file.begin(), file.end(), r), end_it;    it != end_it; ++it)&#123;    auto pos = it-&gt;prefix().length();    // size of the prefix    pos = pos &gt; 40 ? pos - 40 : 0;       // we want up to 40 characters    cout &lt;&lt; it-&gt;prefix().str().substr(pos)          // last part of the prefix        &lt;&lt; &quot;\n\t\t&gt;&gt;&gt; &quot; &lt;&lt; it-&gt;str() &lt;&lt; &quot; &lt;&lt;&lt;\n&quot;    // matched word        &lt;&lt; it-&gt;suffix().str().substr(0, 40)         // first part of the suffix        &lt;&lt; endl;&#125;</code></pre></li></ul><h3 id="17-3-3-使用子表达式"><a href="#17-3-3-使用子表达式" class="headerlink" title="17.3.3 使用子表达式"></a>17.3.3 使用子表达式</h3><ul><li>正则表达式中的模式通常包含一个或多个子表达式。子表达式是模式的一部分，本身也有意义。正则表达式语法通常用括号表示子表达式。</li><li>匹配对象除了提供匹配整体的相关信息外，还可以用来访问模式中的每个子表达式。子匹配是按位置来访问的，第一个子匹配位置为0，表示整个模式对应的匹配，随后是每个子表达式对应的匹配。</li></ul><h3 id="17-3-4-使用regex-replace"><a href="#17-3-4-使用regex-replace" class="headerlink" title="17.3.4 使用regex_replace"></a>17.3.4 使用regex_replace</h3><ul><li>标准库定义了用于在正则表达式替换过程中控制匹配或格式的标志。这些标志可以传递给regex_search、regex_match函数或者smatch类的format成员。匹配和格式化标志的类型为match_flag_type，定义在命名空间regex_constants中。由于regex_constants定义在std中，因此在使用这些名字时，需要同时加上两个命名空间的限定符。</li><li>默认情况下，regex_replace输出整个输入序列。未与正则表达式匹配的部分会原样输出，匹配的部分按照格式字符串指定的格式输出。使用format_no_copy标志可以只输出匹配部分。</li></ul><h2 id="17-4-随机数"><a href="#17-4-随机数" class="headerlink" title="17.4 随机数"></a>17.4 随机数</h2><ul><li>在新标准出现之前，C和C++都依赖于一个简单的C库函数rand来生成随机数。该函数生成均匀分布的伪随机整数，每个随机数的范围在0和一个系统相关的最大值（至少为32767）之间。</li><li>头文件random中的随机数库定义了一组类来解决rand函数的一些问题：随机数引擎类（random-number engines）可以生成unsigned随机数序列；随机数分布类（random-number distribution classes）使用引擎类生成指定类型、范围和概率分布的随机数。</li><li>C++程序不应该使用rand函数，而应该使用default_random_engine类和恰当的分布类对象。</li></ul><h3 id="17-4-1-随机数引擎和分布"><a href="#17-4-1-随机数引擎和分布" class="headerlink" title="17.4.1 随机数引擎和分布"></a>17.4.1 随机数引擎和分布</h3><ul><li>随机数引擎是函数对象类，定义了一个不接受参数的调用运算符，返回一个随机unsigned整数。调用一个随机数引擎对象可以生成原始随机数。<pre><code>default_random_engine e;    // generates random unsigned integersfor (size_t i = 0; i &lt; 10; ++i)    // e() &quot;calls&quot; the object to produce the next random number    cout &lt;&lt; e() &lt;&lt; &quot; &quot;;</code></pre></li><li>标准库定义了多个随机数引擎类，区别在于性能和随机性质量。每个编译器都会指定其中一个作为default_random_engine类型，此类型一般具有最常用的特性。</li><li>大多数情况下，随机数引擎的输出是不能直接使用的，因为生成的随机数范围通常与程序所需要的不符。</li><li>使用分布类对象可以得到指定范围的随机数。新标准库的uniform_int_distribution<unsigned>类型生成均匀分布的unsigned值。<pre><code>// uniformly distributed from 0 to 9 inclusiveuniform_int_distribution&lt;unsigned&gt; u(0,9);default_random_engine e;    // generates unsigned random integersfor (size_t i = 0; i &lt; 10; ++i)    // u uses e as a source of numbers    // each call returns a uniformly distributed value in the specified range    cout &lt;&lt; u(e) &lt;&lt; &quot; &quot;;</code></pre></li><li>类似引擎类型，分布类型也是函数对象类。分布类型定义了一个接受一个随机数引擎参数的调用运算符。分布对象使用它的引擎参数生成随机数，并将其映射到指定的分布区间。</li><li>随机数发生器指分布对象和引擎对象的组合</li><li>rand函数的生成范围在0到RAND_MAX之间，随机数引擎生成的unsigned整数在一个系统定义的范围内。一个引擎类型的范围可以通过调用该类型对象的min和max成员来获得。</li><li>即使随机数发生器生成的数看起来是随机的，但对于一个给定的发生器，每次运行程序时它都会返回相同的数值序列。</li><li>如果函数需要局部的随机数发生器，应该将其（包括引擎和分布对象）定义为static对象，这样随机数发生器就能在函数调用期间保持状态。否则每次调用函数都会生成相同的序列。<pre><code>// returns a vector of 100 uniformly distributed random numbersvector&lt;unsigned&gt; good_randVec()&#123;    // because engines and distributions retain state, they usually should be    // defined as static so that new numbers are generated on each call    static default_random_engine e;    static uniform_int_distribution&lt;unsigned&gt; u(0,9);    vector&lt;unsigned&gt; ret;    for (size_t i = 0; i &lt; 100; ++i)        ret.push_back(u(e));    return ret;&#125;</code></pre></li><li>通过为引擎提供一个种子（seed），可以让引擎在程序每次运行时生成不同的序列。种子是一个数值，引擎利用它从序列中的一个新位置重新开始生成随机数。</li><li>为引擎设置种子有两种方式：<ul><li>在创建对象时提供种子。</li><li>调用引擎的seed成员设置种子。</li></ul><pre><code>default_random_engine e1;    // uses the default seeddefault_random_engine e2(2147483646);   // use the given seed valuedefault_random_engine e3;    // uses the default seed valuee3.seed(32767);     // call seed to set a new seed value</code></pre></li><li>选择种子的常用方法是调用系统函数time。该函数定义在头文件ctime中，返回从一个特定时刻到当前经过的秒数。time函数接受单个指针参数，指向用于写入时间的数据结构。如果指针为空，则函数简单地返回时间。<pre><code>default_random_engine e1(time(0));   // a somewhat random seed</code></pre></li><li>由于time函数返回以秒计算的时间，因此用time返回值作为种子的方式只适用于生成种子的间隔为秒级或更长时间的应用。另外如果程序作为一个自动过程的一部分反复运行，这种方式也会无效，可能多次使用的是相同的种子。</li></ul><h3 id="17-4-2-其他随机数分布"><a href="#17-4-2-其他随机数分布" class="headerlink" title="17.4.2 其他随机数分布"></a>17.4.2 其他随机数分布</h3><ul><li>从rand函数获得随机浮点数的一个常用但不正确的方法是用rand的结果除以RAND_MAX。但因为随机整数的精度通常低于随机浮点数，所以使用这种方法时，有一些浮点值永远不会被生成。</li><li>使用新标准库的uniform_real_distribution类型可以获得随机浮点数。<pre><code>default_random_engine e;    // generates unsigned random integers// uniformly distributed from 0 to 1 inclusiveuniform_real_distribution&lt;double&gt; u(0,1);for (size_t i = 0; i &lt; 10; ++i)    cout &lt;&lt; u(e) &lt;&lt; &quot; &quot;;</code></pre></li><li>除了总是生成bool类型的bernouilli_distribution外，其他分布类型都是模板。每个模板都接受单个类型参数，指定分布生成的结果类型。</li><li>分布类型限制了可以作为模板类型的参数类型，一些模板只能生成浮点数，而其他模板只能生成整数。分布类型还定义了一个默认模板类型参数，整型分布的默认参数是int，浮点数分布的默认参数是double。使用默认类型时应该在模板名后使用空尖括号。<pre><code>// empty &lt;&gt; signify we want to use the default result typeuniform_real_distribution&lt;&gt; u(0,1);    // generates double by default</code></pre></li><li>bernouilli_distribution类型是一个普通类，而非模板。该分布返回一个bool值，其中true的概率是一个常数，默认为0.5。</li><li>由于引擎会返回相同的随机数序列，因此需要在循环中使用引擎时，必须在循环体外定义引擎对象。否则每次循环都会创建新引擎，生成相同序列。同样，分布对象也需要保持运行状态，也必须在循环体外定义。</li></ul><h2 id="17-5-io库再探"><a href="#17-5-io库再探" class="headerlink" title="17.5 io库再探"></a>17.5 io库再探</h2><h3 id="17-5-1-格式化输入与输出"><a href="#17-5-1-格式化输入与输出" class="headerlink" title="17.5.1 格式化输入与输出"></a>17.5.1 格式化输入与输出</h3><ul><li>除了条件状态外，每个iostream对象还维护着一个格式状态来控制IO格式化细节。</li><li>标准库定义了一组操纵符（manipulator）来修改流的格式状态。操纵符是一个函数或对象，会影响流的状态，并能作为输入和输出运算符的运算对象。类似输入和输出运算符，操纵符也返回它所处理的流对象。</li><li>操纵符用于两大类输出控制：控制数值的输出格式，控制补白的数量和位置。</li><li>操纵符改变流的格式状态时，通常改变后的状态对所有后续IO都生效。大多数改变格式状态的操纵符都是设置&#x2F;复原成对的，一个操纵符用于设置新格式，另一个用于恢复正常格式。</li><li>默认情况下，bool值输出为1（true）或0（false）。对流使用boolalpha操纵符可以输出true或false，还原格式时使用noboolalpha操纵符。<pre><code>cout &lt;&lt; &quot;default bool values: &quot; &lt;&lt; true &lt;&lt; &quot; &quot; &lt;&lt; false&lt;&lt; &quot;\nalpha bool values: &quot; &lt;&lt; boolalpha&lt;&lt; true &lt;&lt; &quot; &quot; &lt;&lt; false &lt;&lt; endl;default bool values: 1 0alpha bool values: true false</code></pre></li><li>默认情况下，整型值的输入输出使用十进制。可以使用hex、oct和dec操纵符将其改为十六进制、八进制或改回十进制。<pre><code>cout &lt;&lt; &quot;default: &quot; &lt;&lt; 20 &lt;&lt; &quot; &quot; &lt;&lt; 1024 &lt;&lt; endl;cout &lt;&lt; &quot;octal: &quot; &lt;&lt; oct &lt;&lt; 20 &lt;&lt; &quot; &quot; &lt;&lt; 1024 &lt;&lt; endl;cout &lt;&lt; &quot;hex: &quot; &lt;&lt; hex &lt;&lt; 20 &lt;&lt; &quot; &quot; &lt;&lt; 1024 &lt;&lt; endl;cout &lt;&lt; &quot;decimal: &quot; &lt;&lt; dec &lt;&lt; 20 &lt;&lt; &quot; &quot; &lt;&lt; 1024 &lt;&lt; endl;default: 20 1024octal: 24 2000hex: 14 400decimal: 20 1024</code></pre></li><li>hex、oct和dec操纵符只影响整型运算对象，浮点值的表示形式不受影响。</li><li>默认情况下，在输出数值时，没有可见的标识指出当前使用的进制模式。如果需要输出八进制或十六进制值，应该使用showbase操纵符。对流应用showbase后，在输出结果中会显示进制，显示模式和指定整型常量进制的规范相同。<ul><li>前导0x表示十六进制。</li><li>前导0表示八进制。</li><li>无前导字符表示十进制。</li></ul></li><li>还原格式时使用noshowbase操纵符。<pre><code>cout &lt;&lt; showbase;    // show the base when printing integral valuescout &lt;&lt; &quot;default: &quot; &lt;&lt; 20 &lt;&lt; &quot; &quot; &lt;&lt; 1024 &lt;&lt; endl;cout &lt;&lt; &quot;in octal: &quot; &lt;&lt; oct &lt;&lt; 20 &lt;&lt; &quot; &quot; &lt;&lt; 1024 &lt;&lt; endl;cout &lt;&lt; &quot;in hex: &quot; &lt;&lt; hex &lt;&lt; 20 &lt;&lt; &quot; &quot; &lt;&lt; 1024 &lt;&lt; endl;cout &lt;&lt; &quot;in decimal: &quot; &lt;&lt; dec &lt;&lt; 20 &lt;&lt; &quot; &quot; &lt;&lt; 1024 &lt;&lt; endl;cout &lt;&lt; noshowbase;   // reset the state of the streamdefault: 20 1024in octal: 024 02000in hex: 0x14 0x400in decimal: 20 1024</code></pre></li><li>默认情况下，十六进制值（包括前导字符）以小写格式输出。使用uppercase操纵符可以输出大写字母。还原格式时使用nouppercase操纵符。<pre><code>cout &lt;&lt; uppercase &lt;&lt; showbase &lt;&lt; hex&lt;&lt; &quot;printed in hexadecimal: &quot; &lt;&lt; 20 &lt;&lt; &quot; &quot; &lt;&lt; 1024&lt;&lt; nouppercase &lt;&lt; noshowbase &lt;&lt; dec &lt;&lt; endl;printed in hexadecimal: 0X14 0X400</code></pre></li><li>浮点数的输出格式涉及三个方面：<ul><li>输出精度（即输出多少个数字）。</li><li>十六进制、定点十进制或者科学记数法形式输出。</li><li>没有小数部分的浮点值是否输出小数点。</li></ul></li><li>默认情况下，浮点值按六位数字精度输出；如果浮点值没有小数部分，则不输出小数点；根据浮点数的值选择输出为定点十进制或科学计数法形式：非常大或非常小的值输出为科学记数法形式，其他值输出为定点十进制形式。</li><li>默认情况下，精度控制输出的数字总位数。输出时，浮点值按照当前精度四舍五入而非截断。</li><li>调用IO对象的precision成员或者使用setprecision操纵符可以改变精度。<ul><li>precision成员是重载的。一个版本接受一个int值，将精度设置为此值，并返回旧精度值。另一个版本不接受参数，直接返回当前精度值。</li><li>setprecision操纵符接受一个参数来设置精度。</li></ul></li><li>setprecision操纵符和其他接受参数的操纵符都定义在头文件iomanip中。<pre><code>// cout.precision reports the current precision valuecout &lt;&lt; &quot;Precision: &quot; &lt;&lt; cout.precision()    &lt;&lt; &quot;, Value: &quot; &lt;&lt; sqrt(2.0) &lt;&lt; endl;// cout.precision(12) asks that 12 digits of precision be printedcout.precision(12);cout &lt;&lt; &quot;Precision: &quot; &lt;&lt; cout.precision()    &lt;&lt; &quot;, Value: &quot; &lt;&lt; sqrt(2.0) &lt;&lt; endl;// alternative way to set precision using the setprecision manipulatorcout &lt;&lt; setprecision(3);cout &lt;&lt; &quot;Precision: &quot; &lt;&lt; cout.precision()    &lt;&lt; &quot;, Value: &quot; &lt;&lt; sqrt(2.0) &lt;&lt; endl;Precision: 6, Value: 1.41421Precision: 12, Value: 1.41421356237Precision: 3, Value: 1.41</code></pre></li><li>操纵符可以强制流使用科学记数法、定点十进制或十六进制形式输出浮点值。<ul><li>scientific使用科学记数法表示浮点值。</li><li>fixed使用定点十进制表示浮点值。</li><li>hexfloat（新标准库）使用十六进制表示浮点值。</li><li>defaultfloat（新标准库）将流恢复到默认状态。</li></ul></li><li>除非程序需要控制浮点数的表示方式，否则最好由标准库来选择计数法。<pre><code>cout &lt;&lt; &quot;default format: &quot; &lt;&lt; 100 * sqrt(2.0) &lt;&lt; &#39;\n&#39;    &lt;&lt; &quot;scientific: &quot; &lt;&lt; scientific &lt;&lt; 100 * sqrt(2.0) &lt;&lt; &#39;\n&#39;    &lt;&lt; &quot;fixed decimal: &quot; &lt;&lt; fixed &lt;&lt; 100 * sqrt(2.0) &lt;&lt; &#39;\n&#39;    &lt;&lt; &quot;hexadecimal: &quot; &lt;&lt; hexfloat &lt;&lt; 100 * sqrt(2.0) &lt;&lt; &#39;\n&#39;    &lt;&lt; &quot;use defaults: &quot; &lt;&lt; defaultfloat &lt;&lt; 100 * sqrt(2.0) &lt;&lt; &#39;\n&#39;;default format: 141.421scientific: 1.414214e+002fixed decimal: 141.421356hexadecimal: 0x1.1ad7bcp+7use defaults: 141.421</code></pre></li><li>scientific、fixed和hexfloat操纵符会改变流的精度含义。执行这些操纵符后，精度控制的将是小数点后面的数字位数，而默认情况下控制的是数字总位数。</li><li>默认情况下，当浮点值的小数部分为0时，不显示小数点。使用showpoint操纵符可以强制输出小数点，noshowpoint操纵符还原默认行为。<pre><code>cout &lt;&lt; 10.0 &lt;&lt; endl;        // prints 10cout &lt;&lt; showpoint &lt;&lt; 10.0    // prints 10.0000    &lt;&lt; noshowpoint &lt;&lt; endl;  // revert to default format for the decimal point</code></pre></li><li>按列输出时，通常需要非常精细地控制数据格式。<ul><li>setw指定下一个数字或字符串值的最小空间。</li><li>left表示左对齐输出。</li><li>right表示右对齐输出（默认格式）。</li><li>internal控制负数的符号位置，它左对齐符号，右对齐值，中间空间用空格填充。</li><li>setfill指定一个字符代替默认的空格进行补白。</li></ul></li><li>setw类似endl，不改变输出流的内部状态，只影响下一次输出的大小。</li><li>默认情况下，输入运算符会忽略空白字符（空格符、制表符、换行符、换纸符和回车符）。使用noskipws操纵符可以让输入运算符读取空白符，skipws操纵符还原默认行为。<pre><code>cin &gt;&gt; noskipws;    // set cin so that it reads whitespacewhile (cin &gt;&gt; ch)    cout &lt;&lt; ch;cin &gt;&gt; skipws;      // reset cin to the default state so that it discards whitespace</code></pre></li></ul><h3 id="17-5-2-未格式化的输入-x2F-输出操作（Unformatted-Input-x2F-Output-Operations）"><a href="#17-5-2-未格式化的输入-x2F-输出操作（Unformatted-Input-x2F-Output-Operations）" class="headerlink" title="17.5.2 未格式化的输入&#x2F;输出操作（Unformatted Input&#x2F;Output Operations）"></a>17.5.2 未格式化的输入&#x2F;输出操作（Unformatted Input&#x2F;Output Operations）</h3><ul><li>标准库提供了一组低层操作，支持未格式化IO（unformatted IO）。这些操作可以将一个流当作无解释的字节序列来处理。</li><li>一些未格式化操作每次处理流的一个字节，它们会读取而不是忽略空白符。</li><li>使用未格式化IO操作get和put可以读取和写入一个字符。<pre><code>char ch;while (cin.get(ch))    cout.put(ch);</code></pre></li><li>有时读取完一个字符后才发现目前无法处理该字符，希望将其放回流中。标准库提供了三种方法退回字符。<ul><li>peek返回输入流中下一个字符的副本，但不会将其从流中删除。</li><li>unget使输入流向后移动，令最后读取的值回到流中。即使不知道最后从流中读取了什么值，也可以调用unget。</li><li>putback是特殊版本的unget，它退回从流中读取的最后一个值，但它接受一个参数，该参数必须与最后读取的值相同。</li></ul></li><li>一般情况下，在读取下一个值之前，标准库保证程序可以退回最多一个值。</li><li>peek和无参数的get函数都以int类型从输入流返回字符。这些函数使用int的原因是可以返回文件尾标记。char范围中的每个值都表示一个真实字符，因此没有额外的值可以表示文件尾。返回int的函数先将要返回的字符转换为unsigned char，再将结果提升为int。因此即使字符集中有字符映射到负值，返回的int也是正值。而标准库使用负值表示文件尾，这样就能保证文件尾与任何合法字符的值都不相同。头文件cstdio定义了一个名为EOF的常量值，可以用它检测函数返回的值是否是文件尾。<pre><code>int ch;    // use an int, not a char to hold the return from get()// loop to read and write all the data in the inputwhile ((ch = cin.get()) != EOF)    cout.put(ch);</code></pre></li><li>一个常见的编程错误是将get或peek函数的返回值赋给char而非int对象，但编译器不能发现这个错误。<pre><code>char ch;   // using a char here invites disaster!// the return from cin.get is converted to char and then compared to an intwhile ((ch = cin.get()) != EOF)    cout.put(ch);</code></pre></li><li>当get返回EOF时，该值会先被转换为unsigned char，之后提升得到的int值与EOF值不再相等，因此循环永远不会停止。</li><li>一些未格式化IO操作一次处理大块数据，这些操作可以提高程序执行速度，但需要自己分配并管理用来保存和提取数据的字符数组。</li><li>get和getline函数接受相同的参数，它们的行为类似但不相同。两个函数都一直读取数据，直到遇到下列情况之一：<ul><li>已经读取了size - 1个字符。</li><li>遇到了文件尾（EOF）。</li><li>遇到了分隔符。</li></ul></li><li>两个函数的区别在于处理分隔符的方式：get将分隔符留在输入流中作为下一个字符，而getline读取并丢弃分隔符。两个函数都不会将分隔符保存在结果数组中。</li><li>读取流数据时的一个常见错误是忘记从流中删除分隔符。</li><li>一些操作可能从输入流中读取了未知个数的字节，使用gcount函数可以确定上一次未格式化输入操作读取了多少字符。gcount函数应该在任何后续未格式化输入操作前调用，将字符退回流的操作也属于未格式化输入操作。如果在调用gcount前使用了peek、unget或putback操作，则gcount的返回值为0。</li><li>使用clear、ignore和sync函数可以清空输入流中的数据。读到非法字符时，输入流将处于错误状态。为了继续获取输入数据，先调用clear函数重置流的错误标记。再调用ignore清空流中指定大小的数据，或者调用sync直接清空流中所有数据。numeric_limits<streamsize>::max()返回流的缓冲区大小。<pre><code>// 重置错误标志cin.clear();// 清除流中所有数据cin.clear();cin.ignore(numeric_limits&lt;streamsize&gt;::max());// 清除流中一行数据cin.ignore(numeric_limits&lt;streamsize&gt;::max(), &#39;\n&#39;);</code></pre></li></ul><h3 id="17-5-3-流随机访问（Random-Access-to-a-Stream）"><a href="#17-5-3-流随机访问（Random-Access-to-a-Stream）" class="headerlink" title="17.5.3 流随机访问（Random Access to a Stream）"></a>17.5.3 流随机访问（Random Access to a Stream）</h3><ul><li>随机IO本质上是依赖于操作系统的。</li><li>为了支持随机访问，IO类型通过维护一个标记来确定下一次读写操作的位置。seek函数用于移动标记，tell函数用于获取标记。标准库实际上定义了两对seek和tell函数，一对用于输入流（后缀为g，表示get），一对用于输出流（后缀为p，表示put）。</li><li>虽然标准库为所有流类型都定义了seek和tell函数，但它们是否有意义取决于流绑定到哪个设备。在大多数系统中，绑定到cin、cout、cerr和clog的流不支持随机访问。对这些流可以调用seek和tell函数，但在运行时会出现错误，流也会被置为无效状态。</li><li>从逻辑上考虑，seek和tell函数的使用范围如下：<ul><li>可以对istream、ifstream、istringstream类型使用g版本。</li><li>可以对istream、ifstream、istringstream类型使用g版本。</li><li>可以对iostream、fstream、stringstream类型使用g和p版本。</li></ul></li><li>一个流中只有一个标记——不存在独立的读标记和写标记。fstream和stringstream类型可以读写同一个流。在这些类型中，有单一的缓冲区用于保存读写的数据，同时标记也只有一个，表示缓冲区中的当前位置。标准库将两个版本的seek和tell函数都映射到这个标记。</li><li>由于流中只有一个标记，因此在切换读写操作时，必须使用seek函数来重定位标记。</li><li>seek函数有两个重载版本：一个版本使用绝对地址移动流标记；另一个版本使用指定位置和偏移量移动流标记。<pre><code>// set the marker to a fixed positionseekg(new_position);    // set the read marker to the given pos_type locationseekp(new_position);    // set the write marker to the given pos_type location// offset some distance ahead of or behind the given starting pointseekg(offset, from);    // set the read marker offset distance from fromseekp(offset, from);    // offset has type off_type</code></pre></li><li>参数new_position和offset的类型分别是pos_type和off_type，这两个类型都是机器相关的，定义在头文件istream和ostream中。pos_type表示文件位置，而off_type表示距离当前位置的偏移量，偏移量可以是正数也可以是负数。</li><li>tellg和tellp函数返回一个pos_type值，表示流的当前位置。</li></ul><h1 id="第18章-用于大型工程的工具"><a href="#第18章-用于大型工程的工具" class="headerlink" title="第18章 用于大型工程的工具"></a>第18章 用于大型工程的工具</h1><h2 id="18-1-异常处理"><a href="#18-1-异常处理" class="headerlink" title="18.1 异常处理"></a>18.1 异常处理</h2><ul><li>异常处理机制允许程序中独立开发的部分能够在运行期间就出现的问题进行通信并做出相应的处理，使问题检测和解决过程相互分离。</li></ul><h3 id="18-1-1-抛出异常"><a href="#18-1-1-抛出异常" class="headerlink" title="18.1.1 抛出异常"></a>18.1.1 抛出异常</h3><ul><li>在C++中，通过抛出（throwing）一条表达式来引发（raised）一个异常。被抛出的表达式类型和当前的调用链共同决定了应该使用哪段处理代码（handler）来处理该异常。被选中的处理代码是在调用链中与抛出对象类型匹配且距离最近的代码。</li><li>执行一个throw语句时，跟在throw后面的语句将不再执行。程序的控制权从throw转移到与之匹配的catch语句中。该catch可能是同一个函数中的局部catch，也可能位于直接或间接调用了发生异常的函数的另一个函数中。控制权的转移意味着两个问题：<ul><li>沿着调用链的函数可能会提前退出。</li><li>一旦程序开始执行异常处理代码，则沿着调用链创建的对象会被销毁。</li></ul></li><li>抛出异常后，程序暂停执行当前函数并立即寻找对应catch语句的过程叫做栈展开（stack unwinding）。栈展开沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的catch语句为止。如果没有对应的catch语句，则退出主函数后查找过程结束。<ul><li>如果找到了匹配的catch语句，则程序进入该子句并执行其中的代码。catch语句执行结束后，程序会转移到与try块关联的最后一个catch语句之后的位置继续执行。</li><li>如果没有找到匹配的catch语句，程序会调用标准库的terminate函数，终止运行。</li></ul></li><li>在栈展开过程中，位于调用链上的语句块可能会提前退出，其中的局部对象也会被销毁。如果异常发生在构造函数或者数组及容器的元素初始化过程中，则当前的对象可能只构造了一部分，此时必须确保已构造的成员能被正确销毁。</li><li>如果一个块分配了资源，并且在执行资源释放代码前发生了异常，则资源不会被释放。</li><li>由于栈展开可能会调用析构函数，因此析构函数不应该抛出不能被它自身处理的异常。即，如果析构函数需要执行某个可能引发异常的操作，则该操作应该被放置在一个try语句块中，并在析构函数内部得到处理。实际编程中，析构函数仅仅是释放资源，不太可能引发异常。所有的标准库类型都能确保它们的析构函数不会引发异常。</li><li>编译器使用异常抛出表达式对异常对象（exception object）进行拷贝初始化，因此throw语句中的表达式必须具有完全类型。如果该表达式是类类型，则相应的类必须含有可访问的析构函数和拷贝&#x2F;移动构造函数。如果该表达式是数组或函数类型，则表达式会被转换成对应的指针类型。</li><li>抛出一条表达式时，该表达式的静态编译类型决定了异常对象的类型。如果throw表达式解引用一个基类指针，而该指针实际指向派生类对象，则只有基类部分会被抛出。</li><li>抛出指针时必须确保在任何对应的处理代码中，指针指向的对象一定存在。</li></ul><h3 id="18-1-2-捕获异常"><a href="#18-1-2-捕获异常" class="headerlink" title="18.1.2 捕获异常"></a>18.1.2 捕获异常</h3><ul><li>catch语句（catch clause）中的异常声明（exception declaration）类似只包含一个形参的函数形参列表。声明的类型决定了处理代码所能捕获的异常类型。该类型必须是完全类型，可以是左值引用，但不能是右值引用。如果catch无须访问抛出的表达式，则可以忽略捕获形参的名字。</li><li>进入catch语句后，使用异常对象初始化异常声明中的参数。catch参数的特性和函数参数类似。<ul><li>如果catch的参数类型是非引用类型，则该参数是异常对象的一个副本，改变参数不会影响异常对象本身。</li><li>如果catch的参数类型是引用类型，则该参数是异常对象的一个别名，改变参数就是改变异常对象本身。</li><li>在继承体系中，如果catch的参数类型是基类类型，则可以使用其派生类类型的异常对象对其初始化。<ul><li>catch的参数是基类非引用类型时，异常对象会被切除一部分。</li><li>catch的参数是基类引用类型时，以常规方式绑定到异常对象。</li></ul></li></ul></li><li>异常声明的静态类型决定了catch语句所能执行的操作。如果catch的参数是基类类型，则无法使用派生类特有的成员。</li><li>通常情况下，如果catch接受的异常与某个继承体系有关，则最好将catch参数定义为引用类型。</li><li>查找异常处理代码时，最终结果是第一个与异常匹配的catch语句，但这未必是最佳匹配。因此，越特殊的catch越应该位于整个catch列表的前端。当程序使用具有继承关系的异常时，派生类异常的处理代码应该位于基类异常的处理代码之前。</li><li>异常和异常声明的匹配规则比函数参数严格，绝大多数类型转换都不能使用。<ul><li>允许从非常量到常量的类型转换。</li><li>允许从派生类到基类的类型转换。</li><li>数组被转换成指向数组元素类型的指针，函数被转换成指向该函数类型的指针。</li></ul></li><li>除此之外，包括标准算术类型转换和类类型转换在内的其他所有转换规则都不能在catch匹配过程中使用。</li><li>有时一个单独的catch语句不能完整处理某个异常。执行完一些校正操作后，当前的catch可能会让位于调用链上层的函数继续处理异常。一个catch语句通过重新抛出（rethrowing）的操作将异常传递给另一个catch语句。重新抛出是一条不包含表达式的throw语句。</li><li>有时一个单独的catch语句不能完整处理某个异常。执行完一些校正操作后，当前的catch可能会让位于调用链上层的函数继续处理异常。一个catch语句通过重新抛出（rethrowing）的操作将异常传递给另一个catch语句。重新抛出是一条不包含表达式的throw语句。</li><li>有时一个单独的catch语句不能完整处理某个异常。执行完一些校正操作后，当前的catch可能会让位于调用链上层的函数继续处理异常。一个catch语句通过重新抛出（rethrowing）的操作将异常传递给另一个catch语句。重新抛出是一条不包含表达式的throw语句。</li><li>catch(…)通常与重新抛出语句一起使用。</li><li>如果catch(…)与其他catch语句一起使用，则catch(…)必须位于最后，否则catch(…)后面的catch语句永远不会被匹配。</li></ul><h3 id="18-1-3-函数try语句块与构造函数"><a href="#18-1-3-函数try语句块与构造函数" class="headerlink" title="18.1.3 函数try语句块与构造函数"></a>18.1.3 函数try语句块与构造函数</h3><ul><li>要想处理构造函数初始值列表抛出的异常，必须将构造函数写成函数try语句块（function try block）的形式。函数try语句块使得一组catch语句可以同时处理构造函数体和构造函数初始化过程中的异常。<pre><code>template &lt;typename T&gt;Blob&lt;T&gt;::Blob(std::initializer_list&lt;T&gt; il) try :    data(std::make_shared&lt;std::vector&lt;T&gt;&gt;(il))&#123;    /* empty body */&#125;catch(const std::bad_alloc &amp;e)&#123;    handle_out_of_memory(e);&#125;</code></pre></li><li>函数try语句块的catch语句会在结尾处隐式地重新抛出异常，通知上层函数对象构造失败。上层函数需要继续处理该异常。在初始化构造函数参数时发生的异常不属于函数try语句块处理的范围。</li></ul><h3 id="18-1-4-noexcept异常说明"><a href="#18-1-4-noexcept异常说明" class="headerlink" title="18.1.4 noexcept异常说明"></a>18.1.4 noexcept异常说明</h3><ul><li>在C++11中，可以通过提供noexcept说明（noexcept specification）来指出某个函数不会抛出异常。<pre><code>void recoup(int) noexcept;  // won&#39;t throwvoid alloc(int);            // might throw</code></pre></li><li>noexcept说明的出现位置：<ul><li>关键字noexcept位于函数的参数列表之后，尾置返回类型之前。</li><li>对于一个函数来说，noexcept说明必须同时出现在该函数的所有声明和定义语句中。</li><li>函数指针的声明和定义也可以指定noexcept。</li><li>在typedef或类型别名中不能使用noexcept。</li><li>在成员函数中，关键字noexcept位于const或引用限定符之后，final、override或虚函数的&#x3D;0之前。</li></ul></li><li>编译器并不会在编译时检查noexcept说明。如果一个函数在指定了noexcept的同时又含有throw语句或其他可能抛出异常的操作，仍然会通过编译（个别编译器可能会提出警告）。</li><li>一旦noexcept函数抛出异常，程序会调用terminate函数终止运行（该过程是否执行栈展开未作规定）。因此noexcept可以用于两种情况：<ul><li>确认函数不会抛出异常。</li><li>不知道该如何处理函数抛出的异常。</li></ul></li><li>指明某个函数不会抛出异常可以让调用者不必再考虑异常处理操作。</li><li>早期的C++版本设计了一套更详细的异常说明方案。函数可以使用一个关键字throw，后面跟上用括号包围的异常类型列表，用于指定函数可能抛出的异常类型。关键字throw出现的位置与C++11的noexcept相同。该方案在C++11中被取消。但如果一个函数被声明为throw()的，则也说明该函数不会抛出异常。</li><li>noexcept说明符接受一个可选的实参，该实参必须能转换为bool类型。如果实参为true，则函数不会抛出异常；如果实参为false，则函数可能抛出异常。<pre><code>void recoup(int) noexcept(true);    // recoup won&#39;t throwvoid alloc(int) noexcept(false);    // alloc can throw</code></pre></li><li>noexcept运算符（noexcept operator）是一个一元运算符，返回bool类型的右值常量表达式，表示给定的运算对象是否会抛出异常。和sizeof类似，noexcept运算符也不会对运算对象求值。</li><li>当e调用的函数都含有noexcept说明且e本身不含有throw语句时，上述表达式返回true，否则返回false。noexcept运算符通常在noexcept说明符的实参中使用。<br>  <code>void f() noexcept(noexcept(g()));   // f has same exception specifier as g</code></li><li>函数指针与该指针指向的函数必须具有一致的异常说明。如果某个函数指针是noexcept的，则该指针只能指向noexcept函数；如果显式或隐式地说明了函数指针可能抛出异常，则该指针可以指向任何函数。<pre><code>// both recoup and pf1 promise not to throwvoid (*pf1)(int) noexcept = recoup;// ok: recoup won&#39;t throw; it doesn&#39;t matter that pf2 mightvoid (*pf2)(int) = recoup;pf1 = alloc;    // error: alloc might throw but pf1 said it wouldn&#39;tpf2 = alloc;    // ok: both pf2 and alloc might throw</code></pre></li><li>如果一个虚函数是noexcept的，则后续派生出来的虚函数必须也是noexcept的。如果基类的虚函数允许抛出异常，则派生类的对应函数既可以允许，也可以禁止抛出异常。<pre><code>class Base&#123;public:    virtual double f1(double) noexcept;   // doesn&#39;t throw    virtual int f2() noexcept(false);   // can throw    virtual void f3();   // can throw&#125;;class Derived : public Base&#123;public:    double f1(double);   // error: Base::f1 promises not to throw    int f2() noexcept(false);   // ok: same specification as Base::f2    void f3() noexcept;   // ok: Derived f3 is more restrictive&#125;;</code></pre></li><li>编译器合成拷贝控制成员时，也会生成一个异常声明。如果所有的成员和基类操作都含有noexcept说明，则合成成员也是noexcept的。</li></ul><h3 id="18-1-5-异常类层次"><a href="#18-1-5-异常类层次" class="headerlink" title="18.1.5 异常类层次"></a>18.1.5 异常类层次</h3><ul><li>标准库异常类的继承体系： <img src="/2020/01/09/c/c-primer/%E8%A1%A818.1.png" class="" title="表18.1.png">)</li><li>exception类型只定义了拷贝构造函数、拷贝赋值运算符、一个虚析构函数和一个名为what的虚成员。what函数返回一个const char*，指向一个以NULL结尾的字符数组，并且不会抛出异常。</li><li>exception、bad_cast和bad_alloc类型定义了默认构造函数。runtime_error和logic_error类型没有默认构造函数，但是有一个接受C风格字符串或string类型实参的构造函数，该实参通常用于提供错误信息。what函数返回用于初始化异常对象的错误信息。</li><li>实际编程中通常会自定义exception（或者exception的标准库派生类）的派生类以扩展其继承体系。这些面向具体应用的异常类表示了与应用相关的异常状态。</li></ul><h2 id="18-2-命名空间"><a href="#18-2-命名空间" class="headerlink" title="18.2 命名空间"></a>18.2 命名空间</h2><ul><li>大型应用程序通常会使用多个独立开发的库，其中某些名字可能会相互冲突。多个库将名字放置在全局命名空间中会产生命名空间污染（namespace pollution）。</li><li>命名空间分割了全局命名空间，其中每个命名空间都是一个作用域。</li></ul><h3 id="18-2-1-命名空间定义"><a href="#18-2-1-命名空间定义" class="headerlink" title="18.2.1 命名空间定义"></a>18.2.1 命名空间定义</h3><ul><li>命名空间的定义包含两部分：关键字namespace和随后的命名空间名字。在命名空间名字后面是一系列由花括号包围的声明和定义。能出现在全局作用域中的声明就也能出现在命名空间中。<pre><code>namespace cplusplus_primer&#123;    class Sales_data &#123; / * ... * /&#125;;    Sales_data operator+(const Sales_data&amp;, const Sales_data&amp;);    class Query &#123; /* ... */ &#125;;    class Query_base &#123; /* ... */&#125;;&#125;   // like blocks, namespaces do not end with a semicolon</code></pre></li><li>命名空间作用域后面不需要分号结束。</li><li>和其他名字一样，命名空间的名字也必须在定义它的作用域内保持唯一。命名空间可以定义在全局作用域内，也可以定义在其他命名空间中，但是不能定义在函数或类的内部。</li><li>每个命名空间都是一个作用域，不同命名空间内可以有相同名字的成员。</li><li>定义在某个命名空间中的名字可以被该命名空间内的其他成员直接访问，也可以被这些成员内嵌作用域中的任何单位访问。位于该命名空间之外的代码则必须明确指出所使用的名字属于哪个命名空间。<br>  <code>cplusplus_primer::Query q = cplusplus_primer::Query(&quot;hello&quot;);</code></li><li>命名空间的定义可以是不连续的。</li><li>如果之前没有名为nsp的命名空间定义，则上述代码创建一个新的命名空间；否则，上述代码打开已经存在的命名空间定义并为其添加新的成员声明。</li><li>利用命名空间不连续的特性可以将几个独立的接口和实现文件组成一个命名空间。此时，命名空间的组织方式类似管理自定义类和函数的方式。<ul><li>命名空间的一部分成员用于定义类，以及声明作为类接口的函数和对象。这些成员应该放置在头文件中。</li><li>命名空间成员的定义部分放置在另外的源文件中。源文件需要包含对应的头文件。</li></ul></li><li>程序中的某些实体只能定义一次，如非内联函数、静态数据成员等，命名空间中定义的名字也需要满足该要求。<pre><code>// ---- Sales_data.h----// #includes should appear before opening the namespace# include &lt;string&gt;namespace cplusplus_primer&#123;    class Sales_data &#123; /* ... */&#125;;    Sales_data operator+(const Sales_data&amp;, const Sales_data&amp;);    // declarations for the remaining functions in the Sales_data interface&#125;// ---- Sales_data.cc----// be sure any #includes appear before opening the namespace# include &quot;Sales_data.h&quot;namespace cplusplus_primer&#123;    // definitions for Sales_data members and overloaded operators&#125;</code></pre></li><li>通常情况下，#include不应该出现在命名空间内部。否则头文件中的所有名字都会被定义为该命名空间的成员。</li><li>定义多个类型不相关的命名空间时应该使用单独的文件分别表示每个类型。</li><li>可以在命名空间的外部定义该命名空间的成员。命名空间对于名字的声明必须在作用域内，同时该名字的定义需要明确指出其所属的命名空间。<pre><code>// namespace members defined outside the namespace must use qualified namescplusplus_primer::Sales_datacplusplus_primer::operator+(const Sales_data&amp; lhs, const Sales_data&amp; rhs)&#123;    Sales_data ret(lhs);    // ...&#125;</code></pre></li><li>模板特例化必须定义在原始模板所属的命名空间中。可以在命名空间内部添加模板特例化声明，而在外部对其进行定义。<pre><code>// we must declare the specialization as a member of stdnamespace std&#123;    template &lt;&gt; struct hash&lt;Sales_data&gt;;&#125;// having added the declaration for the specialization to std// we can define the specialization outside the std namespacetemplate &lt;&gt; struct std::hash&lt;Sales_data&gt;&#123;    size_t operator()(const Sales_data&amp; s) const    &#123;        return hash&lt;string&gt;()(s.bookNo) ^            hash&lt;unsigned&gt;()(s.units_sold) ^            hash&lt;double&gt;()(s.revenue);    &#125;    // other members as before&#125;;</code></pre></li><li>全局作用域中定义的名字被隐式添加到全局命名空间（global namespace）中。全局命名空间以隐式方式声明，在所有程序中都存在。</li><li>作用域运算符::可以用于全局命名空间的成员。因为全局命名空间是隐式声明的，所以它并没有名字。</li><li>命名空间可以嵌套。嵌套的命名空间同时也是一个嵌套的作用域，它嵌套在外层命名空间的作用域内。内层命名空间声明的名字会隐藏外层命名空间的同名成员。在嵌套的命名空间中定义的名字只在内层命名空间中有效，外层命名空间中的代码在访问时需要在名字前添加限定符。</li><li>C++11新增了内联命名空间（inline namespace）。和一般的嵌套命名空间不同，内联命名空间中的名字可以被外层命名空间直接使用。定义内联命名空间的方式是在namespace前添加关键字inline。inline必须出现在该命名空间第一次定义的地方。<pre><code>inline namespace FifthEd&#123;    // namespace for the code from the Primer Fifth Edition&#125;namespace FifthEd&#123;   // implicitly inline    class Query_base &#123; /* ... */ &#125;;    // other Query-related declarations&#125;</code></pre></li><li>当应用程序的代码在两次发布之间发生了改变时，通常会使用内联命名空间。<pre><code>namespace FourthEd&#123;    class Item_base &#123; /* ... */&#125;;    class Query_base &#123; /* ... */&#125;;    // other code from the Fourth Edition&#125;namespace cplusplus_primer&#123;    #include &quot;FifthEd.h&quot;    #include &quot;FourthEd.h&quot;&#125;</code></pre></li><li>因为FifthEd是内联的，所以形如cplusplus_primer::的代码可以直接获得FifthEd的成员。如果想使用早期版本，则必须加上完整的外层命名空间名字。</li><li>未命名的命名空间（unnamed namespace）指关键字namespace后紧跟以花括号包围的一系列声明语句。未命名的命名空间中定义的变量拥有静态生命周期：它们在第一次使用前创建，直到程序结束才销毁。</li><li>一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件。每个文件定义自己的未命名的命名空间。如果一个头文件定义了未命名的命名空间，则该命名空间中定义的名字在每个包含该头文件的文件中对应不同实体。</li><li>定义在未命名的命名空间中的名字可以直接使用，不能对其使用作用域运算符。</li><li>定义在未命名的命名空间中的名字的作用域与该命名空间所在的作用域相同。如果未命名的命名空间定义在最外层作用域中，则该命名空间中的名字必须要与全局作用域中的名字有所区别。<pre><code>int i; // global declaration for inamespace&#123;    int i;&#125;// ambiguous: defined globally and in an unnested, unnamed namespacei = 10;namespace local&#123;    namespace    &#123;        int i;    &#125;&#125;// ok: i defined in a nested unnamed namespace is distinct from global ilocal::i = 42;</code></pre></li><li>在标准C++引入命名空间的概念之前，程序需要将名字声明为static的以令其对整个文件有效。在文件中进行静态声明的做法是从C语言继承而来的。在C语言中，声明为static的全局实体在其所在的文件之外不可见。该做法已经被C++标准取消，现在应该使用未命名的命名空间。</li></ul><h3 id="18-2-2-使用命名空间成员"><a href="#18-2-2-使用命名空间成员" class="headerlink" title="18.2.2 使用命名空间成员"></a>18.2.2 使用命名空间成员</h3><ul><li>可以使用关键字namespace和&#x3D;为命名空间定义别名（namespace alias）。别名必须出现在命名空间的定义之后。<br>  <code>namespace primer = cplusplus_primer;</code></li><li>一个命名空间可以有多个别名，它们都与命名空间的原名等价。</li><li>一条using声明（using declaration）一次只引入命名空间的一个成员。</li><li>using声明的有效范围从using声明语句开始，一直到using声明所在的作用域结束为止。在此过程中，外层作用域的同名实体会被隐藏。未加限定的名字只能在using声明所在的作用域及其内层作用域中使用。</li><li>using声明可以出现在全局作用域、局部作用域、命名空间作用域和类的作用域中。在类的作用域中使用时，using声明只能指向基类成员。</li><li>和using声明不同，using指示使某个命名空间中的所有名字都可见</li><li>using指示可以出现在全局作用域、局部作用域和命名空间作用域中，不能出现在类的作用域中。</li><li>如果对std等命名空间使用了using指示而未做任何特殊控制的话，会重新引入多个库之间的名字冲突问题。</li><li>using指示具有将命名空间成员提升到包含命名空间本身和using指示的最近外层作用域的能力。<pre><code>// namespace A and function f are defined at global scopenamespace A&#123;    int i, j;&#125;void f()&#123;    using namespace A;  // injects the names from A into the global scope    cout &lt;&lt; i * j &lt;&lt; endl;  // uses i and j from namespace A    // ...&#125;</code></pre></li><li>当命名空间被注入到其外层作用域之后，该命名空间中定义的名字可能会与其外层作用域的成员冲突。这种冲突允许存在，但是要想使用冲突的名字，就必须明确指出名字的版本。<pre><code>namespace blip&#123;    int i = 16, j = 15, k = 23;    // other declarations&#125;int j = 0;  // ok: j inside blip is hidden inside a namespacevoid manip()&#123;    // using directive; the names in blip are &#39;&#39;added&#39;&#39; to the global scope    using namespace blip;   // clash between ::j and blip::j    // detected only if j is used    ++i;    // sets blip::i to 17    ++j;    // error ambiguous: global j or blip::j?    ++::j;  // ok: sets global j to 1    ++blip::j;    // ok: sets blip::j to 16    int k = 97;   // local k hides blip::k    ++k;    // sets local k to 98&#125;</code></pre></li><li>头文件如果在其顶层作用域中使用using声明或using指示，则会将名字注入到包含该头文件的所有文件中。通常，头文件只负责定义接口部分的名字，而不定义实现部分的名字。因此，头文件最多只能在它的函数或命名空间内使用using声明或using指示。</li><li>相比于使用using指示，在程序中对命名空间中的每个成员分别使用using声明效果更好。<ul><li>如果程序使用了多个不同的库，而这些库中的名字通过using指示变得可见，则全局命名空间污染问题将重新出现。</li><li>using指示引发的二义性错误只有在使用了冲突名字的地方才会被发现。而using声明引发的二义性错误在声明处就能发现。</li></ul></li><li>建议在命名空间本身的实现文件中使用using指示。</li></ul><h3 id="18-2-3-类、命名空间与作用域"><a href="#18-2-3-类、命名空间与作用域" class="headerlink" title="18.2.3 类、命名空间与作用域"></a>18.2.3 类、命名空间与作用域</h3><ul><li>对命名空间内部名字的查找遵循常规查找规则：由内向外依次查找每个外层作用域。只有位于开放的块中且在使用点之前声明的名字才会被考虑。</li><li>对于位于命名空间中的类来说，名字的常规查找规则依然适用：当成员函数使用某个名字时，首先在该成员中查找，然后在类（包括基类）中查找，接着在外层作用域中查找。</li><li>可以从函数的限定名推断出名字查找时检查作用域的顺序，限定名以相反的顺序指出被查找的作用域。</li><li>命名空间中名字的隐藏规则有一个例外：传递给函数一个类类型的对象、指向类的引用或指针时，除了在常规作用域查找名字外，还会查找实参类所属的命名空间。该例外允许概念上作为类接口一部分的非成员函数无须单独的using声明就能被程序使用。<pre><code>std::string s;std::cin &gt;&gt; s;// 等价于std::operator&gt;&gt;(std::cin, s);// 若该规则不存在，则必须为&gt;&gt;运算符提供using声明using std::operator&gt;&gt;;// 或者显式使用std::operator&gt;&gt;std::operator&gt;&gt;(std::cin, s);</code></pre></li><li>标准库定义的move和forward模板函数接受一个右值引用形参，可以匹配任何类型。如果应用程序也定义了一个接受单一参数的move和forward函数，则不管形参是什么类型，都会与标准库的版本冲突。对于这两个函数来说，冲突大多是无意的，因此建议使用它们的含有限定语的完整版本（即std::move、std::forward）。</li><li>如果一个未声明的类或函数第一次出现在友元声明中，则会被认定是离它最近的外层命名空间的成员。</li></ul><h3 id="18-2-4-重载与命名空间"><a href="#18-2-4-重载与命名空间" class="headerlink" title="18.2.4 重载与命名空间"></a>18.2.4 重载与命名空间</h3><ul><li>using声明和using指示能将某些函数添加到候选函数集。</li><li>确定候选函数集时，会在函数的每个实参类（以及实参类的基类）所属的命名空间中搜索候选函数。这些命名空间中所有与被调用函数同名的函数都会被添加到候选集当中，即使其中某些函数在调用语句处不可见也是如此。</li><li>using声明语句声明的是一个名字，而非一个特定的函数。一个using声明囊括了重载函数的所有版本以确保不违反命名空间的接口。<pre><code>using NS::print(int);   // error: cannot specify a parameter listusing NS::print;        // ok: using declarations specify names only</code></pre></li><li>一个using声明引入的函数将重载该声明语句所属作用域中已有的其他同名函数。如果using声明出现在局部作用域中，则引入的名字会隐藏外层作用域的相关声明。如果using声明所在的作用域中已经有一个函数与引入的函数同名且形参列表相同，则该using声明会引发错误。除此之外，using声明将为引入的名字添加额外的重载实例，并最终扩充候选函数集的规模。</li><li>using指示将命名空间的成员提升到外层作用域中，如果命名空间的某个函数与该命名空间所属作用域中的函数同名，则命名空间的函数会被添加到重载集合中。</li><li>与using声明不同，using指示引入一个与已有函数形参列表完全相同的函数并不会引发错误。但需要明确指出调用的是命名空间中的函数版本还是当前作用域中的版本。</li><li>如果存在多个using指示，则来自每个命名空间的名字都会成为候选函数集的一部分。</li></ul><h2 id="18-3-多重继承与虚继承"><a href="#18-3-多重继承与虚继承" class="headerlink" title="18.3 多重继承与虚继承"></a>18.3 多重继承与虚继承</h2><ul><li>多重继承（Multiple inheritance）是指从多个直接基类中产生派生类的能力。多重继承的派生类继承了所有父类的属性。</li></ul><h3 id="18-3-1-多重继承"><a href="#18-3-1-多重继承" class="headerlink" title="18.3.1 多重继承"></a>18.3.1 多重继承</h3><ul><li>派生类的派生列表中可以包含多个基类。每个基类都包含一个可选的访问说明符。和单继承相同，如果访问说明符被省略，则关键字class对应的默认访问说明符是private，关键字struct对应的是public。<pre><code>class Bear : public ZooAnimal &#123; /* ... */ &#125;;class Panda : public Bear, public Endangered &#123; /* ... */ &#125;;</code></pre></li><li>和单继承相同，多重继承的派生列表也只能包含已经被定义过的类，且这些类不能是final的。</li><li>多重继承关系中，派生类对象包含每个基类的子对象</li><li>构造一个多重继承的派生类对象将同时构造并初始化它的所有基类子对象。<pre><code>// explicitly initialize both base classesPanda::Panda(std::string name, bool onExhibit)    : Bear(name, onExhibit, &quot;Panda&quot;),    Endangered(Endangered::critical) &#123; &#125;// implicitly uses the Bear default constructor to initialize the Bear subobjectPanda::Panda()    : Endangered(Endangered::critical) &#123; &#125;</code></pre></li><li>派生类的构造函数初始值列表将实参分别传递给每个直接基类。其中基类的构造顺序与派生列表中基类的出现顺序一致，与构造函数初始值列表中基类的顺序无关。</li><li>C++11允许派生类从它的一个或多个基类中继承构造函数，但如果从多个基类中继承了相同的构造函数（即形参列表完全相同），程序会产生错误。<pre><code>struct Base1&#123;    Base1() = default;    Base1(const std::string&amp;);    Base1(std::shared_ptr&lt;int&gt;);&#125;;struct Base2&#123;    Base2() = default;    Base2(const std::string&amp;);    Base2(int);&#125;;// error: D1 attempts to inherit D1::D1 (const string&amp;) from both base classesstruct D1: public Base1, public Base2&#123;    using Base1::Base1;   // inherit constructors from Base1    using Base2::Base2;   // inherit constructors from Base2&#125;;</code></pre></li><li>如果一个类从它的多个基类中继承了相同的构造函数，则必须为该构造函数定义其自己的版本。<pre><code>struct D2: public Base1, public Base2&#123;    using Base1::Base1;    // inherit constructors from Base1    using Base2::Base2;    // inherit constructors from Base2    // D2 must define its own constructor that takes a string    D2(const string &amp;s): Base1(s), Base2(s) &#123; &#125;    D2() = default;   // needed once D2 defines its own constructor&#125;;</code></pre></li><li>和单继承相同，多重继承的派生类如果定义了自己的拷贝&#x2F;赋值构造函数和赋值运算符，则必须在完整的对象上执行这些操作。只有当派生类使用的是合成版本的拷贝、移动或赋值成员时，才会自动处理其基类部分。在合成版本的拷贝控制成员中，每个基类分别使用自己的对应成员隐式地完成构造、赋值或销毁等工作。</li></ul><h3 id="18-3-2-类型转换与多个基类"><a href="#18-3-2-类型转换与多个基类" class="headerlink" title="18.3.2 类型转换与多个基类"></a>18.3.2 类型转换与多个基类</h3><ul><li>多重继承和单继承相同，某个可访问基类的指针或引用可以直接指向派生类对象。</li><li>编译器不会在派生类向基类的几种转换中进行比较和选择。<pre><code>void print(const Bear&amp;);void print(const Endangered&amp;);Panda ying_yang(&quot;ying_yang&quot;);print(ying_yang);   // error: ambiguous</code></pre></li><li>和单继承相同，对象、指针和引用的静态类型决定了我们可以使用的成员。</li></ul><h3 id="18-3-3-多重继承下的类作用域"><a href="#18-3-3-多重继承下的类作用域" class="headerlink" title="18.3.3 多重继承下的类作用域"></a>18.3.3 多重继承下的类作用域</h3><ul><li>在单继承中，派生类的作用域嵌套在直接基类和间接基类的作用域中。名称查找沿着继承体系自底向上进行，直到找到所需的名字。派生类的名字会隐藏基类的同名成员。在多重继承中，相同的查找过程在所有基类中同时进行。如果名字在多个基类中都被找到，则会产生二义性错误。</li><li>派生类可以从多个基类中分别继承名字相同的成员，但是在使用该名字时必须明确指出其版本。避免潜在二义性的最好方法是在派生类中定义新的版本。</li></ul><h3 id="18-3-4-虚继承"><a href="#18-3-4-虚继承" class="headerlink" title="18.3.4 虚继承"></a>18.3.4 虚继承</h3><ul><li>尽管在派生列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类。派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接继承某个基类，然后通过另一个基类再次间接继承该类。</li><li>默认情况下，派生类含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了多次，则派生类中会包含该类的多个子对象。这种默认情况对某些类并不适用。例如iostream，它直接继承自istream和ostream，而istream和ostream都继承自base_ios，所以iostream继承了base_ios两次。如果iostream对象包含base_ios的两份拷贝，则无法在同一个缓冲区中进行读写操作。</li><li>虚继承可以让某个类共享它的基类，其中共享的基类子对象称为虚基类（virtual base class）。在该机制下，不论虚基类在继承体系中出现了多少次，派生类都只包含唯一一个共享的虚基类子对象。</li><li>通常情况下，使用虚继承的类层次是由一个人或一个项目组一次性设计完成的。对于一个独立开发的类来说，很少需要基类中的某一个是虚基类，况且新基类的开发者也无法改变已存在的类体系。</li><li>虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。</li><li>指定虚基类的方式是在派生列表中添加关键字virtual。<pre><code>// the order of the keywords public and virtual is not significantclass Raccoon : public virtual ZooAnimal &#123; /* ... */ &#125;;class Bear : virtual public ZooAnimal &#123; /* ... */ &#125;;</code></pre></li><li>如果某个类指定了虚基类，则该类的派生仍按照常规方式进行。</li><li>不论基类是不是虚基类，派生类对象都能被可访问基类的指针或引用操作。</li><li>因为在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被直接访问，而且不会产生二义性。此外，如果虚基类的成员只被一条派生路径覆盖，则也可以直接访问该成员。但如果成员被多个基类覆盖，则一般情况下派生类必须为该成员定义新的版本。例如，假设类B定义了一个名为X的成员，D1和D2都从B虚继承得到，D继承了D1和D2。则在D的作用域中，X通过D的两个基类都是可见的。如果通过D的对象使用X，则有三种可能性：<ul><li>如果D1和D2中都没有X的定义，则X会被解析为B的成员，此时不存在二义性。</li><li>如果D1和D2中的某一个定义了X，派生类的X会比共享虚基类B的X优先级更高，此时同样没有二义性。</li><li>如果D1和D2都定义了X，则直接访问X会产生二义性问题。</li></ul></li></ul><h3 id="18-3-5-构造函数与虚继承"><a href="#18-3-5-构造函数与虚继承" class="headerlink" title="18.3.5 构造函数与虚继承"></a>18.3.5 构造函数与虚继承</h3><ul><li>在虚派生中，虚基类是由最低层的派生类初始化的。如果按普通规则处理，虚基类将会在多条继承路径上被重复初始化。</li><li>继承体系中的每个类都可能在某个时刻成为“最低层的派生类”。只要能创建虚基类的派生类对象，该派生类的构造函数就必须初始化它的虚基类。即使虚基类不是派生类的直接基类，构造函数也可以进行初始化。</li><li>构造含有虚基类的对象时，首先使用提供给最低层派生类构造函数的初始值初始化该对象的虚基类子部分，之后再按照直接基类在派生列表中出现的顺序依次对其初始化。</li><li>一个类可以有多个虚基类，此时这些虚子对象按照它们在派生列表中出现的顺序依次构造。</li></ul><h1 id="第19章-特殊工具与技术"><a href="#第19章-特殊工具与技术" class="headerlink" title="第19章 特殊工具与技术"></a>第19章 特殊工具与技术</h1><h2 id="19-1-控制内存分配（Controlling-Memory-Allocation）"><a href="#19-1-控制内存分配（Controlling-Memory-Allocation）" class="headerlink" title="19.1 控制内存分配（Controlling Memory Allocation）"></a>19.1 控制内存分配（Controlling Memory Allocation）</h2><h3 id="19-1-1-重载new和delete（Overloading-new-and-delete）"><a href="#19-1-1-重载new和delete（Overloading-new-and-delete）" class="headerlink" title="19.1.1 重载new和delete（Overloading new and delete）"></a>19.1.1 重载new和delete（Overloading new and delete）</h3><p>使用<code>new</code>表达式时，实际执行了三步操作：</p><ul><li><code>new</code>表达式调用名为<code>operator new</code>（或<code>operator new[]</code>）的标准库函数。该函数分配一块足够大、原始、未命名的内存空间以便存储特定类型的对象（或对象数组）。</li><li>编译器调用对应的构造函数构造这些对象并初始化。</li><li>对象被分配了空间并构造完成，返回指向该对象的指针。</li></ul><p>使用<code>delete</code>表达式时，实际执行了两步操作：</p><ul><li>对指针所指向的对象（或对象数组）执行对应的析构函数。</li><li>编译器调用名为<code>operator delete</code>（或<code>operator delete[]</code>）的标准库函数释放内存空间。</li></ul><p>如果程序希望控制内存分配的过程，则需要定义自己的<code>operator new</code>和<code>operator delete</code>函数。编译器会用自定义版本替换标准库版本。</p><p>程序可以在全局作用域中定义<code>operator new</code>和<code>operator delete</code>函数，也可以将其定义为成员函数。编译器发现<code>new</code>或<code>delete</code>表达式后，将在程序中查找可供调用的<code>operator</code>函数。如果被分配或释放的对象是类类型，编译器会先在类及其基类的作用域中查找。如果该类含有<code>operator</code>成员，则表达式会调用这些成员。否则编译器会继续在全局作用域查找。如果找到自定义版本，则使用该版本的函数。如果没找到，则使用标准库定义的版本。</p><p>可以使用作用域运算符令<code>new</code>或<code>delete</code>表达式忽略定义在类中的函数，直接执行全局作用域版本。</p><p>标准库定义了<code>operator new</code>和<code>operator delete</code>函数的8个重载版本，其中前4个版本可能抛出<code>bad_alloc</code>异常，后4个版本不会抛出异常。重载这些运算符时，必须使用关键字<code>noexcept</code>指定其不抛出异常。</p><pre class=" language-c++"><code class="language-c++">// these versions might throw an exceptionvoid *operator new(size_t);     // allocate an objectvoid *operator new[](size_t);   // allocate an arrayvoid *operator delete(void*) noexcept;      // free an objectvoid *operator delete[](void*) noexcept;    // free an array// versions that promise not to throwvoid *operator new(size_t, nothrow_t&) noexcept;void *operator new[](size_t, nothrow_t&) noexcept;void *operator delete(void*, nothrow_t&) noexcept;void *operator delete[](void*, nothrow_t&) noexcept</code></pre><p><code>nothrow_t</code>类型是定义在头文件<em>new</em>中的一个结构体，这个类型不包含任何成员。头文件<em>new</em>还定义了一个名为<code>nothrow</code>的<code>const</code>对象，用户可以通过这个对象请求<code>new</code>的非抛出版本。</p><p>将<code>operator</code>函数定义为类的成员时，它们是隐式静态的，无须显式地声明<code>static</code>。因为<code>operator new</code>用在对象构造之前，<code>operator delete</code>用在对象销毁之后，所以它们必须是静态成员，而且不能操纵类的任何数据成员。</p><p><code>operator new</code>和<code>operator new[]</code>函数的返回类型必须是<code>void*</code>，第一个形参的类型必须是<code>size_t</code>且不能有默认实参。编译器调用<code>operator new</code>时，用存储指定类型对象所需的字节数初始化<code>size_t</code>形参；调用<code>operator new[]</code>时，传入函数的则是存储数组中所有元素所需的空间。</p><p>自定义<code>operator new</code>函数时可以为它提供额外的形参，用到这些自定义函数的<code>new</code>表达式必须使用<code>new</code>的定位形式传递参数。下面这种形式的<code>new</code>函数只供标准库使用，不能被用户重定义：</p><pre class=" language-c++"><code class="language-c++">void *operator new(size_t, void*);   // this version may not be redefined</code></pre><p><code>operator delete</code>和<code>operator delete[]</code>函数的返回类型必须是<code>void</code>，第一个形参的类型必须是<code>void*</code>。函数被调用时，编译器会用指向待释放内存的指针来初始化<code>void*</code>形参。</p><p>将<code>operator delete</code>或<code>operator delete[]</code>定义为类的成员时，可以包含另一个类型为<code>size_t</code>的形参。该形参的初始值是第一个形参所指向对象的字节数。<code>size_t</code>形参可用于删除继承体系中的对象。如果基类有一个虚析构函数，则传递给<code>operator delete</code>的字节数会因待删除指针所指向对象的动态类型不同而有所区别。实际运行的<code>operator delete</code>函数版本也由对象的动态类型决定。</p><p><code>malloc</code>函数接受一个表示待分配字节数的<code>size_t</code>参数，返回指向分配空间的指针，或者返回0以表示分配失败。<code>free</code>函数接受一个<code>void*</code>参数，它是<code>malloc</code>返回的指针的副本，<code>free</code>将相关内存返回给系统。调用<code>free(0)</code>没有任何意义。</p><pre class=" language-c++"><code class="language-c++">void *operator new(size_t size){    if (void *mem = malloc(size))        return mem;    else        throw bad_alloc();}void operator delete(void *mem) noexcept{    free(mem);}</code></pre><h3 id="19-1-2-定位new表达式（Placement-new-Expressions）"><a href="#19-1-2-定位new表达式（Placement-new-Expressions）" class="headerlink" title="19.1.2 定位new表达式（Placement new Expressions）"></a>19.1.2 定位new表达式（Placement new Expressions）</h3><p>在C++的早期版本中，<code>allocator</code>类还不是标准库的一部分。如果程序想分开内存分配和初始化过程，需要直接调用<code>operator new</code>和<code>operator delete</code>函数。它们类似<code>allocator</code>类的<code>allocate</code>和<code>deallocate</code>成员，负责分配或释放内存空间，但不会构造或销毁对象。</p><p>不能使用<code>allocator</code>类的<code>construct</code>函数在<code>operator new</code>分配的内存空间中构造对象，而应该使用定位<code>new</code>表达式构造。</p><pre class=" language-c++"><code class="language-c++">new (place_address) typenew (place_address) type (initializers)new (place_address) type [size]new (place_address) type [size] { braced initializer list }</code></pre><p>其中<em>place_address</em>是一个指针。<em>initializers</em>是一个以逗号分隔的初始值列表（可能为空），该列表用于构造新分配的对象。</p><p>当仅通过一个地址值调用定位<code>new</code>时，它会使用<code>operator new(size_t, void*)</code>函数（用户无法重载的版本）。该函数不分配任何内存，直接返回指针形参。然后由<code>new</code>表达式负责在指定的地址初始化对象。</p><p>传递给<code>construct</code>函数的指针必须指向同一个<code>allocator</code>对象分配的空间，但是传递给定位<code>new</code>的指针无须指向<code>operator new</code>分配的内存，甚至不需要指向动态内存。</p><p>调用析构函数会销毁对象，但不会释放内存。如果需要的话，可以重新使用该空间。</p><h2 id="19-2-运行时类型识别（Run-Time-Type-Identification）"><a href="#19-2-运行时类型识别（Run-Time-Type-Identification）" class="headerlink" title="19.2 运行时类型识别（Run-Time Type Identification）"></a>19.2 运行时类型识别（Run-Time Type Identification）</h2><p>运行时类型识别（RTTI）的功能由两个运算符实现：</p><ul><li><code>typeid</code>运算符，用于返回表达式的类型。</li><li><code>dynamic_cast</code>运算符，用于将基类的指针或引用安全地转换为派生类的指针或引用。</li></ul><p>RTTI运算符适用于以下情况：想通过基类对象的指针或引用执行某个派生类操作，并且该操作不是虚函数。</p><h3 id="19-2-1-dynamic-cast运算符（The-dynamic-cast-Operator）"><a href="#19-2-1-dynamic-cast运算符（The-dynamic-cast-Operator）" class="headerlink" title="19.2.1 dynamic_cast运算符（The dynamic_cast Operator）"></a>19.2.1 dynamic_cast运算符（The dynamic_cast Operator）</h3><p><code>dynamic_cast</code>运算符的形式如下：</p><pre class=" language-c++"><code class="language-c++">dynamic_cast<type*>(e)dynamic_cast<type&>(e)dynamic_cast<type&&>(e)</code></pre><p>其中<em>type</em>是一个类类型，并且通常情况下该类型应该含有虚函数。在第一种形式中，<em>e</em>必须是一个有效指针；在第二种形式中，<em>e</em>必须是一个左值；在第三种形式中，<em>e</em>不能是左值。在所有形式中，<em>e</em>的类型必须符合以下条件之一：</p><ul><li><em>e</em>是<em>type</em>的公有派生类。</li><li><em>e</em>是<em>type</em>的公有基类。</li><li><em>e</em>和<em>type</em>类型相同。</li></ul><p>如果条件符合，则类型转换成功，否则转换失败。转换失败可能有两种结果：</p><ul><li><p>如果<code>dynamic_cast</code>语句的转换目标是指针类型，则结果为0。</p><pre class=" language-c++"><code class="language-c++">if (Derived *dp = dynamic_cast<Derived*>(bp)){    // use the Derived object to which dp points}else{   // bp points at a Base object    // use the Base object to which bp points}</code></pre></li><li><p>如果<code>dynamic_cast</code>语句的转换目标是引用类型，则抛出<code>bad_cast</code>异常（定义在头文件<em>typeinfo</em>中）。</p><pre class=" language-c++"><code class="language-c++">void f(const Base &b){    try     {        const Derived &d = dynamic_cast<const Derived&>(b);        // use the Derived object to which b referred    }    catch (bad_cast)    {        // handle the fact that the cast failed    }}</code></pre></li></ul><p>在条件判断部分执行<code>dynamic_cast</code>可以确保类型转换和结果检查在同一条表达式中完成。</p><p>可以对一个空指针执行<code>dynamic_cast</code>，结果是所需类型的空指针。</p><h3 id="19-2-2-typeid运算符（The-typeid-Operator）"><a href="#19-2-2-typeid运算符（The-typeid-Operator）" class="headerlink" title="19.2.2 typeid运算符（The typeid Operator）"></a>19.2.2 typeid运算符（The typeid Operator）</h3><p><code>typeid</code>表达式的形式是<code>typeid(e)</code>，其中<em>e</em>可以是任意表达式或类型名称。<code>typeid</code>的结果是一个指向常量对象的引用，该对象的类型是标准库<code>type_info</code>（定义在头文件<em>typeinfo</em>中）或<code>type_info</code>的公有派生类型。</p><p><code>typeid</code>可以作用于任何类型的表达式，其中的顶层<code>const</code>会被忽略。如果表达式是一个引用，则<code>typeid</code>返回该引用所指对象的类型。当<code>typeid</code>作用于数组或函数时，不会执行向指针的标准类型转换。</p><p>当<code>typeid</code>的运算对象不属于类类型或者是一个不包含任何虚函数的类时，<code>typeid</code>返回其静态类型。而当运算对象是至少包含一个虚函数的类的左值时，<code>typeid</code>的结果直到运行期间才会确定。</p><p>通常情况下，<code>typeid</code>用于比较两条表达式的类型是否相同，或者比较一条表达式的类型是否与指定类型相同。</p><pre class=" language-c++"><code class="language-c++">C++Derived *dp = new Derived;Base *bp = dp;   // both pointers point to a Derived object// compare the type of two objects at run timeif (typeid(*bp) == typeid(*dp)){    // bp and dp point to objects of the same type}// test whether the run-time type is a specific typeif (typeid(*bp) == typeid(Derived)){    // bp actually points to a Derived}</code></pre><p><code>typeid</code>应该作用于对象。当<code>typeid</code>作用于指针时，返回的结果是该指针的静态编译类型。</p><pre class=" language-c++"><code class="language-c++">// test always fails: the type of bp is pointer to Baseif (typeid(bp) == typeid(Derived)){    // code never executed}</code></pre><p>只有当类型含有虚函数时，编译器才会对<code>typeid</code>的表达式求值以确定返回类型。对于<code>typeid(*p)</code>，如果指针<em>p</em>所指向的类型不包含虚函数，则<em>p</em>可以是一个无效指针。否则<code>*p</code>会在运行期间求值，此时<em>p</em>必须是一个有效指针。如果<em>p</em>是空指针，<code>typeid(*p)</code>会抛出<code>bad_typeid</code>异常。</p><h3 id="19-2-3-使用RTTI（Using-RTTI）"><a href="#19-2-3-使用RTTI（Using-RTTI）" class="headerlink" title="19.2.3 使用RTTI（Using RTTI）"></a>19.2.3 使用RTTI（Using RTTI）</h3><p>使用RTTI可以为具有继承关系的类实现相等运算符。</p><p>相等运算符的形参是基类的引用。</p><pre class=" language-c++"><code class="language-c++">class Base{    friend bool operator==(const Base&, const Base&);public:    // interface members for Baseprotected:    virtual bool equal(const Base&) const;    // data and other implementation members of Base};class Derived: public Base{public:    // other interface members for Derivedprotected:    bool equal(const Base&) const;    // data and other implementation members of Derived};</code></pre><p>使用<code>typeid</code>检查两个运算对象的类型是否一致，类型一致才会继续判断每个数据成员的取值是否相同。</p><pre class=" language-c++"><code class="language-c++">bool operator==(const Base &lhs, const Base &rhs){    // returns false if typeids are different; otherwise makes a virtual call to equal    return typeid(lhs) == typeid(rhs) && lhs.equal(rhs);}</code></pre><p>每个类定义的<code>equal</code>函数负责比较类型自己的数据成员。<code>equal</code>函数的形参都是基类的引用，但是在比较之前需要先把运算对象转换成自己的类型。</p><pre class=" language-c++"><code class="language-c++">bool Derived::equal(const Base &rhs) const{    // we know the types are equal, so the cast won't throw    auto r = dynamic_cast<const Derived&>(rhs);    // do the work to compare two Derived objects and return the result}bool Base::equal(const Base &rhs) const{// do whatever is required to compare to Base objects}</code></pre><h3 id="19-2-4-type-info类（The-type-info-Class）"><a href="#19-2-4-type-info类（The-type-info-Class）" class="headerlink" title="19.2.4 type_info类（The type_info Class）"></a>19.2.4 type_info类（The type_info Class）</h3><p><code>type_info</code>类的精确定义会根据编译器的不同而略有差异。但是C++规定<code>type_info</code>必须定义在头文件<em>typeinfo</em>中，并且至少提供以下操作：</p>)<p><code>type_info</code>类一般是作为一个基类出现，所以它还应该提供一个公有虚析构函数。当编译器希望提供额外的类型信息时，通常在<code>type_info</code>的派生类中完成。</p><p><code>type_info</code>类没有默认构造函数，而且它的拷贝和移动构造函数以及赋值运算符都被定义为删除的。创建<code>type_info</code>对象的唯一方式就是使用<code>typeid</code>运算符。</p><p>对于某种给定类型来说，<code>name</code>成员的返回值因编译器而异并且不一定与在程序中使用的名字一致。对于<code>name</code>返回值的唯一要求就是类型不同则返回的字符串必须有所区别。</p><h2 id="19-3-枚举类型（Enumerations）"><a href="#19-3-枚举类型（Enumerations）" class="headerlink" title="19.3 枚举类型（Enumerations）"></a>19.3 枚举类型（Enumerations）</h2><p>和类一样，每个枚举类型都定义了一种新的类型。枚举属于字面值常量类型。</p><p>C++包含两种枚举：</p><ul><li><p>限定作用域的枚举（scoped enumeration，C++11新增）。定义形式是关键字<code>enum class</code>（或<code>enum struct</code>）后接枚举类型名字以及用花括号包围、以逗号分隔的枚举成员（enumerator）列表。</p><pre class=" language-c++"><code class="language-c++">enum class open_modes{    input,    output,    append};</code></pre></li><li><p>不限定作用域的枚举（unscoped enumeration）。定义时省略关键字<code>class</code>（或<code>struct</code>），枚举类型名字是可选的。</p><pre class=" language-c++"><code class="language-c++">C++// unscoped enumerationenum color{    red,    yellow,    green};// unnamed, unscoped enumenum{    floatPrec = 6,    doublePrec = 10,    double_doublePrec = 10};</code></pre><p>如果枚举是未命名的，则只能在定义该枚举时一同定义它的对象。</p></li></ul><p>在限定作用域的枚举类型中，枚举成员的名字遵循常规作用域规则，并且在枚举类型的作用域外是不可访问的。与之相反，在不限定作用域的枚举类型中，枚举成员的作用域与枚举类型本身的作用域相同。</p><pre class=" language-c++"><code class="language-c++">enum color { red, yellow, green };   // unscoped enumerationenum stoplight { red, yellow, green };   // error: redefines enumeratorsenum class peppers { red, yellow, green };   // ok: enumerators are hiddencolor eyes = green;    // ok: enumerators are in scope for an unscoped enumerationpeppers p = green;     // error: enumerators from peppers are not in scope// color::green is in scope but has the wrong typecolor hair = color::red;      // ok: we can explicitly access the enumeratorspeppers p2 = peppers::red;    // ok: using red from peppers</code></pre><p>默认情况下，枚举值从0开始，依次加1。也可以直接为枚举成员指定特定的值。</p><pre class=" language-c++"><code class="language-c++">enum class intTypes{    charTyp = 8, shortTyp = 16, intTyp = 16,    longTyp = 32, long_longTyp = 64};</code></pre><p>枚举值可以不唯一。如果没有显式提供初始值，则当前枚举成员的值等于之前枚举成员的值加1。</p><p>枚举成员是<code>const</code>的，因此在初始化枚举成员时提供的初始值必须是常量表达式。</p><p>可以在任何需要常量表达式的地方使用枚举成员。如：</p><ul><li>定义枚举类型的<code>constexpr</code>变量。</li><li>将枚举类型对象作为<code>switch</code>语句的表达式，而将枚举值作为<code>case</code>标签。</li><li>将枚举类型作为非类型模板形参使用。</li><li>在类的定义中初始化枚举类型的静态数据成员。</li></ul><p>初始化枚举对象或者给枚举对象赋值时，必须使用该类型的一个枚举成员或者该类型的另一个对象。即使某个整型值恰好与枚举成员的值相等，也不能用其初始化枚举对象。</p><pre class=" language-c++"><code class="language-c++">open_modes om = 2;        // error: 2 is not of type open_modesom = open_modes::input;   // ok: input is an enumerator of open_modes</code></pre><p>不限定作用域的枚举类型对象或枚举成员能自动转换成整型。</p><pre class=" language-c++"><code class="language-c++">int i = color::red;     // ok: unscoped enumerator implicitly converted to intint j = peppers::red;   // error: scoped enumerations are not implicitly converted</code></pre><p>枚举是由某种整数类型表示的。C++11中，可以在枚举名字后面指定用来表示枚举成员的整型类型。</p><pre class=" language-c++"><code class="language-c++">enum intValues : unsigned long long{     /*...*/ };</code></pre><p>如果没有指定枚举的潜在类型，则默认情况下限定作用域的枚举成员类型是<code>int</code>。不限定作用域的枚举成员不存在默认类型。</p><p>C++11中可以提前声明枚举。枚举的前置声明必须指定（无论隐式或显式）其成员的类型。</p><pre class=" language-c++"><code class="language-c++">// forward declaration of unscoped enum named intValuesenum intValues : unsigned long long;    // unscoped, must specify a typeenum class open_modes;    // scoped enums can use int by default</code></pre><h2 id="19-4-类成员指针（Pointer-to-Class-Member）"><a href="#19-4-类成员指针（Pointer-to-Class-Member）" class="headerlink" title="19.4 类成员指针（Pointer to Class Member）"></a>19.4 类成员指针（Pointer to Class Member）</h2><p>成员指针（pointer to member）是指可以指向类的非静态成员的指针。</p><p>成员指针的类型包括类的类型和成员的类型。初始化成员指针时，会令其指向类的某个成员，但是不指定该成员所属的对象。直到使用成员指针时，才提供成员所属的对象。</p><h3 id="19-4-1-数据成员指针（Pointers-to-Data-Members）"><a href="#19-4-1-数据成员指针（Pointers-to-Data-Members）" class="headerlink" title="19.4.1 数据成员指针（Pointers to Data Members）"></a>19.4.1 数据成员指针（Pointers to Data Members）</h3><p>声明成员指针时必须在<code>*</code>前添加<code>classname::</code>以表示当前定义的指针可以指向<em>classname</em>的成员。</p><pre class=" language-c++"><code class="language-c++">class Screen{public:    typedef std::string::size_type pos;    char get_cursor() const { return contents[cursor]; }    char get() const;    char get(pos ht, pos wd) const;    private:    std::string contents;    pos cursor;    pos height, width;}// pdata can point to a string member of a const (or non const) Screen objectconst string Screen::*pdata;</code></pre><p>初始化或者给成员指针赋值时，需要指定它所指向的成员。</p><pre class=" language-c++"><code class="language-c++">pdata = &Screen::contents;</code></pre><p>成员指针使用<code>.*</code>和<code>-&gt;*</code>来获得其指向对象的成员。</p><pre class=" language-c++"><code class="language-c++">Screen myScreen, *pScreen = &myScreen;// .* dereferences pdata to fetch the contents member from the object myScreenauto s = myScreen.*pdata;// ->* dereferences pdata to fetch contents from the object to which pScreen pointss = pScreen->*pdata;</code></pre><p>常规的访问控制规则对成员指针同样有效。数据成员一般是私有的，因此通常不能直接获得数据成员的指针。如果类希望外部代码能访问它的私有数据成员，可以定义一个函数，令其返回指向私有成员的指针。</p><h3 id="19-4-2-成员函数指针（Pointers-to-Member-Functions）"><a href="#19-4-2-成员函数指针（Pointers-to-Member-Functions）" class="headerlink" title="19.4.2 成员函数指针（Pointers to Member Functions）"></a>19.4.2 成员函数指针（Pointers to Member Functions）</h3><p>类似于其他函数指针，指向成员函数的指针也需要指定目标函数的返回类型和形参列表。如果成员函数是<code>const</code>成员或引用成员，则指针也必须包含<code>const</code>或引用限定符。</p><pre class=" language-c++"><code class="language-c++">// pmf is a pointer that can point to a Screen member function that is const// that returns a char and takes no argumentsauto pmf = &Screen::get_cursor;</code></pre><p>如果成员函数存在重载问题，则必须显式声明指针指向的函数类型。</p><pre class=" language-c++"><code class="language-c++">char (Screen::*pmf2)(Screen::pos, Screen::pos) const;pmf2 = &Screen::get;</code></pre><p>和普通函数指针不同，在成员函数和指向该成员的指针之间不存在自动转换规则。</p><pre class=" language-c++"><code class="language-c++">// pmf points to a Screen member that takes no arguments and returns charpmf = &Screen::get;    // must explicitly use the address-of operatorpmf = Screen::get;     // error: no conversion to pointer for member functions</code></pre><p>成员函数指针使用<code>.*</code>和<code>-&gt;*</code>来调用类的成员函数。</p><pre class=" language-c++"><code class="language-c++">Screen myScreen, *pScreen = &myScreen;// call the function to which pmf points on the object to which pScreen pointschar c1 = (pScreen->*pmf)();// passes the arguments 0, 0 to the two-parameter version of get on the object myScreenchar c2 = (myScreen.*pmf2)(0, 0);</code></pre><p>可以使用类型别名来增强含有成员指针的代码的可读性。</p><h3 id="19-2-3-将成员函数用作可调用对象（Using-Member-Functions-as-Callable-Objects）"><a href="#19-2-3-将成员函数用作可调用对象（Using-Member-Functions-as-Callable-Objects）" class="headerlink" title="19.2.3 将成员函数用作可调用对象（Using Member Functions as Callable Objects）"></a>19.2.3 将成员函数用作可调用对象（Using Member Functions as Callable Objects）</h3><p>成员指针不是一个可调用对象，不支持函数调用运算符。</p><pre class=" language-c++"><code class="language-c++">auto fp = &string::empty;   // fp points to the string empty function// error: must use .* or ->* to call a pointer to memberfind_if(svec.begin(), svec.end(), fp);</code></pre><p>从成员函数指针获取可调用对象的一种方法是使用标准库模板<code>function</code>。</p><pre class=" language-c++"><code class="language-c++">function<bool (const string&)> fcn = &string::empty;find_if(svec.begin(), svec.end(), fcn);</code></pre><p>定义一个<code>function</code>对象时，必须指定该对象所能表示的函数类型（即可调用对象的形式）。如果可调用对象是一个成员函数，则第一个形参必须表示该成员是在哪个对象上执行的。</p><p>使用标准库功能<code>mem_fn</code>（定义在头文件<em>functional</em>中）可以让编译器推断成员的类型。和<code>function</code>一样，<code>mem_fn</code>可以从成员指针生成可调用对象。但<code>mem_fn</code>可以根据成员指针的类型推断可调用对象的类型，无须显式指定。</p><pre class=" language-c++"><code class="language-c++">find_if(svec.begin(), svec.end(), mem_fn(&string::empty));</code></pre><p><code>mem_fn</code>生成的可调用对象可以通过对象和指针调用。</p><pre class=" language-c++"><code class="language-c++">auto f = mem_fn(&string::empty);    // f takes a string or a string*f(*svec.begin());   // ok: passes a string object; f uses .* to call emptyf(&svec[0]);        // ok: passes a pointer to string; f uses .-> to call empty</code></pre><h2 id="19-5-嵌套类（Nested-Classes）"><a href="#19-5-嵌套类（Nested-Classes）" class="headerlink" title="19.5 嵌套类（Nested Classes）"></a>19.5 嵌套类（Nested Classes）</h2><p>一个类可以定义在另一个类的内部，前者被称为嵌套类或嵌套类型（nested type）。嵌套类通常用于定义作为实现部分的类。</p><p>外层类的对象和嵌套类的对象是相互独立的。在嵌套类对象中不包含任何外层类定义的成员，在外层类对象中也不包含任何嵌套类定义的成员。</p><p>嵌套类的名字在外层类作用域中是可见的，在外层类作用域之外不可见。</p><p>外层类对嵌套类的成员没有特殊的访问权限，嵌套类对外层类的成员也没有特殊的访问权限。</p><p>嵌套类在其外层类中定义了一个类型成员。和其他成员类似，该类型的访问权限由外层类的访问说明符决定。</p><p>嵌套类必须声明在类的内部，但是可以定义在类的内部或外部。在外层类之外定义嵌套类时，必须用外层类的名字限定嵌套类的名字。</p><pre class=" language-c++"><code class="language-c++">class TextQuery{    class QueryResult;  // nested class to be defined later};// we're defining the QueryResult class that is a member of class TextQueryclass TextQuery::QueryResult {    /*...*/};</code></pre><p>在嵌套类在其外层类之外完成真正的定义之前，它都是一个不完全类型。</p><h2 id="19-6-union：一种节省空间的类（union-A-Space-Saving-Class）"><a href="#19-6-union：一种节省空间的类（union-A-Space-Saving-Class）" class="headerlink" title="19.6 union：一种节省空间的类（union: A Space-Saving Class）"></a>19.6 union：一种节省空间的类（union: A Space-Saving Class）</h2><p>联合（union）是一种特殊的类。一个联合可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。给联合的某个成员赋值之后，其他成员会变为未定义状态。分配给联合对象的存储空间至少要能容纳它的最大数据成员。</p><p>联合不能包含引用类型的成员。在C++11中，含有构造函数或析构函数的类类型也可以作为联合的成员类型。</p><p>联合可以为其成员指定<code>public</code>、<code>protected</code>和<code>private</code>等保护标记。默认情况下，联合的成员都是公有的。</p><p>联合可以定义包括构造函数和析构函数在内的成员函数。但是由于联合既不能继承自其他类，也不能作为基类使用，所以在联合中不能含有虚函数。</p><p>定义联合时，首先是关键字<code>union</code>，随后是该联合的名字（可选）以及在花括号内的一组成员声明。</p><pre class=" language-c++"><code class="language-c++">// objects of type Token have a single member, which could be of any of the listed typesunion Token{    // members are public by default    char cval;    int ival;    double dval;};</code></pre><p>默认情况下，联合是未初始化的。可以像显式初始化聚合类一样显式初始化联合，提供的初始值会被用于初始化第一个成员。</p><pre class=" language-c++"><code class="language-c++">Token first_token = { 'a' };   // initializes the cval member</code></pre><p>可以使用通用的成员访问运算符访问联合对象的成员。</p><pre class=" language-c++"><code class="language-c++">last_token.cval = 'z';pt->ival = 42;</code></pre><p>匿名联合（anonymous union）是一个未命名的联合，并且在右花括号和分号之间没有任何声明。一旦定义了一个匿名联合，编译器就会自动地为该联合创建一个未命名的对象。在匿名联合的定义所在的作用域内，该联合的成员都是可以直接访问的。</p><pre class=" language-c++"><code class="language-c++">union{   // anonymous union    char cval;    int ival;    double dval;};  // defines an unnamed object, whose members we can access directlycval = 'c';   // assigns a new value to the unnamed, anonymous union objectival = 42;    // that object now holds the value 42</code></pre><p>匿名联合不能包含<code>protected</code>和<code>private</code>成员，也不能定义成员函数。</p><p>C++的早期版本规定，在联合中不能含有定义了构造函数或拷贝控制成员的类类型成员。C++11取消了该限制。但是如果联合的成员类型定义了自己的构造函数或拷贝控制成员，该联合的用法会比只含有内置类型成员的联合复杂得多。</p><ul><li>当联合只包含内置类型的成员时，可以使用普通的赋值语句改变联合的值。但是如果想将联合的值改为类类型成员对应的值，或者将类类型成员的值改为一个其他值，则必须构造或析构该类类型的成员。</li><li>当联合只包含内置类型的成员时，编译器会按照成员顺序依次合成默认构造函数或拷贝控制成员。但是如果联合含有类类型成员，并且该类型自定义了默认构造函数或拷贝控制成员，则编译器会为该联合合成对应的版本并将其声明为删除的。</li></ul><p>对于联合来说，构造或销毁类类型成员的操作非常复杂。通常情况下，可以把含有类类型成员的联合内嵌在另一个类中，这个类可以管理并控制与联合的类类型成员相关的状态转换。</p><h2 id="19-7-局部类（Local-Classes）"><a href="#19-7-局部类（Local-Classes）" class="headerlink" title="19.7 局部类（Local Classes）"></a>19.7 局部类（Local Classes）</h2><p>类可以定义在某个函数的内部，这种类被称为局部类。局部类定义的类型只能在定义它的作用域内可见。</p><p>局部类的所有成员（包括成员函数）都必须完整定义在类的内部，因此局部类的作用与嵌套类相比相差很远。</p><p>局部类中不允许声明静态数据成员。</p><p>局部类只能访问外层作用域定义的类型名、静态变量以及枚举成员，不能使用普通局部变量。</p><pre class=" language-c++"><code class="language-c++">int a, val;void foo(int val){    static int si;    enum Loc { a = 1024, b };    // Bar is local to foo    struct Bar     {        Loc locVal;    // ok: uses a local type name        int barVal;        void fooBar(Loc l = a)  // ok: default argument is Loc::a        {            barVal = val;    // error: val is local to foo            barVal = ::val;  // ok: uses a global object            barVal = si;     // ok: uses a static local object            locVal = b;      // ok: uses an enumerator        }    };    // . . .}</code></pre><p>常规的访问保护规则对于局部类同样适用。外层函数对局部类的私有成员没有任何访问特权。局部类可以将外层函数声明为友元。</p><p>可以在局部类的内部再嵌套一个类。此时嵌套类的定义可以出现在局部类之外，不过嵌套类必须定义在与局部类相同的作用域中。</p><pre class=" language-c++"><code class="language-c++">void foo(){    class Bar    {    public:        class Nested;   // declares class Nested    };        // definition of Nested    class Bar::Nested    {    };}</code></pre><p>局部类内的嵌套类也是一个局部类，必须遵循局部类的各种规定。</p><h2 id="19-8-固有的不可移植的特性（Inherently-Nonportable-Features）"><a href="#19-8-固有的不可移植的特性（Inherently-Nonportable-Features）" class="headerlink" title="19.8 固有的不可移植的特性（Inherently Nonportable Features）"></a>19.8 固有的不可移植的特性（Inherently Nonportable Features）</h2><h3 id="19-8-1位域（Bit-fields）"><a href="#19-8-1位域（Bit-fields）" class="headerlink" title="19.8.1位域（Bit-fields）"></a>19.8.1位域（Bit-fields）</h3><p>类可以将其非静态数据成员定义成位域，在一个位域中含有一定数量的二进制位。当程序需要向其他程序或硬件设备传递二进制数据时，通常会使用位域。</p><p>位域的声明形式是在成员名字之后紧跟一个冒号和一个常量表达式，该表达式用于指定成员所占的二进制位数。</p><p>位域的类型必须是整型或枚举类型。因为带符号位域的行为是由具体实现确定的，所以通常情况下使用无符号类型保存位域。位域类型的大小不能小于位域结构的总大小。</p><pre class=" language-c++"><code class="language-c++">struct Descriptor{    // error: should use unsigned long long    unsigned int LimitLow : 16;    unsigned int BaseLow : 24;    unsigned int Attribute : 16;    unsigned int BaseHigh : 8;}</code></pre><p>定义位域时建议结合<code>#pragma pack</code>指令将结构体对齐值修改为1，防止数据结构错位。</p><pre class=" language-c++"><code class="language-c++">// 保存原始对齐值，设置新对齐#pragma pack(push, 1)// 结构体定义……// 恢复原始对齐值#pragma pack(pop)</code></pre><p>位域成员按定义顺序在内存中由低地址向高地址排列，具体布局与机器相关。</p><p>取地址符<code>&amp;</code>不能作用于位域，因此任何指针都无法指向类的位域。</p><p>如果可能的话，类内部连续定义的位域会压缩在同一整数的相邻位，从而提供存储压缩。</p><p>访问位域的方式与访问类的其他数据成员的方式类似。操作超过1位的位域时，通常会使用内置的位运算符。</p><pre class=" language-c++"><code class="language-c++">File &File::open(File::modes m){    mode |= READ;   // set the READ bit by default    // other processing    if (m & WRITE)  // if opening READ and WRITE        // processing to open the file in read/write mode        return *this;}</code></pre><h3 id="19-8-2-volatile限定符（volatile-Qualifier）"><a href="#19-8-2-volatile限定符（volatile-Qualifier）" class="headerlink" title="19.8.2 volatile限定符（volatile Qualifier）"></a>19.8.2 volatile限定符（volatile Qualifier）</h3><p>当对象的值可能在程序的控制或检测之外被改变时（如子线程），应该将该对象声明为<code>volatile</code>。关键字<code>volatile</code>的作用是告知编译器不要优化这样的对象。</p><p><code>volatile</code>的确切含义与机器有关，只能通过查阅编译器文档来理解。要想让一个使用了<code>volatile</code>的程序在移植到新机器或新编译器后仍然有效，通常需要对该程序进行一些修改。</p><p><code>volatile</code>的用法和<code>const</code>类似，都是对类型的额外修饰。二者相互之间并没有影响。</p><pre class=" language-c++"><code class="language-c++">volatile int display_register;   // int value that might changevolatile Task *curr_task;        // curr_task points to a volatile objectvolatile int iax[max_size];      // each element in iax is volatile</code></pre><p>类可以将成员函数定义为<code>volatile</code>的。<code>volatile</code>对象只能调用<code>volatile</code>成员函数。</p><p><code>volatile</code>和指针的关系类似<code>const</code>。可以声明<code>volatile</code>指针、指向<code>volatile</code>对象的指针和指向<code>volatile</code>对象的<code>volatile</code>指针。</p><pre class=" language-c++"><code class="language-c++">volatile int v;      // v is a volatile intint *volatile vip;   // vip is a volatile pointer to intvolatile int *ivp;   // ivp is a pointer to volatile int// vivp is a volatile pointer to volatile intvolatile int *volatile vivp;int *ip = &v;   // error: must use a pointer to volatile*ivp = &v;      // ok: ivp is a pointer to volatilevivp = &v;      // ok: vivp is a volatile pointer to volatile</code></pre><p>不能使用合成的拷贝&#x2F;移动构造函数和赋值运算符初始化<code>volatile</code>对象或者给<code>volatile</code>对象赋值。合成的成员接受的形参类型是非<code>volatile</code>常量引用，不能把非<code>volatile</code>引用绑定到<code>volatile</code>对象上。</p><p>如果类需要拷贝、移动或赋值它的<code>volatile</code>对象，则必须自定义拷贝或移动操作。</p><pre class=" language-c++"><code class="language-c++">class Foo{public:    Foo(const volatile Foo&); // copy from a volatile object    // assign from a volatile object to a nonvolatile object    Foo& operator=(volatile const Foo&);    // assign from a volatile object to a volatile object    Foo& operator=(volatile const Foo&) volatile;    // remainder of class Foo};</code></pre><h3 id="19-8-3-链接指示：extern-“C”（Linkage-Directives：extern-“C”）"><a href="#19-8-3-链接指示：extern-“C”（Linkage-Directives：extern-“C”）" class="headerlink" title="19.8.3 链接指示：extern “C”（Linkage Directives：extern “C”）"></a>19.8.3 链接指示：extern “C”（Linkage Directives：extern “C”）</h3><p>C++程序有时需要调用使用其他语言编写的函数，最常见的是调用C语言函数。其他语言中的函数名字也必须在C++中进行声明。对于这些函数，编译器检查其调用的方式与处理普通C++函数的方式相同，但是生成的代码有所区别。C++使用链接指示指出任意非C++函数所用的语言。</p><p>链接指示有单个形式和复合形式，其不能出现在类定义或函数定义的内部。同样的链接指示必须出现在函数的每个声明处。</p><pre class=" language-c++"><code class="language-c++">// illustrative linkage directives that might appear in the C++ header <cstring>// single-statement linkage directiveextern "C" size_t strlen(const char *);// compound-statement linkage directiveextern "C"{    int strcmp(const char*, const char*);    char *strcat(char*, const char*);}</code></pre><p>链接指示包含关键字<code>extern</code>、字符串字面值常量和一个函数声明。其中的字符串字面值常量指出了编写函数所用的语言。</p><p>复合形式的链接指示可以应用于整个头文件。当一个<code>#include</code>指示被放置在复合链接指示的花括号中时，头文件中的所有函数声明都会被认为是由链接指示的语言编写的。链接指示可以嵌套，因此如果头文件包含自带链接指示的函数，该函数不会受到影响。</p><pre class=" language-c++"><code class="language-c++">// compound-statement linkage directiveextern "C"{    #include <string.h>   // C functions that manipulate C-style strings}</code></pre><p>C++从C语言继承的标准库函数可以定义成C函数，但并非必须。选择使用C还是C++实现C标准库，是由每个C++实现决定的。</p><p>编写函数所使用的语言是函数类型的一部分。因此对于使用链接指示定义的函数来说，它的每个声明都必须使用相同的链接指示，而且指向这类函数的指针也必须使用与函数本身一样的链接指示。</p><pre class=" language-c++"><code class="language-c++">// pf points to a C function that returns void and takes an intextern "C" void (*pf)(int);</code></pre><p>指向C函数的指针与指向C++函数的指针是不同的类型，两者不能相互赋值或初始化（少数C++编译器支持这种赋值操作并将其视为对语言的扩展，但是从严格意义上来说它是非法的）。</p><pre class=" language-c++"><code class="language-c++">void (*pf1)(int);   // points to a C++ functionextern "C" void (*pf2)(int);    // points to a C functionpf1 = pf2;   // error: pf1 and pf2 have different types</code></pre><p>链接指示不仅对函数本身有效，对作为返回类型或形参类型的函数指针也有效。所以如果希望给C++函数传入指向C函数的指针，必须使用类型别名。</p><pre class=" language-c++"><code class="language-c++">// f1 is a C function; its parameter is a pointer to a C functionextern "C" void f1(void(*)(int));// FC is a pointer to a C functionextern "C" typedef void FC(int);// f2 is a C++ function with a parameter that is a pointer to a C functionvoid f2(FC *);</code></pre><p>通过链接指示定义函数，可以令C++函数在其他语言编写的程序中可用。编译器会为该函数生成适合于指定语言的代码。</p><pre class=" language-c++"><code class="language-c++">// the calc function can be called from C programsextern "C" double calc(double dparm) { /* ... */ }</code></pre><p>如果需要在C和C++中编译同一个源文件，可以在编译C++版本时使用预处理定义<code>__cplusplus</code>。</p><pre class=" language-c++"><code class="language-c++"># ifdef __cplusplus// ok: we're compiling C++extern "C"# endifint strcmp(const char*, const char*);</code></pre><p>链接指示与重载函数的相互作用依赖于目标语言。C语言不支持函数重载，所以一个C链接指示只能用于说明一组重载函数中的某一个。</p><pre class=" language-c++"><code class="language-c++">// error: two extern "C" functions with the same nameextern "C" void print(const char*);extern "C" void print(int);</code></pre>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++,编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建</title>
      <link href="/2020/01/08/qian-duan/bo-ke-da-jian/"/>
      <url>/2020/01/08/qian-duan/bo-ke-da-jian/</url>
      
        <content type="html"><![CDATA[<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><ol><li>下载<a href="https://nodejs.org/en/">node.js</a>  </li><li>创建一个空文件blog，打开git bash。 </li><li>查看node.js和npm是否安装成功。</li></ol><pre class=" language-bash"><code class="language-bash">    node -v    <span class="token function">npm</span> -v</code></pre><ol start="4"><li>切换nmp的源。 <pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g cnmp --registry<span class="token operator">=</span>https://registry.npm.taobao.org</code></pre></li><li>安装hexo。<pre class=" language-bash"><code class="language-bash">cnpm <span class="token function">install</span> -g hexo-cli</code></pre></li><li>查看hexo是否安装完成。<pre class=" language-bash"><code class="language-bash">hexo -v</code></pre></li></ol><h3 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h3><ol><li>生成博客:<code>hexo init</code>。</li><li>在本地运行hexo : <code>hexo s</code> 或者 <code>hexo server</code>。</li><li>在本地浏览器打开localhost:4000就可以看到博客了。</li><li>创建新的文章：<code>hexo n &quot;first article&quot;</code>或者<code>hexo new &quot; &quot;</code>,文章存在的地址是<code>source\_posts</code>目录下。可以直接修改，编写即可。<ul><li>添加文件的时候指定路径 -p <code>hexo n -p c++/test.md &quot;test&quot;</code></li></ul></li><li>生成静态文件:<code>hexo g</code>或者<code>hexo generate</code>。</li></ol><h3 id="部署到github上"><a href="#部署到github上" class="headerlink" title="部署到github上"></a>部署到github上</h3><ol><li>在github官网，创建新的仓库，名字必须是你的用户名加上github加io，如<code>xxxx.github.io</code>。</li><li>安装git插件:<code>cnmp install --save hexo-deployer-git</code>。</li><li>修改目录下的_config.yml文件，修改deployment。<pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">deployment</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> git    <span class="token key atrule">repo</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//github.com/xxxxx/xxxxx.github.io.git</code></pre></li><li>部署到远程仓库上面<code>hexo deploy</code>或者<code>hexo d</code>，需要输入github账号密码,浏览器输入<code>xxxx.github.io</code>即可访问。</li></ol><h3 id="博客主题更换"><a href="#博客主题更换" class="headerlink" title="博客主题更换"></a>博客主题更换</h3><ol><li>下载主题到themes文件夹下。</li><li>更改_config.yml文件中的themes为themes文件夹下的一个主题<code>thems: xxxxx</code>。</li></ol><h3 id="hexo-theme-matery主题安装和配置"><a href="#hexo-theme-matery主题安装和配置" class="headerlink" title="hexo-theme-matery主题安装和配置"></a>hexo-theme-matery主题安装和配置</h3><h4 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h4><ol><li><a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master">下载地址</a>,也可以使用github下载，在themes文件下右键git bash，输入命令<code>git clone https://github.com/blinkfox/hexo-theme-matery.git</code>即可下载。</li><li>下载完成后，更改配置文件_config.yml,找到themes修改为hexo-theme-matery。</li><li>在_config.yml中添加站点信息，及url信息。<pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># Site</span><span class="token key atrule">title</span><span class="token punctuation">:</span> 苏北之<span class="token key atrule">subtitle</span><span class="token punctuation">:</span> <span class="token string">'What is broken can be reforged!'</span><span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token key atrule">keywords</span><span class="token punctuation">:</span> c++<span class="token punctuation">,</span>java<span class="token punctuation">,</span>后台开发<span class="token key atrule">author</span><span class="token punctuation">:</span> gaobo <span class="token key atrule">language</span><span class="token punctuation">:</span> zh<span class="token punctuation">-</span>Hans <span class="token key atrule">timezone</span><span class="token punctuation">:</span> UTC</code></pre></li></ol><h4 id="创建分类页"><a href="#创建分类页" class="headerlink" title="创建分类页"></a>创建分类页</h4><ul><li><p>使用命令窗口，切换到博客根目录，然后输入下面命令：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"categories"</span></code></pre></li><li><p>编译刚创建的页面文件<code>source/categoried/index</code>，至少需要如下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">title</span><span class="token punctuation">:</span> categories<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2020-01-08 15:28:13</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"categories"</span></code></pre></li></ul><h4 id="创建标签tags页"><a href="#创建标签tags页" class="headerlink" title="创建标签tags页"></a>创建标签tags页</h4><ul><li><p><code>tags</code>也是用来展示所有标签的页面，创建标签的命令如下:</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"tags"</span></code></pre></li><li><p>创建的标签页需要包含如下内容:</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">title</span><span class="token punctuation">:</span> categories<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2020-01-08 15:28:13</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"categories"</span></code></pre></li></ul><h4 id="创建关于我about页"><a href="#创建关于我about页" class="headerlink" title="创建关于我about页"></a>创建关于我about页</h4><ul><li><p><code>about</code>是用来展示关于我和我的博客的信息页面，创建关于我的命令如下:</p><pre class=" language-bash"><code class="language-bash">hexo n page <span class="token string">"about"</span></code></pre></li><li><p>创建的关于我标签需要包含以下内容:</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">title</span><span class="token punctuation">:</span> about<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2020-01-08 15:28:13</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"about"</span></code></pre></li></ul><h4 id="创建友情链接"><a href="#创建友情链接" class="headerlink" title="创建友情链接"></a>创建友情链接</h4><ul><li><p>创建友情链接界面，命令如下:</p><pre class=" language-bash"><code class="language-bash">hexo n page <span class="token string">"friends"</span></code></pre></li><li><p>创建的链接界面需要包含如下内容:</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">title</span><span class="token punctuation">:</span> categories<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2020-01-08 15:28:13</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"categories"</span></code></pre></li><li><p>在<code>source</code>目录下创建<code>_data</code>目录，在目录中创建<code>friends.json</code>文件，文件内容如下:</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">[</span><span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/1_qq_27922023.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"码酱"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"我不是大佬，只是在追寻大佬的脚步"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://luokangyuan.com/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/4027734.jpeg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"闪烁之狐"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://blinkfox.github.io/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/avatar.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"ja_rome"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"平凡的脚步也可以走出伟大的行程"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"ttps://me.csdn.net/jlh912008548"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre></li></ul><h4 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h4><ul><li><p>使用主题<a href="https://github.com/ele828/hexo-prism-plugin">hexo-prism-plugin</a>插件来做代码的高亮，使用npm安装命令如下:</p><pre class=" language-bash"><code class="language-bash">cnpm i -S hexo-prism-plugin</code></pre></li><li><p>修改hexo中的<code>_config.yml</code>中的<code>highlight.enable</code>的值为<code>false</code>,并且增加prism的配置如下:</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">prism_plugin</span><span class="token punctuation">:</span><span class="token key atrule">mode</span><span class="token punctuation">:</span> <span class="token string">'preprocess'</span>    <span class="token comment" spellcheck="true"># realtime/preprocess</span><span class="token key atrule">theme</span><span class="token punctuation">:</span> <span class="token string">'default'</span><span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">false    </span><span class="token comment" spellcheck="true"># default false</span><span class="token key atrule">custom_css</span><span class="token punctuation">:</span></code></pre></li></ul><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><ul><li>可以使用<a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a>插件做内容的搜索，安装命令如下:<pre class=" language-bash"><code class="language-bash">cnpm <span class="token function">install</span> hexo-generator-search --save</code></pre></li><li>修改<code>_config.yml</code>文件，增加以下的选项:<pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">search</span><span class="token punctuation">:</span>     <span class="token key atrule">path</span><span class="token punctuation">:</span> search.xml    <span class="token key atrule">field</span><span class="token punctuation">:</span> post</code></pre><blockquote><p><strong>注意</strong>：使用npm下载文件的时候确保在更目录下，不然会出现错误。</p></blockquote></li></ul><h4 id="中文链接转拼音"><a href="#中文链接转拼音" class="headerlink" title="中文链接转拼音"></a>中文链接转拼音</h4><ul><li><p>如果链接是中文的那么文章的地址中也是中文的，<a href="https://github.com/viko16/hexo-permalink-pinyin">hexo-permalink-pinyin</a>可以将中文转为英文。</p></li><li><p>安装命令如下:</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-permalink-pinyin --save</code></pre></li><li><p>修改<code>_config.yml</code>如下:</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">permalink_pinyin</span><span class="token punctuation">:</span>    <span class="token key atrule">ennable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">seperator</span><span class="token punctuation">:</span> <span class="token string">'-'</span></code></pre></li></ul><h4 id="文章字数统计"><a href="#文章字数统计" class="headerlink" title="文章字数统计"></a>文章字数统计</h4><ul><li>在文章中显示文章字数、阅读时长的信息，可以安装<a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>插件。命令如下:<pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i --save hexo-wordcount</code></pre></li><li>需要修改<code>_config.yml</code>文件:<pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">wordcount</span><span class="token punctuation">:</span>    <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 将这个值设置为 true 即可.</span>    <span class="token key atrule">postWordCount</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">min2read</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">totalCount</span><span class="token punctuation">:</span> <span class="token boolean important">true    </span></code></pre></li></ul><h4 id="添加RSS订阅支持"><a href="#添加RSS订阅支持" class="headerlink" title="添加RSS订阅支持"></a>添加RSS订阅支持</h4><ul><li>使用<a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a>插件添加RSS订阅支持，安装命令如下:<pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-feed --save</code></pre></li><li>修改<code>_config.yml</code>文件:<pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">feed</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> atom    <span class="token key atrule">path</span><span class="token punctuation">:</span> atom.xml    <span class="token key atrule">limit</span><span class="token punctuation">:</span> <span class="token number">20</span>    <span class="token key atrule">hub</span><span class="token punctuation">:</span>    <span class="token key atrule">content</span><span class="token punctuation">:</span>    <span class="token key atrule">content_limit</span><span class="token punctuation">:</span> <span class="token number">140</span>    <span class="token key atrule">content_limit_delim</span><span class="token punctuation">:</span> <span class="token string">' '</span>    <span class="token key atrule">order_by</span><span class="token punctuation">:</span> <span class="token punctuation">-</span>date</code></pre></li></ul><h4 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h4><ul><li>修改页脚的文件在<code>/layout/_partical/footer.ejs</code>文件中。可以修改最后站点的访问量或者等。</li></ul><h4 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h4><ul><li>在<code>/layout/_partial/social-link.ejs</code>可以增加或者删除想要的社交链接。</li></ul><h4 id="修改打赏文件"><a href="#修改打赏文件" class="headerlink" title="修改打赏文件"></a>修改打赏文件</h4><ul><li>图片存放位置是<code>source/medias/reward</code>,如果替换了文件且修改了图片的名称，注意将<code>themes</code>下的<code>_config.yml</code>的<code>reward</code>,具体修改如下:<pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">reward</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">title</span><span class="token punctuation">:</span> 你的赏识是我前进的动力  <span class="token key atrule">wechat</span><span class="token punctuation">:</span> /medias/reward/weixin.jpg  <span class="token key atrule">alipay</span><span class="token punctuation">:</span> /medias/reward/zhifubao.jpg</code></pre></li></ul><h4 id="文章开头选项的填写"><a href="#文章开头选项的填写" class="headerlink" title="文章开头选项的填写"></a>文章开头选项的填写</h4><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>ojjkkkkk</td><td></td><td></td></tr></tbody></table><h4 id="修改背景颜色"><a href="#修改背景颜色" class="headerlink" title="修改背景颜色"></a>修改背景颜色</h4><ul><li>修改<code>source/css/metery.css</code>中的bg-color即可。</li></ul><h4 id="添加评论区"><a href="#添加评论区" class="headerlink" title="添加评论区"></a>添加评论区</h4><ul><li><p>安装<a href="https://gitalk.github.io/">gitalk</a>安装方法如下:</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i --save gitalk</code></pre></li><li><p>修改主题下的<code>_config.yml</code>文件：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">gitalk</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">owner</span><span class="token punctuation">:</span> <span class="token string">'gaobo1112'</span>   <span class="token comment" spellcheck="true"># 替换为你自己的github用户名</span>  <span class="token key atrule">repo</span><span class="token punctuation">:</span> <span class="token string">'gaobo1112.github.io'</span> <span class="token comment" spellcheck="true"># 你想用那个仓库来添加评论</span>  <span class="token key atrule">oauth</span><span class="token punctuation">:</span>    <span class="token key atrule">clientId</span><span class="token punctuation">:</span> <span class="token string">'xxxxxxxxxxxxxxxxxxxxx'</span> <span class="token comment" spellcheck="true"># 创建oauth application的id和secret</span>    <span class="token key atrule">clientSecret</span><span class="token punctuation">:</span> <span class="token string">'xxxxxxxxxxxxxxxxxxxxxxxxxxx'</span>  <span class="token key atrule">admin</span><span class="token punctuation">:</span> <span class="token string">'gaobo1112'</span></code></pre></li><li><p>创建新的<a href="https://github.com/settings/applications/new">OAuth Application</a>，填写规则如下:</p><pre class=" language-yaml"><code class="language-yaml">appliaction name<span class="token punctuation">:</span> 随便起HomePage url<span class="token punctuation">:</span> 必须是你博客的地址Authorization callback URL<span class="token punctuation">:</span> 博客的地址</code></pre></li><li><blockquote><p>如果你的存放评论仓库中issue没有一条评论，先添加一条评论。</p></blockquote></li></ul><h4 id="解决hexo图片加载失败的问题"><a href="#解决hexo图片加载失败的问题" class="headerlink" title="解决hexo图片加载失败的问题"></a>解决hexo图片加载失败的问题</h4><ul><li><p>修改<code>_config.yaml</code>中的<code>post_asset_folder: true</code>。</p></li><li><p>资源<code>Asset</code>代表<code>source</code> 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在<code>source/images</code>文件夹中。然后通过类似于<code>![](/images/image.jpg)</code> 的方法访问它们。</p></li><li><p>当资源文件管理功能打开后，<code>Hexo</code>将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code>命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个 <code>markdown</code> 文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p></li><li><p>通过常规的 <code>markdown</code> 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在<code>Hexo 2</code>时代，社区创建了很多插件来解决这个问题。但是，随着<code>Hexo 3</code> 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。</p></li></ul><pre class=" language-md"><code class="language-md">{% asset_path slug %}{% asset_img slug [title] %}{% asset_img 图片名称 [图片说明] %}{% asset_link slug [title] %}</code></pre><h4 id="添加卡通人物"><a href="#添加卡通人物" class="headerlink" title="添加卡通人物"></a>添加卡通人物</h4><ul><li>下载安装<a href="https://github.com/EYHN/hexo-helper-live2d">live2d</a>:</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save hexo-helper-live2d </code></pre><ul><li>下载安装<a href="https://github.com/xiazeyu/live2d-widget-models">live2d-widget-models</a>，这里选择<code>karuto</code>作为实例。更多的<a href="https://huaji8.top/post/live2d-plugin-2.0/">模型地址</a>。</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> live2d-widget-model-haruto</code></pre><ul><li>修改<code>_config.yml</code>。</li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">live2d</span><span class="token punctuation">:</span>    <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">scriptFrom</span><span class="token punctuation">:</span> local    <span class="token key atrule">model</span><span class="token punctuation">:</span>         <span class="token key atrule">use</span><span class="token punctuation">:</span> live2d<span class="token punctuation">-</span>widget<span class="token punctuation">-</span>model<span class="token punctuation">-</span>haruto <span class="token comment" spellcheck="true">#模型选择</span>    <span class="token key atrule">display</span><span class="token punctuation">:</span>         <span class="token key atrule">position</span><span class="token punctuation">:</span> right  <span class="token comment" spellcheck="true">#模型位置</span>        <span class="token key atrule">width</span><span class="token punctuation">:</span> <span class="token number">150       </span><span class="token comment" spellcheck="true">#模型宽度</span>        <span class="token key atrule">height</span><span class="token punctuation">:</span> <span class="token number">300      </span><span class="token comment" spellcheck="true">#模型高度</span>    <span class="token key atrule">mobile</span><span class="token punctuation">:</span>         <span class="token key atrule">show</span><span class="token punctuation">:</span> <span class="token boolean important">false      </span><span class="token comment" spellcheck="true">#是否在手机端显示</span></code></pre><blockquote><p>注意：如果选择使用haru模型，下载命令是<code>npm install --save live2d-widget-model-haru</code>,并且要将node_modules&#x2F;_live2d-widget-model-haru…中的json文件分别移到子文件加01和02中。原来01和02的json文件是空的，不做这个操作会报错。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
